       """
       To ensure compatibility from Python ``2.6`` - ``3.3``, a module has been
       created. Clearly there is huge need to use conforming syntax.
    1: """
    1: import sys
    1: import platform
       
       # Cannot use sys.version.major and minor names, because in Python 2.6 it's not
       # a namedtuple.
    1: py_version = int(str(sys.version_info[0]) + str(sys.version_info[1]))
       
       # unicode function
    1: try:
    1:     unicode = unicode
    1: except NameError:
    1:     unicode = str
       
    1: is_pypy = platform.python_implementation() == 'PyPy'
       
       
    1: def use_metaclass(meta, *bases):
           """ Create a class with a metaclass. """
    1:     if not bases:
    1:         bases = (object,)
    1:     return meta("HackClass", bases, {})
       
       
    1: try:
    1:     encoding = sys.stdout.encoding
    1:     if encoding is None:
               encoding = 'utf-8'
       except AttributeError:
           encoding = 'ascii'
       
       
    1: def u(string):
           """Cast to unicode DAMMIT!
           Written because Python2 repr always implicitly casts to a string, so we
           have to cast back to a unicode (and we know that we always deal with valid
           unicode, because we check that in the beginning).
           """
           if py_version >= 30:
               return str(string)
       
           if not isinstance(string, unicode):
               return unicode(str(string), 'UTF-8')
           return string
       
       
    1: try:
    1:     FileNotFoundError = FileNotFoundError
       except NameError:
           FileNotFoundError = IOError
       
       
    1: def utf8_repr(func):
           """
           ``__repr__`` methods in Python 2 don't allow unicode objects to be
           returned. Therefore cast them to utf-8 bytes in this decorator.
           """
    4:     def wrapper(self):
               result = func(self)
               if isinstance(result, unicode):
                   return result.encode('utf-8')
               else:
                   return result
       
    4:     if py_version >= 30:
    4:         return func
           else:
               return wrapper
       
       
    1: try:
    1:     from functools import total_ordering
       except ImportError:
           # Python 2.6
           def total_ordering(cls):
               """Class decorator that fills in missing ordering methods"""
               convert = {
                   '__lt__': [('__gt__', lambda self, other: not (self < other or self == other)),
                              ('__le__', lambda self, other: self < other or self == other),
                              ('__ge__', lambda self, other: not self < other)],
                   '__le__': [('__ge__', lambda self, other: not self <= other or self == other),
                              ('__lt__', lambda self, other: self <= other and not self == other),
                              ('__gt__', lambda self, other: not self <= other)],
                   '__gt__': [('__lt__', lambda self, other: not (self > other or self == other)),
                              ('__ge__', lambda self, other: self > other or self == other),
                              ('__le__', lambda self, other: not self > other)],
                   '__ge__': [('__le__', lambda self, other: (not self >= other) or self == other),
                              ('__gt__', lambda self, other: self >= other and not self == other),
                              ('__lt__', lambda self, other: not self >= other)]
               }
               roots = set(dir(cls)) & set(convert)
               if not roots:
                   raise ValueError('must define at least one ordering operation: < > <= >=')
               root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__
               for opname, opfunc in convert[root]:
                   if opname not in roots:
                       opfunc.__name__ = opname
                       opfunc.__doc__ = getattr(int, opname).__doc__
                       setattr(cls, opname, opfunc)
               return cls
