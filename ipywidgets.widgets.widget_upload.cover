       # Copyright(c) Jupyter Development Team.
       # Distributed under the terms of the Modified BSD License.
       
       """FileUpload class.
       
       Represents a file upload button.
    1: """
       
    1: from traitlets import (
           observe, default, Unicode, Dict, List, Int, Bool, Bytes, CaselessStrEnum
       )
       
    1: from .widget_description import DescriptionWidget
    1: from .valuewidget import ValueWidget
    1: from .widget_core import CoreWidget
    1: from .widget_button import ButtonStyle
    1: from .widget import register, widget_serialization
    1: from .trait_types import bytes_serialization, InstanceDict
       
    1: def content_from_json(value, widget):
           """
           deserialize file content
           """
           from_json = bytes_serialization['from_json']
           output = [from_json(e, None) for e in value]
           return output
       
       
    2: @register
    1: class FileUpload(DescriptionWidget, ValueWidget, CoreWidget):
           """
           Upload file(s) from browser to Python kernel as bytes
    1:     """
    1:     _model_name = Unicode('FileUploadModel').tag(sync=True)
    1:     _view_name = Unicode('FileUploadView').tag(sync=True)
    1:     _counter = Int().tag(sync=True)
       
    1:     accept = Unicode(help='File types to accept, empty string for all').tag(sync=True)
    1:     multiple = Bool(help='If True, allow for multiple files upload').tag(sync=True)
    1:     disabled = Bool(help='Enable or disable button').tag(sync=True)
    1:     icon = Unicode('upload', help="Font-awesome icon name, without the 'fa-' prefix.").tag(sync=True)
    1:     button_style = CaselessStrEnum(
    1:         values=['primary', 'success', 'info', 'warning', 'danger', ''], default_value='',
    1:         help="""Use a predefined styling for the button.""").tag(sync=True)
    1:     style = InstanceDict(ButtonStyle).tag(sync=True, **widget_serialization)
    1:     metadata = List(Dict(), help='List of file metadata').tag(sync=True)
    1:     data = List(Bytes(), help='List of file content (bytes)').tag(
    1:         sync=True, from_json=content_from_json
           )
    1:     error = Unicode(help='Error message').tag(sync=True)
    1:     value = Dict(read_only=True)
       
    1:     @observe('_counter')
           def on_incr_counter(self, change):
               """
               counter increment triggers the update of trait value
               """
               res = {}
               msg = 'Error: length of metadata and data must be equal'
               assert len(self.metadata) == len(self.data), msg
               for metadata, content in zip(self.metadata, self.data):
                   name = metadata['name']
                   res[name] = {'metadata': metadata, 'content': content}
               self.set_trait('value', res)
       
    1:     @default('description')
           def _default_description(self):
               return 'Upload'
