       # -*- coding: utf-8 -*-
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       #    http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
       # implied.
       # See the License for the specific language governing permissions and
       # limitations under the License.
    1: """Module for the regular expressions crafted from ABNF."""
       
    1: import sys
       
       # https://tools.ietf.org/html/rfc3986#page-13
    1: GEN_DELIMS = GENERIC_DELIMITERS = ":/?#[]@"
    1: GENERIC_DELIMITERS_SET = set(GENERIC_DELIMITERS)
       # https://tools.ietf.org/html/rfc3986#page-13
    1: SUB_DELIMS = SUB_DELIMITERS = "!$&'()*+,;="
    1: SUB_DELIMITERS_SET = set(SUB_DELIMITERS)
       # Escape the '*' for use in regular expressions
    1: SUB_DELIMITERS_RE = r"!$&'()\*+,;="
    1: RESERVED_CHARS_SET = GENERIC_DELIMITERS_SET.union(SUB_DELIMITERS_SET)
    1: ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    1: DIGIT = '0123456789'
       # https://tools.ietf.org/html/rfc3986#section-2.3
    1: UNRESERVED = UNRESERVED_CHARS = ALPHA + DIGIT + r'._!-'
    1: UNRESERVED_CHARS_SET = set(UNRESERVED_CHARS)
    1: NON_PCT_ENCODED_SET = RESERVED_CHARS_SET.union(UNRESERVED_CHARS_SET)
       # We need to escape the '-' in this case:
    1: UNRESERVED_RE = r'A-Za-z0-9._~\-'
       
       # Percent encoded character values
    1: PERCENT_ENCODED = PCT_ENCODED = '%[A-Fa-f0-9]{2}'
    1: PCHAR = '([' + UNRESERVED_RE + SUB_DELIMITERS_RE + ':@]|%s)' % PCT_ENCODED
       
       # NOTE(sigmavirus24): We're going to use more strict regular expressions
       # than appear in Appendix B for scheme. This will prevent over-eager
       # consuming of items that aren't schemes.
    1: SCHEME_RE = '[a-zA-Z][a-zA-Z0-9+.-]*'
    1: _AUTHORITY_RE = '[^/?#]*'
    1: _PATH_RE = '[^?#]*'
    1: _QUERY_RE = '[^#]*'
    1: _FRAGMENT_RE = '.*'
       
       # Extracted from http://tools.ietf.org/html/rfc3986#appendix-B
       COMPONENT_PATTERN_DICT = {
    1:     'scheme': SCHEME_RE,
    1:     'authority': _AUTHORITY_RE,
    1:     'path': _PATH_RE,
    1:     'query': _QUERY_RE,
    1:     'fragment': _FRAGMENT_RE,
       }
       
       # See http://tools.ietf.org/html/rfc3986#appendix-B
       # In this case, we name each of the important matches so we can use
       # SRE_Match#groupdict to parse the values out if we so choose. This is also
       # modified to ignore other matches that are not important to the parsing of
       # the reference so we can also simply use SRE_Match#groups.
       URL_PARSING_RE = (
    1:     r'(?:(?P<scheme>{scheme}):)?(?://(?P<authority>{authority}))?'
           r'(?P<path>{path})(?:\?(?P<query>{query}))?'
           r'(?:#(?P<fragment>{fragment}))?'
    1: ).format(**COMPONENT_PATTERN_DICT)
       
       
       # #########################
       # Authority Matcher Section
       # #########################
       
       # Host patterns, see: http://tools.ietf.org/html/rfc3986#section-3.2.2
       # The pattern for a regular name, e.g.,  www.google.com, api.github.com
    1: REGULAR_NAME_RE = REG_NAME = '((?:{0}|[{1}])*)'.format(
    1:     '%[0-9A-Fa-f]{2}', SUB_DELIMITERS_RE + UNRESERVED_RE
       )
       # The pattern for an IPv4 address, e.g., 192.168.255.255, 127.0.0.1,
    1: IPv4_RE = r'([0-9]{1,3}\.){3}[0-9]{1,3}'
       # Hexadecimal characters used in each piece of an IPv6 address
    1: HEXDIG_RE = '[0-9A-Fa-f]{1,4}'
       # Least-significant 32 bits of an IPv6 address
    1: LS32_RE = '({hex}:{hex}|{ipv4})'.format(hex=HEXDIG_RE, ipv4=IPv4_RE)
       # Substitutions into the following patterns for IPv6 patterns defined
       # http://tools.ietf.org/html/rfc3986#page-20
    1: _subs = {'hex': HEXDIG_RE, 'ls32': LS32_RE}
       
       # Below: h16 = hexdig, see: https://tools.ietf.org/html/rfc5234 for details
       # about ABNF (Augmented Backus-Naur Form) use in the comments
       variations = [
           #                            6( h16 ":" ) ls32
    1:     '(%(hex)s:){6}%(ls32)s' % _subs,
           #                       "::" 5( h16 ":" ) ls32
    1:     '::(%(hex)s:){5}%(ls32)s' % _subs,
           # [               h16 ] "::" 4( h16 ":" ) ls32
    1:     '(%(hex)s)?::(%(hex)s:){4}%(ls32)s' % _subs,
           # [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    1:     '((%(hex)s:)?%(hex)s)?::(%(hex)s:){3}%(ls32)s' % _subs,
           # [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    1:     '((%(hex)s:){0,2}%(hex)s)?::(%(hex)s:){2}%(ls32)s' % _subs,
           # [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    1:     '((%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s' % _subs,
           # [ *4( h16 ":" ) h16 ] "::"              ls32
    1:     '((%(hex)s:){0,4}%(hex)s)?::%(ls32)s' % _subs,
           # [ *5( h16 ":" ) h16 ] "::"              h16
    1:     '((%(hex)s:){0,5}%(hex)s)?::%(hex)s' % _subs,
           # [ *6( h16 ":" ) h16 ] "::"
    1:     '((%(hex)s:){0,6}%(hex)s)?::' % _subs,
       ]
       
    1: IPv6_RE = '(({0})|({1})|({2})|({3})|({4})|({5})|({6})|({7})|({8}))'.format(
    1:     *variations
       )
       
    1: IPv_FUTURE_RE = r'v[0-9A-Fa-f]+\.[%s]+' % (
    1:     UNRESERVED_RE + SUB_DELIMITERS_RE + ':'
       )
       
       # RFC 6874 Zone ID ABNF
    1: ZONE_ID = '(?:[' + UNRESERVED_RE + ']|' + PCT_ENCODED + ')+'
       
    1: IPv6_ADDRZ_RFC4007_RE = IPv6_RE + '(?:(?:%25|%)' + ZONE_ID + ')?'
    1: IPv6_ADDRZ_RE = IPv6_RE + '(?:%25' + ZONE_ID + ')?'
       
    1: IP_LITERAL_RE = r'\[({0}|{1})\]'.format(
    1:     IPv6_ADDRZ_RFC4007_RE,
    1:     IPv_FUTURE_RE,
       )
       
       # Pattern for matching the host piece of the authority
    1: HOST_RE = HOST_PATTERN = '({0}|{1}|{2})'.format(
    1:     REG_NAME,
    1:     IPv4_RE,
    1:     IP_LITERAL_RE,
       )
    1: USERINFO_RE = '^([' + UNRESERVED_RE + SUB_DELIMITERS_RE + ':]|%s)+' % (
    1:     PCT_ENCODED
       )
    1: PORT_RE = '[0-9]{1,5}'
       
       # ####################
       # Path Matcher Section
       # ####################
       
       # See http://tools.ietf.org/html/rfc3986#section-3.3 for more information
       # about the path patterns defined below.
       segments = {
    1:     'segment': PCHAR + '*',
           # Non-zero length segment
    1:     'segment-nz': PCHAR + '+',
           # Non-zero length segment without ":"
    1:     'segment-nz-nc': PCHAR.replace(':', '') + '+'
       }
       
       # Path types taken from Section 3.3 (linked above)
    1: PATH_EMPTY = '^$'
    1: PATH_ROOTLESS = '%(segment-nz)s(/%(segment)s)*' % segments
    1: PATH_NOSCHEME = '%(segment-nz-nc)s(/%(segment)s)*' % segments
    1: PATH_ABSOLUTE = '/(%s)?' % PATH_ROOTLESS
    1: PATH_ABEMPTY = '(/%(segment)s)*' % segments
    1: PATH_RE = '^(%s|%s|%s|%s|%s)$' % (
    1:     PATH_ABEMPTY, PATH_ABSOLUTE, PATH_NOSCHEME, PATH_ROOTLESS, PATH_EMPTY
       )
       
       FRAGMENT_RE = QUERY_RE = (
    1:     '^([/?:@' + UNRESERVED_RE + SUB_DELIMITERS_RE + ']|%s)*$' % PCT_ENCODED
       )
       
       # ##########################
       # Relative reference matcher
       # ##########################
       
       # See http://tools.ietf.org/html/rfc3986#section-4.2 for details
    1: RELATIVE_PART_RE = '(//%s%s|%s|%s|%s)' % (
    1:     COMPONENT_PATTERN_DICT['authority'],
    1:     PATH_ABEMPTY,
    1:     PATH_ABSOLUTE,
    1:     PATH_NOSCHEME,
    1:     PATH_EMPTY,
       )
       
       # See http://tools.ietf.org/html/rfc3986#section-3 for definition
    1: HIER_PART_RE = '(//%s%s|%s|%s|%s)' % (
    1:     COMPONENT_PATTERN_DICT['authority'],
    1:     PATH_ABEMPTY,
    1:     PATH_ABSOLUTE,
    1:     PATH_ROOTLESS,
    1:     PATH_EMPTY,
       )
       
       # ###############
       # IRIs / RFC 3987
       # ###############
       
       # Only wide-unicode gets the high-ranges of UCSCHAR
    1: if sys.maxunicode > 0xFFFF:  # pragma: no cover
    1:     IPRIVATE = u'\uE000-\uF8FF\U000F0000-\U000FFFFD\U00100000-\U0010FFFD'
           UCSCHAR_RE = (
    1:         u'\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF'
               u'\U00010000-\U0001FFFD\U00020000-\U0002FFFD'
               u'\U00030000-\U0003FFFD\U00040000-\U0004FFFD'
               u'\U00050000-\U0005FFFD\U00060000-\U0006FFFD'
               u'\U00070000-\U0007FFFD\U00080000-\U0008FFFD'
               u'\U00090000-\U0009FFFD\U000A0000-\U000AFFFD'
               u'\U000B0000-\U000BFFFD\U000C0000-\U000CFFFD'
               u'\U000D0000-\U000DFFFD\U000E1000-\U000EFFFD'
           )
       else:  # pragma: no cover
           IPRIVATE = u'\uE000-\uF8FF'
           UCSCHAR_RE = (
               u'\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF'
           )
       
    1: IUNRESERVED_RE = u'A-Za-z0-9\\._~\\-' + UCSCHAR_RE
    1: IPCHAR = u'([' + IUNRESERVED_RE + SUB_DELIMITERS_RE + u':@]|%s)' % PCT_ENCODED
       
       isegments = {
    1:     'isegment': IPCHAR + u'*',
           # Non-zero length segment
    1:     'isegment-nz': IPCHAR + u'+',
           # Non-zero length segment without ":"
    1:     'isegment-nz-nc': IPCHAR.replace(':', '') + u'+'
       }
       
    1: IPATH_ROOTLESS = u'%(isegment-nz)s(/%(isegment)s)*' % isegments
    1: IPATH_NOSCHEME = u'%(isegment-nz-nc)s(/%(isegment)s)*' % isegments
    1: IPATH_ABSOLUTE = u'/(?:%s)?' % IPATH_ROOTLESS
    1: IPATH_ABEMPTY = u'(?:/%(isegment)s)*' % isegments
    1: IPATH_RE = u'^(?:%s|%s|%s|%s|%s)$' % (
    1:     IPATH_ABEMPTY, IPATH_ABSOLUTE, IPATH_NOSCHEME, IPATH_ROOTLESS, PATH_EMPTY
       )
       
    1: IREGULAR_NAME_RE = IREG_NAME = u'(?:{0}|[{1}])*'.format(
    1:     u'%[0-9A-Fa-f]{2}', SUB_DELIMITERS_RE + IUNRESERVED_RE
       )
       
    1: IHOST_RE = IHOST_PATTERN = u'({0}|{1}|{2})'.format(
    1:     IREG_NAME,
    1:     IPv4_RE,
    1:     IP_LITERAL_RE,
       )
       
    1: IUSERINFO_RE = u'^(?:[' + IUNRESERVED_RE + SUB_DELIMITERS_RE + u':]|%s)+' % (
    1:     PCT_ENCODED
       )
       
       IFRAGMENT_RE = (u'^(?:[/?:@' + IUNRESERVED_RE + SUB_DELIMITERS_RE
    1:                 + u']|%s)*$' % PCT_ENCODED)
       IQUERY_RE = (u'^(?:[/?:@' + IUNRESERVED_RE + SUB_DELIMITERS_RE
    1:              + IPRIVATE + u']|%s)*$' % PCT_ENCODED)
       
    1: IRELATIVE_PART_RE = u'(//%s%s|%s|%s|%s)' % (
    1:     COMPONENT_PATTERN_DICT['authority'],
    1:     IPATH_ABEMPTY,
    1:     IPATH_ABSOLUTE,
    1:     IPATH_NOSCHEME,
    1:     PATH_EMPTY,
       )
       
    1: IHIER_PART_RE = u'(//%s%s|%s|%s|%s)' % (
    1:     COMPONENT_PATTERN_DICT['authority'],
    1:     IPATH_ABEMPTY,
    1:     IPATH_ABSOLUTE,
    1:     IPATH_ROOTLESS,
    1:     PATH_EMPTY,
       )
