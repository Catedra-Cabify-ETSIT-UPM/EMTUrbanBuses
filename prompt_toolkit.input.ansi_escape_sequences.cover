       """
       Mappings from VT100 (ANSI) escape sequences to the corresponding prompt_toolkit
       keys.
    1: """
    1: from __future__ import unicode_literals
    1: from ..keys import Keys
       
       __all__ = [
    1:     'ANSI_SEQUENCES',
    1:     'REVERSE_ANSI_SEQUENCES',
       ]
       
       
       # Mapping of vt100 escape codes to Keys.
       ANSI_SEQUENCES = {
    1:     '\x00': Keys.ControlAt,  # Control-At (Also for Ctrl-Space)
    1:     '\x01': Keys.ControlA,  # Control-A (home)
    1:     '\x02': Keys.ControlB,  # Control-B (emacs cursor left)
    1:     '\x03': Keys.ControlC,  # Control-C (interrupt)
    1:     '\x04': Keys.ControlD,  # Control-D (exit)
    1:     '\x05': Keys.ControlE,  # Control-E (end)
    1:     '\x06': Keys.ControlF,  # Control-F (cursor forward)
    1:     '\x07': Keys.ControlG,  # Control-G
    1:     '\x08': Keys.ControlH,  # Control-H (8) (Identical to '\b')
    1:     '\x09': Keys.ControlI,  # Control-I (9) (Identical to '\t')
    1:     '\x0a': Keys.ControlJ,  # Control-J (10) (Identical to '\n')
    1:     '\x0b': Keys.ControlK,  # Control-K (delete until end of line; vertical tab)
    1:     '\x0c': Keys.ControlL,  # Control-L (clear; form feed)
    1:     '\x0d': Keys.ControlM,  # Control-M (13) (Identical to '\r')
    1:     '\x0e': Keys.ControlN,  # Control-N (14) (history forward)
    1:     '\x0f': Keys.ControlO,  # Control-O (15)
    1:     '\x10': Keys.ControlP,  # Control-P (16) (history back)
    1:     '\x11': Keys.ControlQ,  # Control-Q
    1:     '\x12': Keys.ControlR,  # Control-R (18) (reverse search)
    1:     '\x13': Keys.ControlS,  # Control-S (19) (forward search)
    1:     '\x14': Keys.ControlT,  # Control-T
    1:     '\x15': Keys.ControlU,  # Control-U
    1:     '\x16': Keys.ControlV,  # Control-V
    1:     '\x17': Keys.ControlW,  # Control-W
    1:     '\x18': Keys.ControlX,  # Control-X
    1:     '\x19': Keys.ControlY,  # Control-Y (25)
    1:     '\x1a': Keys.ControlZ,  # Control-Z
       
    1:     '\x1b': Keys.Escape,            # Also Control-[
    1:     '\x1c': Keys.ControlBackslash,  # Both Control-\ (also Ctrl-| )
    1:     '\x1d': Keys.ControlSquareClose,  # Control-]
    1:     '\x1e': Keys.ControlCircumflex,  # Control-^
    1:     '\x1f': Keys.ControlUnderscore,  # Control-underscore (Also for Ctrl-hyphen.)
       
           # ASCII Delete (0x7f)
           # Vt220 (and Linux terminal) send this when pressing backspace. We map this
           # to ControlH, because that will make it easier to create key bindings that
           # work everywhere, with the trade-off that it's no longer possible to
           # handle backspace and control-h individually for the few terminals that
           # support it. (Most terminals send ControlH when backspace is pressed.)
           # See: http://www.ibb.net/~anne/keyboard.html
    1:     '\x7f': Keys.ControlH,
       
    1:     '\x1b[A': Keys.Up,
    1:     '\x1b[B': Keys.Down,
    1:     '\x1b[C': Keys.Right,
    1:     '\x1b[D': Keys.Left,
    1:     '\x1b[H': Keys.Home,
    1:     '\x1bOH': Keys.Home,
    1:     '\x1b[F': Keys.End,
    1:     '\x1bOF': Keys.End,
    1:     '\x1b[3~': Keys.Delete,
    1:     '\x1b[3;2~': Keys.ShiftDelete,  # xterm, gnome-terminal.
    1:     '\x1b[3;5~': Keys.ControlDelete,  # xterm, gnome-terminal.
    1:     '\x1b[1~': Keys.Home,  # tmux
    1:     '\x1b[4~': Keys.End,  # tmux
    1:     '\x1b[5~': Keys.PageUp,
    1:     '\x1b[6~': Keys.PageDown,
    1:     '\x1b[7~': Keys.Home,  # xrvt
    1:     '\x1b[8~': Keys.End,  # xrvt
    1:     '\x1b[Z': Keys.BackTab,  # shift + tab
    1:     '\x1b[2~': Keys.Insert,
       
    1:     '\x1bOP': Keys.F1,
    1:     '\x1bOQ': Keys.F2,
    1:     '\x1bOR': Keys.F3,
    1:     '\x1bOS': Keys.F4,
    1:     '\x1b[[A': Keys.F1,  # Linux console.
    1:     '\x1b[[B': Keys.F2,  # Linux console.
    1:     '\x1b[[C': Keys.F3,  # Linux console.
    1:     '\x1b[[D': Keys.F4,  # Linux console.
    1:     '\x1b[[E': Keys.F5,  # Linux console.
    1:     '\x1b[11~': Keys.F1,  # rxvt-unicode
    1:     '\x1b[12~': Keys.F2,  # rxvt-unicode
    1:     '\x1b[13~': Keys.F3,  # rxvt-unicode
    1:     '\x1b[14~': Keys.F4,  # rxvt-unicode
    1:     '\x1b[15~': Keys.F5,
    1:     '\x1b[17~': Keys.F6,
    1:     '\x1b[18~': Keys.F7,
    1:     '\x1b[19~': Keys.F8,
    1:     '\x1b[20~': Keys.F9,
    1:     '\x1b[21~': Keys.F10,
    1:     '\x1b[23~': Keys.F11,
    1:     '\x1b[24~': Keys.F12,
    1:     '\x1b[25~': Keys.F13,
    1:     '\x1b[26~': Keys.F14,
    1:     '\x1b[28~': Keys.F15,
    1:     '\x1b[29~': Keys.F16,
    1:     '\x1b[31~': Keys.F17,
    1:     '\x1b[32~': Keys.F18,
    1:     '\x1b[33~': Keys.F19,
    1:     '\x1b[34~': Keys.F20,
       
           # Xterm
    1:     '\x1b[1;2P': Keys.F13,
    1:     '\x1b[1;2Q': Keys.F14,
           # '\x1b[1;2R': Keys.F15,  # Conflicts with CPR response.
    1:     '\x1b[1;2S': Keys.F16,
    1:     '\x1b[15;2~': Keys.F17,
    1:     '\x1b[17;2~': Keys.F18,
    1:     '\x1b[18;2~': Keys.F19,
    1:     '\x1b[19;2~': Keys.F20,
    1:     '\x1b[20;2~': Keys.F21,
    1:     '\x1b[21;2~': Keys.F22,
    1:     '\x1b[23;2~': Keys.F23,
    1:     '\x1b[24;2~': Keys.F24,
       
    1:     '\x1b[1;5A': Keys.ControlUp,     # Cursor Mode
    1:     '\x1b[1;5B': Keys.ControlDown,   # Cursor Mode
    1:     '\x1b[1;5C': Keys.ControlRight,  # Cursor Mode
    1:     '\x1b[1;5D': Keys.ControlLeft,   # Cursor Mode
       
    1:     '\x1b[1;2A': Keys.ShiftUp,
    1:     '\x1b[1;2B': Keys.ShiftDown,
    1:     '\x1b[1;2C': Keys.ShiftRight,
    1:     '\x1b[1;2D': Keys.ShiftLeft,
       
           # Tmux sends following keystrokes when control+arrow is pressed, but for
           # Emacs ansi-term sends the same sequences for normal arrow keys. Consider
           # it a normal arrow press, because that's more important.
    1:     '\x1bOA': Keys.Up,
    1:     '\x1bOB': Keys.Down,
    1:     '\x1bOC': Keys.Right,
    1:     '\x1bOD': Keys.Left,
       
    1:     '\x1b[5A': Keys.ControlUp,
    1:     '\x1b[5B': Keys.ControlDown,
    1:     '\x1b[5C': Keys.ControlRight,
    1:     '\x1b[5D': Keys.ControlLeft,
       
    1:     '\x1bOc': Keys.ControlRight,  # rxvt
    1:     '\x1bOd': Keys.ControlLeft,  # rxvt
       
           # Tmux (Win32 subsystem) sends the following scroll events.
    1:     '\x1b[62~': Keys.ScrollUp,
    1:     '\x1b[63~': Keys.ScrollDown,
       
    1:     '\x1b[200~': Keys.BracketedPaste,  # Start of bracketed paste.
       
           # Meta + arrow keys. Several terminals handle this differently.
           # The following sequences are for xterm and gnome-terminal.
           #     (Iterm sends ESC followed by the normal arrow_up/down/left/right
           #     sequences, and the OSX Terminal sends ESCb and ESCf for "alt
           #     arrow_left" and "alt arrow_right." We don't handle these
           #     explicitly, in here, because would could not distinguish between
           #     pressing ESC (to go to Vi navigation mode), followed by just the
           #     'b' or 'f' key. These combinations are handled in
           #     the input processor.)
    1:     '\x1b[1;3D': (Keys.Escape, Keys.Left),
    1:     '\x1b[1;3C': (Keys.Escape, Keys.Right),
    1:     '\x1b[1;3A': (Keys.Escape, Keys.Up),
    1:     '\x1b[1;3B': (Keys.Escape, Keys.Down),
       
           # Option+left/right on (some?) Macs when using iTerm defaults
           # (see issue #483)
    1:     '\x1b[1;9D': (Keys.Escape, Keys.Left),
    1:     '\x1b[1;9C': (Keys.Escape, Keys.Right),
       
           # Sequences generated by numpad 5. Not sure what it means. (It doesn't
           # appear in 'infocmp'. Just ignore.
    1:     '\x1b[E': Keys.Ignore,  # Xterm.
    1:     '\x1b[G': Keys.Ignore,  # Linux console.
       }
       
       
    1: def _get_reverse_ansi_sequences():
           """
           Create a dictionary that maps prompt_toolkit keys back to the VT100 escape
           sequences.
           """
    1:     result = {}
       
  122:     for sequence, key in ANSI_SEQUENCES.items():
  121:         if not isinstance(key, tuple):
  115:             if key not in result:
   81:                 result[key] = sequence
       
    1:     return result
       
       
    1: REVERSE_ANSI_SEQUENCES = _get_reverse_ansi_sequences()
