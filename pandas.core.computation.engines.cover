       """
       Engine classes for :func:`~pandas.eval`
    1: """
       
    1: import abc
       
    1: from pandas.core.computation.align import _align, _reconstruct_object
    1: from pandas.core.computation.ops import UndefinedVariableError, _mathops, _reductions
       
    1: import pandas.io.formats.printing as printing
       
    1: _ne_builtins = frozenset(_mathops + _reductions)
       
       
    2: class NumExprClobberingError(NameError):
    1:     pass
       
       
    1: def _check_ne_builtin_clash(expr):
           """Attempt to prevent foot-shooting in a helpful way.
       
           Parameters
           ----------
           terms : Term
               Terms can contain
           """
           names = expr.names
           overlap = names & _ne_builtins
       
           if overlap:
               s = ", ".join(map(repr, overlap))
               raise NumExprClobberingError(
                   'Variables in expression "{expr}" '
                   "overlap with builtins: ({s})".format(expr=expr, s=s)
               )
       
       
    2: class AbstractEngine(metaclass=abc.ABCMeta):
    1:     """Object serving as a base class for all engines."""
       
    1:     has_neg_frac = False
       
    1:     def __init__(self, expr):
               self.expr = expr
               self.aligned_axes = None
               self.result_type = None
       
    1:     def convert(self):
               """Convert an expression for evaluation.
       
               Defaults to return the expression as a string.
               """
               return printing.pprint_thing(self.expr)
       
    1:     def evaluate(self):
               """Run the engine on the expression
       
               This method performs alignment which is necessary no matter what engine
               is being used, thus its implementation is in the base class.
       
               Returns
               -------
               obj : object
                   The result of the passed expression.
               """
               if not self._is_aligned:
                   self.result_type, self.aligned_axes = _align(self.expr.terms)
       
               # make sure no names in resolvers and locals/globals clash
               res = self._evaluate()
               return _reconstruct_object(
                   self.result_type, res, self.aligned_axes, self.expr.terms.return_type
               )
       
    1:     @property
           def _is_aligned(self):
               return self.aligned_axes is not None and self.result_type is not None
       
    1:     @abc.abstractmethod
           def _evaluate(self):
               """Return an evaluated expression.
       
               Parameters
               ----------
               env : Scope
                   The local and global environment in which to evaluate an
                   expression.
       
               Notes
               -----
               Must be implemented by subclasses.
               """
               pass
       
       
    2: class NumExprEngine(AbstractEngine):
       
    1:     """NumExpr engine class"""
       
    1:     has_neg_frac = True
       
    1:     def __init__(self, expr):
               super().__init__(expr)
       
    1:     def convert(self):
               return str(super().convert())
       
    1:     def _evaluate(self):
               import numexpr as ne
       
               # convert the expression to a valid numexpr expression
               s = self.convert()
       
               try:
                   env = self.expr.env
                   scope = env.full_scope
                   truediv = scope["truediv"]
                   _check_ne_builtin_clash(self.expr)
                   return ne.evaluate(s, local_dict=scope, truediv=truediv)
               except KeyError as e:
                   # python 3 compat kludge
                   try:
                       msg = e.message
                   except AttributeError:
                       msg = str(e)
                   raise UndefinedVariableError(msg)
       
       
    2: class PythonEngine(AbstractEngine):
       
           """Evaluate an expression in Python space.
       
           Mostly for testing purposes.
    1:     """
       
    1:     has_neg_frac = False
       
    1:     def __init__(self, expr):
               super().__init__(expr)
       
    1:     def evaluate(self):
               return self.expr()
       
    1:     def _evaluate(self):
               pass
       
       
    1: _engines = {"numexpr": NumExprEngine, "python": PythonEngine}
