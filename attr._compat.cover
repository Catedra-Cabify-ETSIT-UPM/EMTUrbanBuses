    1: from __future__ import absolute_import, division, print_function
       
    1: import platform
    1: import sys
    1: import types
    1: import warnings
       
       
    1: PY2 = sys.version_info[0] == 2
    1: PYPY = platform.python_implementation() == "PyPy"
       
       
    1: if PYPY or sys.version_info[:2] >= (3, 6):
    1:     ordered_dict = dict
       else:
           from collections import OrderedDict
       
           ordered_dict = OrderedDict
       
       
    1: if PY2:
           from UserDict import IterableUserDict
           from collections import Mapping, Sequence  # noqa
       
           # We 'bundle' isclass instead of using inspect as importing inspect is
           # fairly expensive (order of 10-15 ms for a modern machine in 2016)
           def isclass(klass):
               return isinstance(klass, (type, types.ClassType))
       
           # TYPE is used in exceptions, repr(int) is different on Python 2 and 3.
           TYPE = "type"
       
           def iteritems(d):
               return d.iteritems()
       
           # Python 2 is bereft of a read-only dict proxy, so we make one!
           class ReadOnlyDict(IterableUserDict):
               """
               Best-effort read-only dict wrapper.
               """
       
               def __setitem__(self, key, val):
                   # We gently pretend we're a Python 3 mappingproxy.
                   raise TypeError(
                       "'mappingproxy' object does not support item assignment"
                   )
       
               def update(self, _):
                   # We gently pretend we're a Python 3 mappingproxy.
                   raise AttributeError(
                       "'mappingproxy' object has no attribute 'update'"
                   )
       
               def __delitem__(self, _):
                   # We gently pretend we're a Python 3 mappingproxy.
                   raise TypeError(
                       "'mappingproxy' object does not support item deletion"
                   )
       
               def clear(self):
                   # We gently pretend we're a Python 3 mappingproxy.
                   raise AttributeError(
                       "'mappingproxy' object has no attribute 'clear'"
                   )
       
               def pop(self, key, default=None):
                   # We gently pretend we're a Python 3 mappingproxy.
                   raise AttributeError(
                       "'mappingproxy' object has no attribute 'pop'"
                   )
       
               def popitem(self):
                   # We gently pretend we're a Python 3 mappingproxy.
                   raise AttributeError(
                       "'mappingproxy' object has no attribute 'popitem'"
                   )
       
               def setdefault(self, key, default=None):
                   # We gently pretend we're a Python 3 mappingproxy.
                   raise AttributeError(
                       "'mappingproxy' object has no attribute 'setdefault'"
                   )
       
               def __repr__(self):
                   # Override to be identical to the Python 3 version.
                   return "mappingproxy(" + repr(self.data) + ")"
       
           def metadata_proxy(d):
               res = ReadOnlyDict()
               res.data.update(d)  # We blocked update, so we have to do it like this.
               return res
       
           def just_warn(*args, **kw):  # pragma: nocover
               """
               We only warn on Python 3 because we are not aware of any concrete
               consequences of not setting the cell on Python 2.
               """
       
       
       else:  # Python 3 and later.
    1:     from collections.abc import Mapping, Sequence  # noqa
       
    1:     def just_warn(*args, **kw):
               """
               We only warn on Python 3 because we are not aware of any concrete
               consequences of not setting the cell on Python 2.
               """
               warnings.warn(
                   "Missing ctypes.  Some features like bare super() or accessing "
                   "__class__ will not work with slotted classes.",
                   RuntimeWarning,
                   stacklevel=2,
               )
       
    1:     def isclass(klass):
    2:         return isinstance(klass, type)
       
    1:     TYPE = "class"
       
    1:     def iteritems(d):
   11:         return d.items()
       
    1:     def metadata_proxy(d):
    1:         return types.MappingProxyType(dict(d))
       
       
    1: def import_ctypes():
           """
           Moved into a function for testability.
           """
    1:     import ctypes
       
    1:     return ctypes
       
       
    1: def make_set_closure_cell():
           """
           Moved into a function for testability.
           """
    1:     if PYPY:  # pragma: no cover
       
               def set_closure_cell(cell, value):
                   cell.__setstate__((value,))
       
           else:
    1:         try:
    1:             ctypes = import_ctypes()
       
    1:             set_closure_cell = ctypes.pythonapi.PyCell_Set
    1:             set_closure_cell.argtypes = (ctypes.py_object, ctypes.py_object)
    1:             set_closure_cell.restype = ctypes.c_int
               except Exception:
                   # We try best effort to set the cell, but sometimes it's not
                   # possible.  For example on Jython or on GAE.
                   set_closure_cell = just_warn
    1:     return set_closure_cell
       
       
    1: set_closure_cell = make_set_closure_cell()
