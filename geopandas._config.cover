       """
       Lightweight options machinery.
       
       Based on https://github.com/topper-123/optioneer, but simplified (don't deal
       with nested options, deprecated options, ..), just the attribute-style dict
       like holding the options and giving a nice repr.
    1: """
    1: from collections import namedtuple
    1: import textwrap
       
       
    1: Option = namedtuple("Option", "key default_value doc validator callback")
       
       
    2: class Options(object):
    1:     """Provide attribute-style access to configuration dict."""
       
    1:     def __init__(self, options):
    1:         super(Options, self).__setattr__("_options", options)
               # populate with default values
    1:         config = {}
    2:         for key, option in options.items():
    1:             config[key] = option.default_value
       
    1:         super(Options, self).__setattr__("_config", config)
       
    1:     def __setattr__(self, key, value):
               # you can't set new keys
               if key in self._config:
                   option = self._options[key]
                   if option.validator:
                       option.validator(value)
                   self._config[key] = value
               else:
                   msg = "You can only set the value of existing options"
                   raise AttributeError(msg)
       
    1:     def __getattr__(self, key):
               try:
                   return self._config[key]
               except KeyError:
                   raise AttributeError("No such option")
       
    1:     def __dir__(self):
               return list(self._config.keys())
       
    1:     def __repr__(self):
               cls = self.__class__.__name__
               description = ""
               for key, option in self._options.items():
                   descr = u"{key}: {cur!r} [default: {default!r}]\n".format(
                       key=key, cur=self._config[key], default=option.default_value
                   )
                   description += descr
       
                   if option.doc:
                       doc_text = "\n".join(textwrap.wrap(option.doc, width=70))
                   else:
                       doc_text = u"No description available."
                   doc_text = indent(doc_text, prefix="    ")
                   description += doc_text
               space = "\n  "
               description = description.replace("\n", space)
               return "{}({}{})".format(cls, space, description)
       
       
    1: def indent(text, prefix, predicate=None):
           """
           This is the python 3 textwrap.indent function, which is not available in
           python 2.
           """
           if predicate is None:
       
               def predicate(line):
                   return line.strip()
       
           def prefixed_lines():
               for line in text.splitlines(True):
                   yield (prefix + line if predicate(line) else line)
       
           return "".join(prefixed_lines())
       
       
    1: def _validate_display_precision(value):
           if value is not None:
               if not isinstance(value, int) or not (0 <= value <= 16):
                   raise ValueError("Invalid value, needs to be an integer [0-16]")
       
       
    1: display_precision = Option(
    1:     key="display_precision",
    1:     default_value=None,
           doc=(
    1:         "The precision (maximum number of decimals) of the coordinates in "
               "the WKT representation in the Series/DataFrame display. "
               "By default (None), it tries to infer and use 3 decimals for projected "
               "coordinates and 5 decimals for geographic coordinates."
           ),
    1:     validator=_validate_display_precision,
    1:     callback=None,
       )
       
    1: options = Options({"display_precision": display_precision})
