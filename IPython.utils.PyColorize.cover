       # -*- coding: utf-8 -*-
       """
       Class and program to colorize python source code for ANSI terminals.
       
       Based on an HTML code highlighter by Jurgen Hermann found at:
       http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52298
       
       Modifications by Fernando Perez (fperez@colorado.edu).
       
       Information on the original HTML highlighter follows:
       
       MoinMoin - Python Source Parser
       
       Title: Colorize Python source using the built-in tokenizer
       
       Submitter: Jurgen Hermann
       Last Updated:2001/04/06
       
       Version no:1.2
       
       Description:
       
       This code is part of MoinMoin (http://moin.sourceforge.net/) and converts
       Python source code to HTML markup, rendering comments, keywords,
       operators, numeric and string literals in different colors.
       
       It shows how to use the built-in keyword, token and tokenize modules to
       scan Python source code and re-emit it with no changes to its original
       formatting (which is the hard part).
    1: """
       
    1: __all__ = ['ANSICodeColors', 'Parser']
       
    1: _scheme_default = 'Linux'
       
       
       # Imports
    1: import keyword
    1: import os
    1: import sys
    1: import token
    1: import tokenize
       
    1: generate_tokens = tokenize.generate_tokens
       
    1: from IPython.utils.coloransi import TermColors, InputTermColors,ColorScheme, ColorSchemeTable
    1: from .colorable import Colorable
    1: from io import StringIO
       
       #############################################################################
       ### Python Source Parser (does Highlighting)
       #############################################################################
       
    1: _KEYWORD = token.NT_OFFSET + 1
    1: _TEXT    = token.NT_OFFSET + 2
       
       #****************************************************************************
       # Builtin color schemes
       
    1: Colors = TermColors  # just a shorthand
       
       # Build a few color schemes
    1: NoColor = ColorScheme(
    1:     'NoColor',{
    1:     'header'         : Colors.NoColor,
    1:     token.NUMBER     : Colors.NoColor,
    1:     token.OP         : Colors.NoColor,
    1:     token.STRING     : Colors.NoColor,
    1:     tokenize.COMMENT : Colors.NoColor,
    1:     token.NAME       : Colors.NoColor,
    1:     token.ERRORTOKEN : Colors.NoColor,
       
    1:     _KEYWORD         : Colors.NoColor,
    1:     _TEXT            : Colors.NoColor,
       
    1:     'in_prompt'      : InputTermColors.NoColor,  # Input prompt
    1:     'in_number'      : InputTermColors.NoColor,  # Input prompt number
    1:     'in_prompt2'     : InputTermColors.NoColor, # Continuation prompt
    1:     'in_normal'      : InputTermColors.NoColor,  # color off (usu. Colors.Normal)
       
    1:     'out_prompt'     : Colors.NoColor, # Output prompt
    1:     'out_number'     : Colors.NoColor, # Output prompt number
       
    1:     'normal'         : Colors.NoColor  # color off (usu. Colors.Normal)
           }  )
       
    1: LinuxColors = ColorScheme(
    1:     'Linux',{
    1:     'header'         : Colors.LightRed,
    1:     token.NUMBER     : Colors.LightCyan,
    1:     token.OP         : Colors.Yellow,
    1:     token.STRING     : Colors.LightBlue,
    1:     tokenize.COMMENT : Colors.LightRed,
    1:     token.NAME       : Colors.Normal,
    1:     token.ERRORTOKEN : Colors.Red,
       
    1:     _KEYWORD         : Colors.LightGreen,
    1:     _TEXT            : Colors.Yellow,
       
    1:     'in_prompt'      : InputTermColors.Green,
    1:     'in_number'      : InputTermColors.LightGreen,
    1:     'in_prompt2'     : InputTermColors.Green,
    1:     'in_normal'      : InputTermColors.Normal,  # color off (usu. Colors.Normal)
       
    1:     'out_prompt'     : Colors.Red,
    1:     'out_number'     : Colors.LightRed,
       
    1:     'normal'         : Colors.Normal  # color off (usu. Colors.Normal)
           } )
       
    1: NeutralColors = ColorScheme(
    1:     'Neutral',{
    1:     'header'         : Colors.Red,
    1:     token.NUMBER     : Colors.Cyan,
    1:     token.OP         : Colors.Blue,
    1:     token.STRING     : Colors.Blue,
    1:     tokenize.COMMENT : Colors.Red,
    1:     token.NAME       : Colors.Normal,
    1:     token.ERRORTOKEN : Colors.Red,
       
    1:     _KEYWORD         : Colors.Green,
    1:     _TEXT            : Colors.Blue,
       
    1:     'in_prompt'      : InputTermColors.Blue,
    1:     'in_number'      : InputTermColors.LightBlue,
    1:     'in_prompt2'     : InputTermColors.Blue,
    1:     'in_normal'      : InputTermColors.Normal,  # color off (usu. Colors.Normal)
       
    1:     'out_prompt'     : Colors.Red,
    1:     'out_number'     : Colors.LightRed,
       
    1:     'normal'         : Colors.Normal  # color off (usu. Colors.Normal)
           }  )
       
       # Hack: the 'neutral' colours are not very visible on a dark background on
       # Windows. Since Windows command prompts have a dark background by default, and
       # relatively few users are likely to alter that, we will use the 'Linux' colours,
       # designed for a dark background, as the default on Windows. Changing it here
       # avoids affecting the prompt colours rendered by prompt_toolkit, where the
       # neutral defaults do work OK.
       
    1: if os.name == 'nt':
           NeutralColors = LinuxColors.copy(name='Neutral')
       
    1: LightBGColors = ColorScheme(
    1:     'LightBG',{
    1:     'header'         : Colors.Red,
    1:     token.NUMBER     : Colors.Cyan,
    1:     token.OP         : Colors.Blue,
    1:     token.STRING     : Colors.Blue,
    1:     tokenize.COMMENT : Colors.Red,
    1:     token.NAME       : Colors.Normal,
    1:     token.ERRORTOKEN : Colors.Red,
       
       
    1:     _KEYWORD         : Colors.Green,
    1:     _TEXT            : Colors.Blue,
       
    1:     'in_prompt'      : InputTermColors.Blue,
    1:     'in_number'      : InputTermColors.LightBlue,
    1:     'in_prompt2'     : InputTermColors.Blue,
    1:     'in_normal'      : InputTermColors.Normal,  # color off (usu. Colors.Normal)
       
    1:     'out_prompt'     : Colors.Red,
    1:     'out_number'     : Colors.LightRed,
       
    1:     'normal'         : Colors.Normal  # color off (usu. Colors.Normal)
           }  )
       
       # Build table of color schemes (needed by the parser)
    1: ANSICodeColors = ColorSchemeTable([NoColor,LinuxColors,LightBGColors, NeutralColors],
    1:                                   _scheme_default)
       
    1: Undefined = object()
       
    2: class Parser(Colorable):
           """ Format colored Python source.
    1:     """
       
    1:     def __init__(self, color_table=None, out = sys.stdout, parent=None, style=None):
               """ Create a parser with a specified color table and output channel.
       
               Call format() to process code.
               """
       
               super(Parser, self).__init__(parent=parent)
       
               self.color_table = color_table if color_table else ANSICodeColors
               self.out = out
               self.pos = None
               self.lines = None
               self.raw = None
               if not style:
                   self.style = self.default_style
               else:
                   self.style = style
       
       
    1:     def format(self, raw, out=None, scheme=Undefined):
               import warnings
               if scheme is not Undefined:
                   warnings.warn('The `scheme` argument of IPython.utils.PyColorize:Parser.format is deprecated since IPython 6.0.'
                                 'It will have no effect. Set the parser `style` directly.',
                                 stacklevel=2)
               return self.format2(raw, out)[0]
       
    1:     def format2(self, raw, out = None):
               """ Parse and send the colored source.
       
               If out and scheme are not specified, the defaults (given to
               constructor) are used.
       
               out should be a file-type object. Optionally, out can be given as the
               string 'str' and the parser will automatically return the output in a
               string."""
       
               string_output = 0
               if out == 'str' or self.out == 'str' or \
                  isinstance(self.out, StringIO):
                   # XXX - I don't really like this state handling logic, but at this
                   # point I don't want to make major changes, so adding the
                   # isinstance() check is the simplest I can do to ensure correct
                   # behavior.
                   out_old = self.out
                   self.out = StringIO()
                   string_output = 1
               elif out is not None:
                   self.out = out
               else:
                   raise ValueError('`out` or `self.out` should be file-like or the value `"str"`')
       
               # Fast return of the unmodified input for NoColor scheme
               if self.style == 'NoColor':
                   error = False
                   self.out.write(raw)
                   if string_output:
                       return raw, error
                   return None, error
       
               # local shorthands
               colors = self.color_table[self.style].colors
               self.colors = colors # put in object so __call__ sees it
       
               # Remove trailing whitespace and normalize tabs
               self.raw = raw.expandtabs().rstrip()
       
               # store line offsets in self.lines
               self.lines = [0, 0]
               pos = 0
               raw_find = self.raw.find
               lines_append = self.lines.append
               while True:
                   pos = raw_find('\n', pos) + 1
                   if not pos:
                       break
                   lines_append(pos)
               lines_append(len(self.raw))
       
               # parse the source and write it
               self.pos = 0
               text = StringIO(self.raw)
       
               error = False
               try:
                   for atoken in generate_tokens(text.readline):
                       self(*atoken)
               except tokenize.TokenError as ex:
                   msg = ex.args[0]
                   line = ex.args[1][0]
                   self.out.write("%s\n\n*** ERROR: %s%s%s\n" %
                                  (colors[token.ERRORTOKEN],
                                   msg, self.raw[self.lines[line]:],
                                   colors.normal)
                                  )
                   error = True
               self.out.write(colors.normal+'\n')
               if string_output:
                   output = self.out.getvalue()
                   self.out = out_old
                   return (output, error)
               return (None, error)
       
       
    1:     def _inner_call_(self, toktype, toktext, start_pos):
               """like call but write to a temporary buffer"""
               buff = StringIO()
               srow, scol = start_pos
               colors = self.colors
               owrite = buff.write
       
               # line separator, so this works across platforms
               linesep = os.linesep
       
               # calculate new positions
               oldpos = self.pos
               newpos = self.lines[srow] + scol
               self.pos = newpos + len(toktext)
       
               # send the original whitespace, if needed
               if newpos > oldpos:
                   owrite(self.raw[oldpos:newpos])
       
               # skip indenting tokens
               if toktype in [token.INDENT, token.DEDENT]:
                   self.pos = newpos
                   buff.seek(0)
                   return buff.read()
       
               # map token type to a color group
               if token.LPAR <= toktype <= token.OP:
                   toktype = token.OP
               elif toktype == token.NAME and keyword.iskeyword(toktext):
                   toktype = _KEYWORD
               color = colors.get(toktype, colors[_TEXT])
       
               # Triple quoted strings must be handled carefully so that backtracking
               # in pagers works correctly. We need color terminators on _each_ line.
               if linesep in toktext:
                   toktext = toktext.replace(linesep, '%s%s%s' %
                                             (colors.normal,linesep,color))
       
               # send text
               owrite('%s%s%s' % (color,toktext,colors.normal))
               buff.seek(0)
               return buff.read()
       
       
    1:     def __call__(self, toktype, toktext, start_pos, end_pos, line):
               """ Token handler, with syntax highlighting."""
               self.out.write(
                   self._inner_call_(toktype, toktext, start_pos))
