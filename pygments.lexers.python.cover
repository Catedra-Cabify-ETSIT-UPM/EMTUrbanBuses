       # -*- coding: utf-8 -*-
       """
           pygments.lexers.python
           ~~~~~~~~~~~~~~~~~~~~~~
       
           Lexers for Python and related languages.
       
           :copyright: Copyright 2006-2019 by the Pygments team, see AUTHORS.
           :license: BSD, see LICENSE for details.
    1: """
       
    1: import re
       
    1: from pygments.lexer import Lexer, RegexLexer, include, bygroups, using, \
           default, words, combined, do_insertions
    1: from pygments.util import get_bool_opt, shebang_matches
    1: from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
           Number, Punctuation, Generic, Other, Error
    1: from pygments import unistring as uni
       
    1: __all__ = ['PythonLexer', 'PythonConsoleLexer', 'PythonTracebackLexer',
    1:            'Python3Lexer', 'Python3TracebackLexer', 'CythonLexer',
    1:            'DgLexer', 'NumPyLexer']
       
    1: line_re = re.compile('.*?\n')
       
       
    2: class PythonLexer(RegexLexer):
           """
           For `Python <http://www.python.org>`_ source code.
    1:     """
       
    1:     name = 'Python'
    1:     aliases = ['python', 'py', 'sage']
    1:     filenames = ['*.py', '*.pyw', '*.sc', 'SConstruct', 'SConscript', '*.tac', '*.sage']
    1:     mimetypes = ['text/x-python', 'application/x-python']
       
    1:     def innerstring_rules(ttype):
               return [
                   # the old style '%s' % (...) string formatting
    2:             (r'%(\(\w+\))?[-#0 +]*([0-9]+|[*])?(\.([0-9]+|[*]))?'
    2:              '[hlL]?[E-GXc-giorsux%]', String.Interpol),
                   # backslashes, quotes and formatting signs must be parsed one at a time
    2:             (r'[^\\\'"%\n]+', ttype),
    2:             (r'[\'"\\]', ttype),
                   # unhandled string formatting sign
    2:             (r'%', ttype),
                   # newlines are an error (use "nl" state)
               ]
       
           tokens = {
               'root': [
    1:             (r'\n', Text),
    1:             (r'^(\s*)([rRuUbB]{,2})("""(?:.|\n)*?""")',
    1:              bygroups(Text, String.Affix, String.Doc)),
    1:             (r"^(\s*)([rRuUbB]{,2})('''(?:.|\n)*?''')",
    1:              bygroups(Text, String.Affix, String.Doc)),
    1:             (r'[^\S\n]+', Text),
    1:             (r'\A#!.+$', Comment.Hashbang),
    1:             (r'#.*$', Comment.Single),
    1:             (r'[]{}:(),;[]', Punctuation),
    1:             (r'\\\n', Text),
    1:             (r'\\', Text),
    1:             (r'(in|is|and|or|not)\b', Operator.Word),
    1:             (r'!=|==|<<|>>|[-~+/*%=<>&^|.]', Operator),
    1:             include('keywords'),
    1:             (r'(def)((?:\s|\\\s)+)', bygroups(Keyword, Text), 'funcname'),
    1:             (r'(class)((?:\s|\\\s)+)', bygroups(Keyword, Text), 'classname'),
    1:             (r'(from)((?:\s|\\\s)+)', bygroups(Keyword.Namespace, Text),
    1:              'fromimport'),
    1:             (r'(import)((?:\s|\\\s)+)', bygroups(Keyword.Namespace, Text),
    1:              'import'),
    1:             include('builtins'),
    1:             include('magicfuncs'),
    1:             include('magicvars'),
    1:             include('backtick'),
    1:             ('([rR]|[uUbB][rR]|[rR][uUbB])(""")',
    1:              bygroups(String.Affix, String.Double), 'tdqs'),
    1:             ("([rR]|[uUbB][rR]|[rR][uUbB])(''')",
    1:              bygroups(String.Affix, String.Single), 'tsqs'),
    1:             ('([rR]|[uUbB][rR]|[rR][uUbB])(")',
    1:              bygroups(String.Affix, String.Double), 'dqs'),
    1:             ("([rR]|[uUbB][rR]|[rR][uUbB])(')",
    1:              bygroups(String.Affix, String.Single), 'sqs'),
    1:             ('([uUbB]?)(""")', bygroups(String.Affix, String.Double),
    1:              combined('stringescape', 'tdqs')),
    1:             ("([uUbB]?)(''')", bygroups(String.Affix, String.Single),
    1:              combined('stringescape', 'tsqs')),
    1:             ('([uUbB]?)(")', bygroups(String.Affix, String.Double),
    1:              combined('stringescape', 'dqs')),
    1:             ("([uUbB]?)(')", bygroups(String.Affix, String.Single),
    1:              combined('stringescape', 'sqs')),
    1:             include('name'),
    1:             include('numbers'),
               ],
               'keywords': [
    1:             (words((
    1:                 'assert', 'break', 'continue', 'del', 'elif', 'else', 'except',
                       'exec', 'finally', 'for', 'global', 'if', 'lambda', 'pass',
                       'print', 'raise', 'return', 'try', 'while', 'yield',
    1:                 'yield from', 'as', 'with'), suffix=r'\b'),
    1:              Keyword),
               ],
               'builtins': [
    1:             (words((
    1:                 '__import__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin',
                       'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod',
                       'cmp', 'coerce', 'compile', 'complex', 'delattr', 'dict', 'dir', 'divmod',
                       'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float',
                       'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'hex', 'id',
                       'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len',
                       'list', 'locals', 'long', 'map', 'max', 'min', 'next', 'object',
                       'oct', 'open', 'ord', 'pow', 'property', 'range', 'raw_input', 'reduce',
                       'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
                       'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type',
                       'unichr', 'unicode', 'vars', 'xrange', 'zip'),
    1:                 prefix=r'(?<!\.)', suffix=r'\b'),
    1:              Name.Builtin),
    1:             (r'(?<!\.)(self|None|Ellipsis|NotImplemented|False|True|cls'
    1:              r')\b', Name.Builtin.Pseudo),
    1:             (words((
    1:                 'ArithmeticError', 'AssertionError', 'AttributeError',
                       'BaseException', 'DeprecationWarning', 'EOFError', 'EnvironmentError',
                       'Exception', 'FloatingPointError', 'FutureWarning', 'GeneratorExit',
                       'IOError', 'ImportError', 'ImportWarning', 'IndentationError',
                       'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
                       'MemoryError', 'ModuleNotFoundError', 'NameError', 'NotImplemented', 'NotImplementedError',
                       'OSError', 'OverflowError', 'OverflowWarning', 'PendingDeprecationWarning',
                       'RecursionError', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError',
                       'StopIteration', 'StopAsyncIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
                       'SystemExit', 'TabError', 'TypeError', 'UnboundLocalError',
                       'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError',
                       'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
                       'ValueError', 'VMSError', 'Warning', 'WindowsError',
    1:                 'ZeroDivisionError'), prefix=r'(?<!\.)', suffix=r'\b'),
    1:              Name.Exception),
               ],
               'magicfuncs': [
    1:             (words((
    1:                 '__abs__', '__add__', '__and__', '__call__', '__cmp__', '__coerce__',
                       '__complex__', '__contains__', '__del__', '__delattr__', '__delete__',
                       '__delitem__', '__delslice__', '__div__', '__divmod__', '__enter__',
                       '__eq__', '__exit__', '__float__', '__floordiv__', '__ge__', '__get__',
                       '__getattr__', '__getattribute__', '__getitem__', '__getslice__', '__gt__',
                       '__hash__', '__hex__', '__iadd__', '__iand__', '__idiv__', '__ifloordiv__',
                       '__ilshift__', '__imod__', '__imul__', '__index__', '__init__',
                       '__instancecheck__', '__int__', '__invert__', '__iop__', '__ior__',
                       '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__',
                       '__ixor__', '__le__', '__len__', '__long__', '__lshift__', '__lt__',
                       '__missing__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__',
                       '__nonzero__', '__oct__', '__op__', '__or__', '__pos__', '__pow__',
                       '__radd__', '__rand__', '__rcmp__', '__rdiv__', '__rdivmod__', '__repr__',
                       '__reversed__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__',
                       '__rop__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__',
                       '__rtruediv__', '__rxor__', '__set__', '__setattr__', '__setitem__',
                       '__setslice__', '__str__', '__sub__', '__subclasscheck__', '__truediv__',
    1:                 '__unicode__', '__xor__'), suffix=r'\b'),
    1:              Name.Function.Magic),
               ],
               'magicvars': [
    1:             (words((
    1:                 '__bases__', '__class__', '__closure__', '__code__', '__defaults__',
                       '__dict__', '__doc__', '__file__', '__func__', '__globals__',
                       '__metaclass__', '__module__', '__mro__', '__name__', '__self__',
                       '__slots__', '__weakref__'),
    1:                 suffix=r'\b'),
    1:              Name.Variable.Magic),
               ],
               'numbers': [
    1:             (r'(\d+\.\d*|\d*\.\d+)([eE][+-]?[0-9]+)?j?', Number.Float),
    1:             (r'\d+[eE][+-]?[0-9]+j?', Number.Float),
    1:             (r'0[0-7]+j?', Number.Oct),
    1:             (r'0[bB][01]+', Number.Bin),
    1:             (r'0[xX][a-fA-F0-9]+', Number.Hex),
    1:             (r'\d+L', Number.Integer.Long),
    1:             (r'\d+j?', Number.Integer)
               ],
               'backtick': [
    1:             ('`.*?`', String.Backtick),
               ],
               'name': [
    1:             (r'@[\w.]+', Name.Decorator),
    1:             (r'[a-zA-Z_]\w*', Name),
               ],
               'funcname': [
    1:             include('magicfuncs'),
    1:             (r'[a-zA-Z_]\w*', Name.Function, '#pop'),
    1:             default('#pop'),
               ],
               'classname': [
    1:             (r'[a-zA-Z_]\w*', Name.Class, '#pop')
               ],
               'import': [
    1:             (r'(?:[ \t]|\\\n)+', Text),
    1:             (r'as\b', Keyword.Namespace),
    1:             (r',', Operator),
    1:             (r'[a-zA-Z_][\w.]*', Name.Namespace),
    1:             default('#pop')  # all else: go back
               ],
               'fromimport': [
    1:             (r'(?:[ \t]|\\\n)+', Text),
    1:             (r'import\b', Keyword.Namespace, '#pop'),
                   # if None occurs here, it's "raise x from None", since None can
                   # never be a module name
    1:             (r'None\b', Name.Builtin.Pseudo, '#pop'),
                   # sadly, in "raise x from y" y will be highlighted as namespace too
    1:             (r'[a-zA-Z_.][\w.]*', Name.Namespace),
                   # anything else here also means "raise x from y" and is therefore
                   # not an error
    1:             default('#pop'),
               ],
               'stringescape': [
    1:             (r'\\([\\abfnrtv"\']|\n|N\{.*?\}|u[a-fA-F0-9]{4}|'
    1:              r'U[a-fA-F0-9]{8}|x[a-fA-F0-9]{2}|[0-7]{1,3})', String.Escape)
               ],
    1:         'strings-single': innerstring_rules(String.Single),
    1:         'strings-double': innerstring_rules(String.Double),
               'dqs': [
    1:             (r'"', String.Double, '#pop'),
    1:             (r'\\\\|\\"|\\\n', String.Escape),  # included here for raw strings
    1:             include('strings-double')
               ],
               'sqs': [
    1:             (r"'", String.Single, '#pop'),
    1:             (r"\\\\|\\'|\\\n", String.Escape),  # included here for raw strings
    1:             include('strings-single')
               ],
               'tdqs': [
    1:             (r'"""', String.Double, '#pop'),
    1:             include('strings-double'),
    1:             (r'\n', String.Double)
               ],
               'tsqs': [
    1:             (r"'''", String.Single, '#pop'),
    1:             include('strings-single'),
    1:             (r'\n', String.Single)
               ],
           }
       
    1:     def analyse_text(text):
               return shebang_matches(text, r'pythonw?(2(\.\d)?)?') or \
                   'import ' in text[:1000]
       
       
    2: class Python3Lexer(RegexLexer):
           """
           For `Python <http://www.python.org>`_ source code (version 3.0).
       
           .. versionadded:: 0.10
    1:     """
       
    1:     name = 'Python 3'
    1:     aliases = ['python3', 'py3']
    1:     filenames = []  # Nothing until Python 3 gets widespread
    1:     mimetypes = ['text/x-python3', 'application/x-python3']
       
    1:     flags = re.MULTILINE | re.UNICODE
       
    1:     uni_name = "[%s][%s]*" % (uni.xid_start, uni.xid_continue)
       
    1:     def innerstring_rules(ttype):
               return [
                   # the old style '%s' % (...) string formatting (still valid in Py3)
    2:             (r'%(\(\w+\))?[-#0 +]*([0-9]+|[*])?(\.([0-9]+|[*]))?'
    2:              '[hlL]?[E-GXc-giorsaux%]', String.Interpol),
                   # the new style '{}'.format(...) string formatting
    2:             (r'\{'
                    r'((\w+)((\.\w+)|(\[[^\]]+\]))*)?'  # field name
                    r'(\![sra])?'                       # conversion
                    r'(\:(.?[<>=\^])?[-+ ]?#?0?(\d+)?,?(\.\d+)?[E-GXb-gnosx%]?)?'
    2:              r'\}', String.Interpol),
       
                   # backslashes, quotes and formatting signs must be parsed one at a time
    2:             (r'[^\\\'"%{\n]+', ttype),
    2:             (r'[\'"\\]', ttype),
                   # unhandled string formatting sign
    2:             (r'%|(\{{1,2})', ttype)
                   # newlines are an error (use "nl" state)
               ]
       
    1:     tokens = PythonLexer.tokens.copy()
           tokens['keywords'] = [
    1:         (words((
    1:             'assert', 'async', 'await', 'break', 'continue', 'del', 'elif',
                   'else', 'except', 'finally', 'for', 'global', 'if', 'lambda', 'pass',
                   'raise', 'nonlocal', 'return', 'try', 'while', 'yield', 'yield from',
    1:             'as', 'with'), suffix=r'\b'),
    1:          Keyword),
    1:         (words((
    1:             'True', 'False', 'None'), suffix=r'\b'),
    1:          Keyword.Constant),
           ]
           tokens['builtins'] = [
    1:         (words((
    1:             '__import__', 'abs', 'all', 'any', 'bin', 'bool', 'bytearray', 'bytes',
                   'chr', 'classmethod', 'cmp', 'compile', 'complex', 'delattr', 'dict',
                   'dir', 'divmod', 'enumerate', 'eval', 'filter', 'float', 'format',
                   'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'hex', 'id',
                   'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'list',
                   'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct',
                   'open', 'ord', 'pow', 'print', 'property', 'range', 'repr', 'reversed',
                   'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str',
    1:             'sum', 'super', 'tuple', 'type', 'vars', 'zip'), prefix=r'(?<!\.)',
    1:             suffix=r'\b'),
    1:          Name.Builtin),
    1:         (r'(?<!\.)(self|Ellipsis|NotImplemented|cls)\b', Name.Builtin.Pseudo),
    1:         (words((
    1:             'ArithmeticError', 'AssertionError', 'AttributeError',
                   'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning',
                   'EOFError', 'EnvironmentError', 'Exception', 'FloatingPointError',
                   'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
                   'ImportWarning', 'IndentationError', 'IndexError', 'KeyError',
                   'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError',
                   'NotImplementedError', 'OSError', 'OverflowError',
                   'PendingDeprecationWarning', 'ReferenceError', 'ResourceWarning',
                   'RuntimeError', 'RuntimeWarning', 'StopIteration',
                   'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',
                   'TypeError', 'UnboundLocalError', 'UnicodeDecodeError',
                   'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError',
                   'UnicodeWarning', 'UserWarning', 'ValueError', 'VMSError', 'Warning',
                   'WindowsError', 'ZeroDivisionError',
                   # new builtin exceptions from PEP 3151
                   'BlockingIOError', 'ChildProcessError', 'ConnectionError',
                   'BrokenPipeError', 'ConnectionAbortedError', 'ConnectionRefusedError',
                   'ConnectionResetError', 'FileExistsError', 'FileNotFoundError',
                   'InterruptedError', 'IsADirectoryError', 'NotADirectoryError',
                   'PermissionError', 'ProcessLookupError', 'TimeoutError'),
    1:             prefix=r'(?<!\.)', suffix=r'\b'),
    1:          Name.Exception),
           ]
           tokens['magicfuncs'] = [
    1:         (words((
    1:             '__abs__', '__add__', '__aenter__', '__aexit__', '__aiter__', '__and__',
                   '__anext__', '__await__', '__bool__', '__bytes__', '__call__',
                   '__complex__', '__contains__', '__del__', '__delattr__', '__delete__',
                   '__delitem__', '__dir__', '__divmod__', '__enter__', '__eq__', '__exit__',
                   '__float__', '__floordiv__', '__format__', '__ge__', '__get__',
                   '__getattr__', '__getattribute__', '__getitem__', '__gt__', '__hash__',
                   '__iadd__', '__iand__', '__ifloordiv__', '__ilshift__', '__imatmul__',
                   '__imod__', '__import__', '__imul__', '__index__', '__init__',
                   '__instancecheck__', '__int__', '__invert__', '__ior__', '__ipow__',
                   '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__',
                   '__le__', '__len__', '__length_hint__', '__lshift__', '__lt__',
                   '__matmul__', '__missing__', '__mod__', '__mul__', '__ne__', '__neg__',
                   '__new__', '__next__', '__or__', '__pos__', '__pow__', '__prepare__',
                   '__radd__', '__rand__', '__rdivmod__', '__repr__', '__reversed__',
                   '__rfloordiv__', '__rlshift__', '__rmatmul__', '__rmod__', '__rmul__',
                   '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__',
                   '__rsub__', '__rtruediv__', '__rxor__', '__set__', '__setattr__',
                   '__setitem__', '__str__', '__sub__', '__subclasscheck__', '__truediv__',
    1:             '__xor__'), suffix=r'\b'),
    1:          Name.Function.Magic),
           ]
           tokens['magicvars'] = [
    1:         (words((
    1:             '__annotations__', '__bases__', '__class__', '__closure__', '__code__',
                   '__defaults__', '__dict__', '__doc__', '__file__', '__func__',
                   '__globals__', '__kwdefaults__', '__module__', '__mro__', '__name__',
                   '__objclass__', '__qualname__', '__self__', '__slots__', '__weakref__'),
    1:             suffix=r'\b'),
    1:          Name.Variable.Magic),
           ]
           tokens['numbers'] = [
    1:         (r'(\d(?:_?\d)*\.(?:\d(?:_?\d)*)?|(?:\d(?:_?\d)*)?\.\d(?:_?\d)*)'
    1:          r'([eE][+-]?\d(?:_?\d)*)?', Number.Float),
    1:         (r'\d(?:_?\d)*[eE][+-]?\d(?:_?\d)*j?', Number.Float),
    1:         (r'0[oO](?:_?[0-7])+', Number.Oct),
    1:         (r'0[bB](?:_?[01])+', Number.Bin),
    1:         (r'0[xX](?:_?[a-fA-F0-9])+', Number.Hex),
    1:         (r'\d(?:_?\d)*', Number.Integer)
           ]
    1:     tokens['backtick'] = []
           tokens['name'] = [
    1:         (r'@\w+', Name.Decorator),
    1:         (r'@', Operator),  # new matrix multiplication operator
    1:         (uni_name, Name),
           ]
           tokens['funcname'] = [
    1:         (uni_name, Name.Function, '#pop')
           ]
           tokens['classname'] = [
    1:         (uni_name, Name.Class, '#pop')
           ]
           tokens['import'] = [
    1:         (r'(\s+)(as)(\s+)', bygroups(Text, Keyword, Text)),
    1:         (r'\.', Name.Namespace),
    1:         (uni_name, Name.Namespace),
    1:         (r'(\s*)(,)(\s*)', bygroups(Text, Operator, Text)),
    1:         default('#pop')  # all else: go back
           ]
           tokens['fromimport'] = [
    1:         (r'(\s+)(import)\b', bygroups(Text, Keyword), '#pop'),
    1:         (r'\.', Name.Namespace),
    1:         (uni_name, Name.Namespace),
    1:         default('#pop'),
           ]
    1:     tokens['strings-single'] = innerstring_rules(String.Single)
    1:     tokens['strings-double'] = innerstring_rules(String.Double)
       
       
    1:     def analyse_text(text):
               return shebang_matches(text, r'pythonw?3(\.\d)?')
       
       
    2: class PythonConsoleLexer(Lexer):
           """
           For Python console output or doctests, such as:
       
           .. sourcecode:: pycon
       
               >>> a = 'foo'
               >>> print a
               foo
               >>> 1 / 0
               Traceback (most recent call last):
                 File "<stdin>", line 1, in <module>
               ZeroDivisionError: integer division or modulo by zero
       
           Additional options:
       
           `python3`
               Use Python 3 lexer for code.  Default is ``False``.
       
               .. versionadded:: 1.0
    1:     """
    1:     name = 'Python console session'
    1:     aliases = ['pycon']
    1:     mimetypes = ['text/x-python-doctest']
       
    1:     def __init__(self, **options):
               self.python3 = get_bool_opt(options, 'python3', False)
               Lexer.__init__(self, **options)
       
    1:     def get_tokens_unprocessed(self, text):
               if self.python3:
                   pylexer = Python3Lexer(**self.options)
                   tblexer = Python3TracebackLexer(**self.options)
               else:
                   pylexer = PythonLexer(**self.options)
                   tblexer = PythonTracebackLexer(**self.options)
       
               curcode = ''
               insertions = []
               curtb = ''
               tbindex = 0
               tb = 0
               for match in line_re.finditer(text):
                   line = match.group()
                   if line.startswith(u'>>> ') or line.startswith(u'... '):
                       tb = 0
                       insertions.append((len(curcode),
                                          [(0, Generic.Prompt, line[:4])]))
                       curcode += line[4:]
                   elif line.rstrip() == u'...' and not tb:
                       # only a new >>> prompt can end an exception block
                       # otherwise an ellipsis in place of the traceback frames
                       # will be mishandled
                       insertions.append((len(curcode),
                                          [(0, Generic.Prompt, u'...')]))
                       curcode += line[3:]
                   else:
                       if curcode:
                           for item in do_insertions(
                                   insertions, pylexer.get_tokens_unprocessed(curcode)):
                               yield item
                           curcode = ''
                           insertions = []
                       if (line.startswith(u'Traceback (most recent call last):') or
                               re.match(u'  File "[^"]+", line \\d+\\n$', line)):
                           tb = 1
                           curtb = line
                           tbindex = match.start()
                       elif line == 'KeyboardInterrupt\n':
                           yield match.start(), Name.Class, line
                       elif tb:
                           curtb += line
                           if not (line.startswith(' ') or line.strip() == u'...'):
                               tb = 0
                               for i, t, v in tblexer.get_tokens_unprocessed(curtb):
                                   yield tbindex+i, t, v
                               curtb = ''
                       else:
                           yield match.start(), Generic.Output, line
               if curcode:
                   for item in do_insertions(insertions,
                                             pylexer.get_tokens_unprocessed(curcode)):
                       yield item
               if curtb:
                   for i, t, v in tblexer.get_tokens_unprocessed(curtb):
                       yield tbindex+i, t, v
       
       
    2: class PythonTracebackLexer(RegexLexer):
           """
           For Python tracebacks.
       
           .. versionadded:: 0.7
    1:     """
       
    1:     name = 'Python Traceback'
    1:     aliases = ['pytb']
    1:     filenames = ['*.pytb']
    1:     mimetypes = ['text/x-python-traceback']
       
           tokens = {
               'root': [
                   # Cover both (most recent call last) and (innermost last)
                   # The optional ^C allows us to catch keyboard interrupt signals.
    1:             (r'^(\^C)?(Traceback.*\n)',
    1:              bygroups(Text, Generic.Traceback), 'intb'),
                   # SyntaxError starts with this.
    1:             (r'^(?=  File "[^"]+", line \d+)', Generic.Traceback, 'intb'),
    1:             (r'^.*\n', Other),
               ],
               'intb': [
    1:             (r'^(  File )("[^"]+")(, line )(\d+)(, in )(.+)(\n)',
    1:              bygroups(Text, Name.Builtin, Text, Number, Text, Name, Text)),
    1:             (r'^(  File )("[^"]+")(, line )(\d+)(\n)',
    1:              bygroups(Text, Name.Builtin, Text, Number, Text)),
    1:             (r'^(    )(.+)(\n)',
    1:              bygroups(Text, using(PythonLexer), Text)),
    1:             (r'^([ \t]*)(\.\.\.)(\n)',
    1:              bygroups(Text, Comment, Text)),  # for doctests...
    1:             (r'^([^:]+)(: )(.+)(\n)',
    1:              bygroups(Generic.Error, Text, Name, Text), '#pop'),
    1:             (r'^([a-zA-Z_]\w*)(:?\n)',
    1:              bygroups(Generic.Error, Text), '#pop')
               ],
           }
       
       
    2: class Python3TracebackLexer(RegexLexer):
           """
           For Python 3.0 tracebacks, with support for chained exceptions.
       
           .. versionadded:: 1.0
    1:     """
       
    1:     name = 'Python 3.0 Traceback'
    1:     aliases = ['py3tb']
    1:     filenames = ['*.py3tb']
    1:     mimetypes = ['text/x-python3-traceback']
       
           tokens = {
               'root': [
    1:             (r'\n', Text),
    1:             (r'^Traceback \(most recent call last\):\n', Generic.Traceback, 'intb'),
    1:             (r'^During handling of the above exception, another '
    1:              r'exception occurred:\n\n', Generic.Traceback),
    1:             (r'^The above exception was the direct cause of the '
    1:              r'following exception:\n\n', Generic.Traceback),
    1:             (r'^(?=  File "[^"]+", line \d+)', Generic.Traceback, 'intb'),
               ],
               'intb': [
    1:             (r'^(  File )("[^"]+")(, line )(\d+)(, in )(.+)(\n)',
    1:              bygroups(Text, Name.Builtin, Text, Number, Text, Name, Text)),
    1:             (r'^(  File )("[^"]+")(, line )(\d+)(\n)',
    1:              bygroups(Text, Name.Builtin, Text, Number, Text)),
    1:             (r'^(    )(.+)(\n)',
    1:              bygroups(Text, using(Python3Lexer), Text)),
    1:             (r'^([ \t]*)(\.\.\.)(\n)',
    1:              bygroups(Text, Comment, Text)),  # for doctests...
    1:             (r'^([^:]+)(: )(.+)(\n)',
    1:              bygroups(Generic.Error, Text, Name, Text), '#pop'),
    1:             (r'^([a-zA-Z_]\w*)(:?\n)',
    1:              bygroups(Generic.Error, Text), '#pop')
               ],
           }
       
       
    2: class CythonLexer(RegexLexer):
           """
           For Pyrex and `Cython <http://cython.org>`_ source code.
       
           .. versionadded:: 1.1
    1:     """
       
    1:     name = 'Cython'
    1:     aliases = ['cython', 'pyx', 'pyrex']
    1:     filenames = ['*.pyx', '*.pxd', '*.pxi']
    1:     mimetypes = ['text/x-cython', 'application/x-cython']
       
           tokens = {
               'root': [
    1:             (r'\n', Text),
    1:             (r'^(\s*)("""(?:.|\n)*?""")', bygroups(Text, String.Doc)),
    1:             (r"^(\s*)('''(?:.|\n)*?''')", bygroups(Text, String.Doc)),
    1:             (r'[^\S\n]+', Text),
    1:             (r'#.*$', Comment),
    1:             (r'[]{}:(),;[]', Punctuation),
    1:             (r'\\\n', Text),
    1:             (r'\\', Text),
    1:             (r'(in|is|and|or|not)\b', Operator.Word),
    1:             (r'(<)([a-zA-Z0-9.?]+)(>)',
    1:              bygroups(Punctuation, Keyword.Type, Punctuation)),
    1:             (r'!=|==|<<|>>|[-~+/*%=<>&^|.?]', Operator),
    1:             (r'(from)(\d+)(<=)(\s+)(<)(\d+)(:)',
    1:              bygroups(Keyword, Number.Integer, Operator, Name, Operator,
    1:                       Name, Punctuation)),
    1:             include('keywords'),
    1:             (r'(def|property)(\s+)', bygroups(Keyword, Text), 'funcname'),
    1:             (r'(cp?def)(\s+)', bygroups(Keyword, Text), 'cdef'),
                   # (should actually start a block with only cdefs)
    1:             (r'(cdef)(:)', bygroups(Keyword, Punctuation)),
    1:             (r'(class|struct)(\s+)', bygroups(Keyword, Text), 'classname'),
    1:             (r'(from)(\s+)', bygroups(Keyword, Text), 'fromimport'),
    1:             (r'(c?import)(\s+)', bygroups(Keyword, Text), 'import'),
    1:             include('builtins'),
    1:             include('backtick'),
    1:             ('(?:[rR]|[uU][rR]|[rR][uU])"""', String, 'tdqs'),
    1:             ("(?:[rR]|[uU][rR]|[rR][uU])'''", String, 'tsqs'),
    1:             ('(?:[rR]|[uU][rR]|[rR][uU])"', String, 'dqs'),
    1:             ("(?:[rR]|[uU][rR]|[rR][uU])'", String, 'sqs'),
    1:             ('[uU]?"""', String, combined('stringescape', 'tdqs')),
    1:             ("[uU]?'''", String, combined('stringescape', 'tsqs')),
    1:             ('[uU]?"', String, combined('stringescape', 'dqs')),
    1:             ("[uU]?'", String, combined('stringescape', 'sqs')),
    1:             include('name'),
    1:             include('numbers'),
               ],
               'keywords': [
    1:             (words((
    1:                 'assert', 'break', 'by', 'continue', 'ctypedef', 'del', 'elif',
                       'else', 'except', 'except?', 'exec', 'finally', 'for', 'fused', 'gil',
                       'global', 'if', 'include', 'lambda', 'nogil', 'pass', 'print',
    1:                 'raise', 'return', 'try', 'while', 'yield', 'as', 'with'), suffix=r'\b'),
    1:              Keyword),
    1:             (r'(DEF|IF|ELIF|ELSE)\b', Comment.Preproc),
               ],
               'builtins': [
    1:             (words((
    1:                 '__import__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin',
                       'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr',
                       'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'delattr',
                       'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit',
                       'file', 'filter', 'float', 'frozenset', 'getattr', 'globals',
                       'hasattr', 'hash', 'hex', 'id', 'input', 'int', 'intern', 'isinstance',
                       'issubclass', 'iter', 'len', 'list', 'locals', 'long', 'map', 'max',
                       'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'property',
                       'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed',
                       'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod',
                       'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'unsigned',
    1:                 'vars', 'xrange', 'zip'), prefix=r'(?<!\.)', suffix=r'\b'),
    1:              Name.Builtin),
    1:             (r'(?<!\.)(self|None|Ellipsis|NotImplemented|False|True|NULL'
    1:              r')\b', Name.Builtin.Pseudo),
    1:             (words((
    1:                 'ArithmeticError', 'AssertionError', 'AttributeError',
                       'BaseException', 'DeprecationWarning', 'EOFError', 'EnvironmentError',
                       'Exception', 'FloatingPointError', 'FutureWarning', 'GeneratorExit',
                       'IOError', 'ImportError', 'ImportWarning', 'IndentationError',
                       'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
                       'MemoryError', 'NameError', 'NotImplemented', 'NotImplementedError',
                       'OSError', 'OverflowError', 'OverflowWarning',
                       'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError',
                       'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError',
                       'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',
                       'TypeError', 'UnboundLocalError', 'UnicodeDecodeError',
                       'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError',
                       'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning',
    1:                 'ZeroDivisionError'), prefix=r'(?<!\.)', suffix=r'\b'),
    1:              Name.Exception),
               ],
               'numbers': [
    1:             (r'(\d+\.?\d*|\d*\.\d+)([eE][+-]?[0-9]+)?', Number.Float),
    1:             (r'0\d+', Number.Oct),
    1:             (r'0[xX][a-fA-F0-9]+', Number.Hex),
    1:             (r'\d+L', Number.Integer.Long),
    1:             (r'\d+', Number.Integer)
               ],
               'backtick': [
    1:             ('`.*?`', String.Backtick),
               ],
               'name': [
    1:             (r'@\w+', Name.Decorator),
    1:             (r'[a-zA-Z_]\w*', Name),
               ],
               'funcname': [
    1:             (r'[a-zA-Z_]\w*', Name.Function, '#pop')
               ],
               'cdef': [
    1:             (r'(public|readonly|extern|api|inline)\b', Keyword.Reserved),
    1:             (r'(struct|enum|union|class)\b', Keyword),
    1:             (r'([a-zA-Z_]\w*)(\s*)(?=[(:#=]|$)',
    1:              bygroups(Name.Function, Text), '#pop'),
    1:             (r'([a-zA-Z_]\w*)(\s*)(,)',
    1:              bygroups(Name.Function, Text, Punctuation)),
    1:             (r'from\b', Keyword, '#pop'),
    1:             (r'as\b', Keyword),
    1:             (r':', Punctuation, '#pop'),
    1:             (r'(?=["\'])', Text, '#pop'),
    1:             (r'[a-zA-Z_]\w*', Keyword.Type),
    1:             (r'.', Text),
               ],
               'classname': [
    1:             (r'[a-zA-Z_]\w*', Name.Class, '#pop')
               ],
               'import': [
    1:             (r'(\s+)(as)(\s+)', bygroups(Text, Keyword, Text)),
    1:             (r'[a-zA-Z_][\w.]*', Name.Namespace),
    1:             (r'(\s*)(,)(\s*)', bygroups(Text, Operator, Text)),
    1:             default('#pop')  # all else: go back
               ],
               'fromimport': [
    1:             (r'(\s+)(c?import)\b', bygroups(Text, Keyword), '#pop'),
    1:             (r'[a-zA-Z_.][\w.]*', Name.Namespace),
                   # ``cdef foo from "header"``, or ``for foo from 0 < i < 10``
    1:             default('#pop'),
               ],
               'stringescape': [
    1:             (r'\\([\\abfnrtv"\']|\n|N\{.*?\}|u[a-fA-F0-9]{4}|'
    1:              r'U[a-fA-F0-9]{8}|x[a-fA-F0-9]{2}|[0-7]{1,3})', String.Escape)
               ],
               'strings': [
    1:             (r'%(\([a-zA-Z0-9]+\))?[-#0 +]*([0-9]+|[*])?(\.([0-9]+|[*]))?'
    1:              '[hlL]?[E-GXc-giorsux%]', String.Interpol),
    1:             (r'[^\\\'"%\n]+', String),
                   # quotes, percents and backslashes must be parsed one at a time
    1:             (r'[\'"\\]', String),
                   # unhandled string formatting sign
    1:             (r'%', String)
                   # newlines are an error (use "nl" state)
               ],
               'nl': [
    1:             (r'\n', String)
               ],
               'dqs': [
    1:             (r'"', String, '#pop'),
    1:             (r'\\\\|\\"|\\\n', String.Escape),  # included here again for raw strings
    1:             include('strings')
               ],
               'sqs': [
    1:             (r"'", String, '#pop'),
    1:             (r"\\\\|\\'|\\\n", String.Escape),  # included here again for raw strings
    1:             include('strings')
               ],
               'tdqs': [
    1:             (r'"""', String, '#pop'),
    1:             include('strings'),
    1:             include('nl')
               ],
               'tsqs': [
    1:             (r"'''", String, '#pop'),
    1:             include('strings'),
    1:             include('nl')
               ],
           }
       
       
    2: class DgLexer(RegexLexer):
           """
           Lexer for `dg <http://pyos.github.com/dg>`_,
           a functional and object-oriented programming language
           running on the CPython 3 VM.
       
           .. versionadded:: 1.6
    1:     """
    1:     name = 'dg'
    1:     aliases = ['dg']
    1:     filenames = ['*.dg']
    1:     mimetypes = ['text/x-dg']
       
           tokens = {
               'root': [
    1:             (r'\s+', Text),
    1:             (r'#.*?$', Comment.Single),
       
    1:             (r'(?i)0b[01]+', Number.Bin),
    1:             (r'(?i)0o[0-7]+', Number.Oct),
    1:             (r'(?i)0x[0-9a-f]+', Number.Hex),
    1:             (r'(?i)[+-]?[0-9]+\.[0-9]+(e[+-]?[0-9]+)?j?', Number.Float),
    1:             (r'(?i)[+-]?[0-9]+e[+-]?\d+j?', Number.Float),
    1:             (r'(?i)[+-]?[0-9]+j?', Number.Integer),
       
    1:             (r"(?i)(br|r?b?)'''", String, combined('stringescape', 'tsqs', 'string')),
    1:             (r'(?i)(br|r?b?)"""', String, combined('stringescape', 'tdqs', 'string')),
    1:             (r"(?i)(br|r?b?)'", String, combined('stringescape', 'sqs', 'string')),
    1:             (r'(?i)(br|r?b?)"', String, combined('stringescape', 'dqs', 'string')),
       
    1:             (r"`\w+'*`", Operator),
    1:             (r'\b(and|in|is|or|where)\b', Operator.Word),
    1:             (r'[!$%&*+\-./:<-@\\^|~;,]+', Operator),
       
    1:             (words((
    1:                 'bool', 'bytearray', 'bytes', 'classmethod', 'complex', 'dict', 'dict\'',
                       'float', 'frozenset', 'int', 'list', 'list\'', 'memoryview', 'object',
                       'property', 'range', 'set', 'set\'', 'slice', 'staticmethod', 'str',
                       'super', 'tuple', 'tuple\'', 'type'),
    1:                    prefix=r'(?<!\.)', suffix=r'(?![\'\w])'),
    1:              Name.Builtin),
    1:             (words((
    1:                 '__import__', 'abs', 'all', 'any', 'bin', 'bind', 'chr', 'cmp', 'compile',
                       'complex', 'delattr', 'dir', 'divmod', 'drop', 'dropwhile', 'enumerate',
                       'eval', 'exhaust', 'filter', 'flip', 'foldl1?', 'format', 'fst',
                       'getattr', 'globals', 'hasattr', 'hash', 'head', 'hex', 'id', 'init',
                       'input', 'isinstance', 'issubclass', 'iter', 'iterate', 'last', 'len',
                       'locals', 'map', 'max', 'min', 'next', 'oct', 'open', 'ord', 'pow',
                       'print', 'repr', 'reversed', 'round', 'setattr', 'scanl1?', 'snd',
                       'sorted', 'sum', 'tail', 'take', 'takewhile', 'vars', 'zip'),
    1:                    prefix=r'(?<!\.)', suffix=r'(?![\'\w])'),
    1:              Name.Builtin),
    1:             (r"(?<!\.)(self|Ellipsis|NotImplemented|None|True|False)(?!['\w])",
    1:              Name.Builtin.Pseudo),
       
    1:             (r"(?<!\.)[A-Z]\w*(Error|Exception|Warning)'*(?!['\w])",
    1:              Name.Exception),
    1:             (r"(?<!\.)(Exception|GeneratorExit|KeyboardInterrupt|StopIteration|"
    1:              r"SystemExit)(?!['\w])", Name.Exception),
       
    1:             (r"(?<![\w.])(except|finally|for|if|import|not|otherwise|raise|"
    1:              r"subclass|while|with|yield)(?!['\w])", Keyword.Reserved),
       
    1:             (r"[A-Z_]+'*(?!['\w])", Name),
    1:             (r"[A-Z]\w+'*(?!['\w])", Keyword.Type),
    1:             (r"\w+'*", Name),
       
    1:             (r'[()]', Punctuation),
    1:             (r'.', Error),
               ],
               'stringescape': [
    1:             (r'\\([\\abfnrtv"\']|\n|N\{.*?\}|u[a-fA-F0-9]{4}|'
    1:              r'U[a-fA-F0-9]{8}|x[a-fA-F0-9]{2}|[0-7]{1,3})', String.Escape)
               ],
               'string': [
    1:             (r'%(\(\w+\))?[-#0 +]*([0-9]+|[*])?(\.([0-9]+|[*]))?'
    1:              '[hlL]?[E-GXc-giorsux%]', String.Interpol),
    1:             (r'[^\\\'"%\n]+', String),
                   # quotes, percents and backslashes must be parsed one at a time
    1:             (r'[\'"\\]', String),
                   # unhandled string formatting sign
    1:             (r'%', String),
    1:             (r'\n', String)
               ],
               'dqs': [
    1:             (r'"', String, '#pop')
               ],
               'sqs': [
    1:             (r"'", String, '#pop')
               ],
               'tdqs': [
    1:             (r'"""', String, '#pop')
               ],
               'tsqs': [
    1:             (r"'''", String, '#pop')
               ],
           }
       
       
    2: class NumPyLexer(PythonLexer):
           """
           A Python lexer recognizing Numerical Python builtins.
       
           .. versionadded:: 0.10
    1:     """
       
    1:     name = 'NumPy'
    1:     aliases = ['numpy']
       
           # override the mimetypes to not inherit them from python
    1:     mimetypes = []
    1:     filenames = []
       
    1:     EXTRA_KEYWORDS = set((
    1:         'abs', 'absolute', 'accumulate', 'add', 'alen', 'all', 'allclose',
               'alltrue', 'alterdot', 'amax', 'amin', 'angle', 'any', 'append',
               'apply_along_axis', 'apply_over_axes', 'arange', 'arccos', 'arccosh',
               'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh', 'argmax', 'argmin',
               'argsort', 'argwhere', 'around', 'array', 'array2string', 'array_equal',
               'array_equiv', 'array_repr', 'array_split', 'array_str', 'arrayrange',
               'asanyarray', 'asarray', 'asarray_chkfinite', 'ascontiguousarray',
               'asfarray', 'asfortranarray', 'asmatrix', 'asscalar', 'astype',
               'atleast_1d', 'atleast_2d', 'atleast_3d', 'average', 'bartlett',
               'base_repr', 'beta', 'binary_repr', 'bincount', 'binomial',
               'bitwise_and', 'bitwise_not', 'bitwise_or', 'bitwise_xor', 'blackman',
               'bmat', 'broadcast', 'byte_bounds', 'bytes', 'byteswap', 'c_',
               'can_cast', 'ceil', 'choose', 'clip', 'column_stack', 'common_type',
               'compare_chararrays', 'compress', 'concatenate', 'conj', 'conjugate',
               'convolve', 'copy', 'corrcoef', 'correlate', 'cos', 'cosh', 'cov',
               'cross', 'cumprod', 'cumproduct', 'cumsum', 'delete', 'deprecate',
               'diag', 'diagflat', 'diagonal', 'diff', 'digitize', 'disp', 'divide',
               'dot', 'dsplit', 'dstack', 'dtype', 'dump', 'dumps', 'ediff1d', 'empty',
               'empty_like', 'equal', 'exp', 'expand_dims', 'expm1', 'extract', 'eye',
               'fabs', 'fastCopyAndTranspose', 'fft', 'fftfreq', 'fftshift', 'fill',
               'finfo', 'fix', 'flat', 'flatnonzero', 'flatten', 'fliplr', 'flipud',
               'floor', 'floor_divide', 'fmod', 'frexp', 'fromarrays', 'frombuffer',
               'fromfile', 'fromfunction', 'fromiter', 'frompyfunc', 'fromstring',
               'generic', 'get_array_wrap', 'get_include', 'get_numarray_include',
               'get_numpy_include', 'get_printoptions', 'getbuffer', 'getbufsize',
               'geterr', 'geterrcall', 'geterrobj', 'getfield', 'gradient', 'greater',
               'greater_equal', 'gumbel', 'hamming', 'hanning', 'histogram',
               'histogram2d', 'histogramdd', 'hsplit', 'hstack', 'hypot', 'i0',
               'identity', 'ifft', 'imag', 'index_exp', 'indices', 'inf', 'info',
               'inner', 'insert', 'int_asbuffer', 'interp', 'intersect1d',
               'intersect1d_nu', 'inv', 'invert', 'iscomplex', 'iscomplexobj',
               'isfinite', 'isfortran', 'isinf', 'isnan', 'isneginf', 'isposinf',
               'isreal', 'isrealobj', 'isscalar', 'issctype', 'issubclass_',
               'issubdtype', 'issubsctype', 'item', 'itemset', 'iterable', 'ix_',
               'kaiser', 'kron', 'ldexp', 'left_shift', 'less', 'less_equal', 'lexsort',
               'linspace', 'load', 'loads', 'loadtxt', 'log', 'log10', 'log1p', 'log2',
               'logical_and', 'logical_not', 'logical_or', 'logical_xor', 'logspace',
               'lstsq', 'mat', 'matrix', 'max', 'maximum', 'maximum_sctype',
               'may_share_memory', 'mean', 'median', 'meshgrid', 'mgrid', 'min',
               'minimum', 'mintypecode', 'mod', 'modf', 'msort', 'multiply', 'nan',
               'nan_to_num', 'nanargmax', 'nanargmin', 'nanmax', 'nanmin', 'nansum',
               'ndenumerate', 'ndim', 'ndindex', 'negative', 'newaxis', 'newbuffer',
               'newbyteorder', 'nonzero', 'not_equal', 'obj2sctype', 'ogrid', 'ones',
               'ones_like', 'outer', 'permutation', 'piecewise', 'pinv', 'pkgload',
               'place', 'poisson', 'poly', 'poly1d', 'polyadd', 'polyder', 'polydiv',
               'polyfit', 'polyint', 'polymul', 'polysub', 'polyval', 'power', 'prod',
               'product', 'ptp', 'put', 'putmask', 'r_', 'randint', 'random_integers',
               'random_sample', 'ranf', 'rank', 'ravel', 'real', 'real_if_close',
               'recarray', 'reciprocal', 'reduce', 'remainder', 'repeat', 'require',
               'reshape', 'resize', 'restoredot', 'right_shift', 'rint', 'roll',
               'rollaxis', 'roots', 'rot90', 'round', 'round_', 'row_stack', 's_',
               'sample', 'savetxt', 'sctype2char', 'searchsorted', 'seed', 'select',
               'set_numeric_ops', 'set_printoptions', 'set_string_function',
               'setbufsize', 'setdiff1d', 'seterr', 'seterrcall', 'seterrobj',
               'setfield', 'setflags', 'setmember1d', 'setxor1d', 'shape',
               'show_config', 'shuffle', 'sign', 'signbit', 'sin', 'sinc', 'sinh',
               'size', 'slice', 'solve', 'sometrue', 'sort', 'sort_complex', 'source',
               'split', 'sqrt', 'square', 'squeeze', 'standard_normal', 'std',
               'subtract', 'sum', 'svd', 'swapaxes', 'take', 'tan', 'tanh', 'tensordot',
               'test', 'tile', 'tofile', 'tolist', 'tostring', 'trace', 'transpose',
               'trapz', 'tri', 'tril', 'trim_zeros', 'triu', 'true_divide', 'typeDict',
               'typename', 'uniform', 'union1d', 'unique', 'unique1d', 'unravel_index',
               'unwrap', 'vander', 'var', 'vdot', 'vectorize', 'view', 'vonmises',
               'vsplit', 'vstack', 'weibull', 'where', 'who', 'zeros', 'zeros_like'
           ))
       
    1:     def get_tokens_unprocessed(self, text):
               for index, token, value in \
                       PythonLexer.get_tokens_unprocessed(self, text):
                   if token is Name and value in self.EXTRA_KEYWORDS:
                       yield index, Keyword.Pseudo, value
                   else:
                       yield index, token, value
       
    1:     def analyse_text(text):
               return (shebang_matches(text, r'pythonw?(2(\.\d)?)?') or
                       'import ' in text[:1000]) \
                   and ('import numpy' in text or 'from numpy import' in text)
