    1: from abc import abstractmethod
       
    1: from parso.tree import search_ancestor
       
    1: from jedi._compatibility import Parameter
    1: from jedi.evaluate.base_context import ContextSet, NO_CONTEXTS
    1: from jedi.cache import memoize_method
       
       
    2: class AbstractNameDefinition(object):
    1:     start_pos = None
    1:     string_name = None
    1:     parent_context = None
    1:     tree_name = None
    1:     is_context_name = True
           """
           Used for the Jedi API to know if it's a keyword or an actual name.
           """
       
    1:     @abstractmethod
           def infer(self):
               raise NotImplementedError
       
    1:     @abstractmethod
           def goto(self):
               # Typically names are already definitions and therefore a goto on that
               # name will always result on itself.
               return {self}
       
    1:     def get_qualified_names(self, include_module_names=False):
               qualified_names = self._get_qualified_names()
               if qualified_names is None or not include_module_names:
                   return qualified_names
       
               module_names = self.get_root_context().string_names
               if module_names is None:
                   return None
               return module_names + qualified_names
       
    1:     def _get_qualified_names(self):
               # By default, a name has no qualified names.
               return None
       
    1:     def get_root_context(self):
               return self.parent_context.get_root_context()
       
    1:     def __repr__(self):
               if self.start_pos is None:
                   return '<%s: string_name=%s>' % (self.__class__.__name__, self.string_name)
               return '<%s: string_name=%s start_pos=%s>' % (self.__class__.__name__,
                                                             self.string_name, self.start_pos)
       
    1:     def is_import(self):
               return False
       
    1:     @property
           def api_type(self):
               return self.parent_context.api_type
       
       
    2: class AbstractArbitraryName(AbstractNameDefinition):
           """
           When you e.g. want to complete dicts keys, you probably want to complete
           string literals, which is not really a name, but for Jedi we use this
           concept of Name for completions as well.
    1:     """
    1:     is_context_name = False
       
    1:     def __init__(self, evaluator, string):
               self.evaluator = evaluator
               self.string_name = string
               self.parent_context = evaluator.builtins_module
       
    1:     def infer(self):
               return NO_CONTEXTS
       
       
    2: class AbstractTreeName(AbstractNameDefinition):
    1:     def __init__(self, parent_context, tree_name):
               self.parent_context = parent_context
               self.tree_name = tree_name
       
    1:     def get_qualified_names(self, include_module_names=False):
               import_node = search_ancestor(self.tree_name, 'import_name', 'import_from')
               # For import nodes we cannot just have names, because it's very unclear
               # how they would look like. For now we just ignore them in most cases.
               # In case of level == 1, it works always, because it's like a submodule
               # lookup.
               if import_node is not None and not (import_node.level == 1
                                                   and self.get_root_context().is_package):
                   # TODO improve the situation for when level is present.
                   if include_module_names and not import_node.level:
                       return tuple(n.value for n in import_node.get_path_for_name(self.tree_name))
                   else:
                       return None
       
               return super(AbstractTreeName, self).get_qualified_names(include_module_names)
       
    1:     def _get_qualified_names(self):
               parent_names = self.parent_context.get_qualified_names()
               if parent_names is None:
                   return None
               return parent_names + (self.tree_name.value,)
       
    1:     def goto(self, **kwargs):
               return self.parent_context.evaluator.goto(self.parent_context, self.tree_name, **kwargs)
       
    1:     def is_import(self):
               imp = search_ancestor(self.tree_name, 'import_from', 'import_name')
               return imp is not None
       
    1:     @property
           def string_name(self):
               return self.tree_name.value
       
    1:     @property
           def start_pos(self):
               return self.tree_name.start_pos
       
       
    2: class ContextNameMixin(object):
    1:     def infer(self):
               return ContextSet([self._context])
       
    1:     def _get_qualified_names(self):
               return self._context.get_qualified_names()
       
    1:     def get_root_context(self):
               if self.parent_context is None:  # A module
                   return self._context
               return super(ContextNameMixin, self).get_root_context()
       
    1:     @property
           def api_type(self):
               return self._context.api_type
       
       
    2: class ContextName(ContextNameMixin, AbstractTreeName):
    1:     def __init__(self, context, tree_name):
               super(ContextName, self).__init__(context.parent_context, tree_name)
               self._context = context
       
    1:     def goto(self):
               return ContextSet([self._context.name])
       
       
    2: class TreeNameDefinition(AbstractTreeName):
    1:     _API_TYPES = dict(
    1:         import_name='module',
    1:         import_from='module',
    1:         funcdef='function',
    1:         param='param',
    1:         classdef='class',
           )
       
    1:     def infer(self):
               # Refactor this, should probably be here.
               from jedi.evaluate.syntax_tree import tree_name_to_contexts
               parent = self.parent_context
               return tree_name_to_contexts(parent.evaluator, parent, self.tree_name)
       
    1:     @property
           def api_type(self):
               definition = self.tree_name.get_definition(import_name_always=True)
               if definition is None:
                   return 'statement'
               return self._API_TYPES.get(definition.type, 'statement')
       
       
    2: class _ParamMixin(object):
    1:     def maybe_positional_argument(self, include_star=True):
               options = [Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD]
               if include_star:
                   options.append(Parameter.VAR_POSITIONAL)
               return self.get_kind() in options
       
    1:     def maybe_keyword_argument(self, include_stars=True):
               options = [Parameter.KEYWORD_ONLY, Parameter.POSITIONAL_OR_KEYWORD]
               if include_stars:
                   options.append(Parameter.VAR_KEYWORD)
               return self.get_kind() in options
       
    1:     def _kind_string(self):
               kind = self.get_kind()
               if kind == Parameter.VAR_POSITIONAL:  # *args
                   return '*'
               if kind == Parameter.VAR_KEYWORD:  # **kwargs
                   return '**'
               return ''
       
       
    2: class ParamNameInterface(_ParamMixin):
    1:     api_type = u'param'
       
    1:     def get_kind(self):
               raise NotImplementedError
       
    1:     def to_string(self):
               raise NotImplementedError
       
    1:     def get_param(self):
               # TODO document better where this is used and when. Currently it has
               #      very limited use, but is still in use. It's currently not even
               #      clear what values would be allowed.
               return None
       
    1:     @property
           def star_count(self):
               kind = self.get_kind()
               if kind == Parameter.VAR_POSITIONAL:
                   return 1
               if kind == Parameter.VAR_KEYWORD:
                   return 2
               return 0
       
       
    2: class BaseTreeParamName(ParamNameInterface, AbstractTreeName):
    1:     annotation_node = None
    1:     default_node = None
       
    1:     def to_string(self):
               output = self._kind_string() + self.string_name
               annotation = self.annotation_node
               default = self.default_node
               if annotation is not None:
                   output += ': ' + annotation.get_code(include_prefix=False)
               if default is not None:
                   output += '=' + default.get_code(include_prefix=False)
               return output
       
       
    2: class ParamName(BaseTreeParamName):
    1:     def _get_param_node(self):
               return search_ancestor(self.tree_name, 'param')
       
    1:     @property
           def annotation_node(self):
               return self._get_param_node().annotation
       
    1:     def infer_annotation(self, execute_annotation=True):
               node = self.annotation_node
               if node is None:
                   return NO_CONTEXTS
               contexts = self.parent_context.parent_context.eval_node(node)
               if execute_annotation:
                   contexts = contexts.execute_annotation()
               return contexts
       
    1:     def infer_default(self):
               node = self.default_node
               if node is None:
                   return NO_CONTEXTS
               return self.parent_context.parent_context.eval_node(node)
       
    1:     @property
           def default_node(self):
               return self._get_param_node().default
       
    1:     @property
           def string_name(self):
               name = self.tree_name.value
               if name.startswith('__'):
                   # Params starting with __ are an equivalent to positional only
                   # variables in typeshed.
                   name = name[2:]
               return name
       
    1:     def get_kind(self):
               tree_param = self._get_param_node()
               if tree_param.star_count == 1:  # *args
                   return Parameter.VAR_POSITIONAL
               if tree_param.star_count == 2:  # **kwargs
                   return Parameter.VAR_KEYWORD
       
               # Params starting with __ are an equivalent to positional only
               # variables in typeshed.
               if tree_param.name.value.startswith('__'):
                   return Parameter.POSITIONAL_ONLY
       
               parent = tree_param.parent
               param_appeared = False
               for p in parent.children:
                   if param_appeared:
                       if p == '/':
                           return Parameter.POSITIONAL_ONLY
                   else:
                       if p == '*':
                           return Parameter.KEYWORD_ONLY
                       if p.type == 'param':
                           if p.star_count:
                               return Parameter.KEYWORD_ONLY
                           if p == tree_param:
                               param_appeared = True
               return Parameter.POSITIONAL_OR_KEYWORD
       
    1:     def infer(self):
               return self.get_param().infer()
       
    1:     def get_param(self):
               params, _ = self.parent_context.get_executed_params_and_issues()
               param_node = search_ancestor(self.tree_name, 'param')
               return params[param_node.position_index]
       
       
    2: class ParamNameWrapper(_ParamMixin):
    1:     def __init__(self, param_name):
               self._wrapped_param_name = param_name
       
    1:     def __getattr__(self, name):
               return getattr(self._wrapped_param_name, name)
       
    1:     def __repr__(self):
               return '<%s: %s>' % (self.__class__.__name__, self._wrapped_param_name)
       
       
    2: class ImportName(AbstractNameDefinition):
    1:     start_pos = (1, 0)
    1:     _level = 0
       
    1:     def __init__(self, parent_context, string_name):
               self._from_module_context = parent_context
               self.string_name = string_name
       
    1:     def get_qualified_names(self, include_module_names=False):
               if include_module_names:
                   if self._level:
                       assert self._level == 1, "Everything else is not supported for now"
                       module_names = self._from_module_context.string_names
                       if module_names is None:
                           return module_names
                       return module_names + (self.string_name,)
                   return (self.string_name,)
               return ()
       
    1:     @property
           def parent_context(self):
               m = self._from_module_context
               import_contexts = self.infer()
               if not import_contexts:
                   return m
               # It's almost always possible to find the import or to not find it. The
               # importing returns only one context, pretty much always.
               return next(iter(import_contexts))
       
    1:     @memoize_method
           def infer(self):
               from jedi.evaluate.imports import Importer
               m = self._from_module_context
               return Importer(m.evaluator, [self.string_name], m, level=self._level).follow()
       
    1:     def goto(self):
               return [m.name for m in self.infer()]
       
    1:     @property
           def api_type(self):
               return 'module'
       
       
    2: class SubModuleName(ImportName):
    1:     _level = 1
       
       
    2: class NameWrapper(object):
    1:     def __init__(self, wrapped_name):
               self._wrapped_name = wrapped_name
       
    1:     @abstractmethod
           def infer(self):
               raise NotImplementedError
       
    1:     def __getattr__(self, name):
               return getattr(self._wrapped_name, name)
       
    1:     def __repr__(self):
               return '%s(%s)' % (self.__class__.__name__, self._wrapped_name)
