    1: from __future__ import unicode_literals
    1: from abc import ABCMeta, abstractmethod
    1: from six import with_metaclass
       
    1: from prompt_toolkit.utils import test_callable_args
       
       __all__ = [
    1:     'Filter',
    1:     'Never',
    1:     'Always',
    1:     'Condition',
       ]
       
       
    2: class Filter(with_metaclass(ABCMeta, object)):
           """
           Base class for any filter to activate/deactivate a feature, depending on a
           condition.
       
           The return value of ``__call__`` will tell if the feature should be active.
    1:     """
    1:     @abstractmethod
           def __call__(self):
               """
               The actual call to evaluate the filter.
               """
               return True
       
    1:     def __and__(self, other):
               """
               Chaining of filters using the & operator.
               """
               return _and_cache[self, other]
       
    1:     def __or__(self, other):
               """
               Chaining of filters using the | operator.
               """
    1:         return _or_cache[self, other]
       
    1:     def __invert__(self):
               """
               Inverting of filters using the ~ operator.
               """
               return _invert_cache[self]
       
    1:     def __bool__(self):
               """
               By purpose, we don't allow bool(...) operations directly on a filter,
               because the meaning is ambiguous.
       
               Executing a filter has to be done always by calling it. Providing
               defaults for `None` values should be done through an `is None` check
               instead of for instance ``filter1 or Always()``.
               """
               raise ValueError('The truth value of a Filter is ambiguous. '
                                'Instead, call it as a function.')
       
    1:     __nonzero__ = __bool__  # For Python 2.
       
       
    2: class _AndCache(dict):
           """
           Cache for And operation between filters.
           (Filter classes are stateless, so we can reuse them.)
       
           Note: This could be a memory leak if we keep creating filters at runtime.
                 If that is True, the filters should be weakreffed (not the tuple of
                 filters), and tuples should be removed when one of these filters is
                 removed. In practise however, there is a finite amount of filters.
    1:     """
    1:     def __missing__(self, filters):
               a, b = filters
               assert isinstance(b, Filter), 'Expecting filter, got %r' % b
       
               if isinstance(b, Always) or isinstance(a, Never):
                   return a
               elif isinstance(b, Never) or isinstance(a, Always):
                   return b
       
               result = _AndList(filters)
               self[filters] = result
               return result
       
       
    2: class _OrCache(dict):
    1:     """ Cache for Or operation between filters. """
    1:     def __missing__(self, filters):
    1:         a, b = filters
    1:         assert isinstance(b, Filter), 'Expecting filter, got %r' % b
       
    1:         if isinstance(b, Always) or isinstance(a, Never):
                   return b
    1:         elif isinstance(b, Never) or isinstance(a, Always):
                   return a
       
    1:         result = _OrList(filters)
    1:         self[filters] = result
    1:         return result
       
       
    2: class _InvertCache(dict):
    1:     """ Cache for inversion operator. """
    1:     def __missing__(self, filter):
               result = _Invert(filter)
               self[filter] = result
               return result
       
       
    1: _and_cache = _AndCache()
    1: _or_cache = _OrCache()
    1: _invert_cache = _InvertCache()
       
       
    2: class _AndList(Filter):
           """
           Result of &-operation between several filters.
    1:     """
    1:     def __init__(self, filters):
               all_filters = []
       
               for f in filters:
                   if isinstance(f, _AndList):  # Turn nested _AndLists into one.
                       all_filters.extend(f.filters)
                   else:
                       all_filters.append(f)
       
               self.filters = all_filters
       
    1:     def __call__(self):
               return all(f() for f in self.filters)
       
    1:     def __repr__(self):
               return '&'.join(repr(f) for f in self.filters)
       
       
    2: class _OrList(Filter):
           """
           Result of |-operation between several filters.
    1:     """
    1:     def __init__(self, filters):
    1:         all_filters = []
       
    3:         for f in filters:
    2:             if isinstance(f, _OrList):  # Turn nested _OrLists into one.
                       all_filters.extend(f.filters)
                   else:
    2:                 all_filters.append(f)
       
    1:         self.filters = all_filters
       
    1:     def __call__(self):
               return any(f() for f in self.filters)
       
    1:     def __repr__(self):
               return '|'.join(repr(f) for f in self.filters)
       
       
    2: class _Invert(Filter):
           """
           Negation of another filter.
    1:     """
    1:     def __init__(self, filter):
               self.filter = filter
       
    1:     def __call__(self):
               return not self.filter()
       
    1:     def __repr__(self):
               return '~%r' % self.filter
       
       
    2: class Always(Filter):
           """
           Always enable feature.
    1:     """
    1:     def __call__(self):
               return True
       
    1:     def __invert__(self):
               return Never()
       
       
    2: class Never(Filter):
           """
           Never enable feature.
    1:     """
    1:     def __call__(self):
               return False
       
    1:     def __invert__(self):
               return Always()
       
       
    2: class Condition(Filter):
           """
           Turn any callable into a Filter. The callable is supposed to not take any
           arguments.
       
           This can be used as a decorator::
       
               @Condition
               def feature_is_active():  # `feature_is_active` becomes a Filter.
                   return True
       
           :param func: Callable which takes no inputs and returns a boolean.
    1:     """
    1:     def __init__(self, func):
   27:         assert callable(func)
   27:         assert test_callable_args(func, [])
   27:         self.func = func
       
    1:     def __call__(self):
               return self.func()
       
    1:     def __repr__(self):
               return 'Condition(%r)' % self.func
