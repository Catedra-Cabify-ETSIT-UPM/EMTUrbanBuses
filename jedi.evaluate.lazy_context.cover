    1: from jedi.evaluate.base_context import ContextSet, NO_CONTEXTS
    1: from jedi.common.utils import monkeypatch
       
       
    2: class AbstractLazyContext(object):
    1:     def __init__(self, data):
               self.data = data
       
    1:     def __repr__(self):
               return '<%s: %s>' % (self.__class__.__name__, self.data)
       
    1:     def infer(self):
               raise NotImplementedError
       
       
    2: class LazyKnownContext(AbstractLazyContext):
    1:     """data is a context."""
    1:     def infer(self):
               return ContextSet([self.data])
       
       
    2: class LazyKnownContexts(AbstractLazyContext):
    1:     """data is a ContextSet."""
    1:     def infer(self):
               return self.data
       
       
    2: class LazyUnknownContext(AbstractLazyContext):
    1:     def __init__(self):
               super(LazyUnknownContext, self).__init__(None)
       
    1:     def infer(self):
               return NO_CONTEXTS
       
       
    2: class LazyTreeContext(AbstractLazyContext):
    1:     def __init__(self, context, node):
               super(LazyTreeContext, self).__init__(node)
               self.context = context
               # We need to save the predefined names. It's an unfortunate side effect
               # that needs to be tracked otherwise results will be wrong.
               self._predefined_names = dict(context.predefined_names)
       
    1:     def infer(self):
               with monkeypatch(self.context, 'predefined_names', self._predefined_names):
                   return self.context.eval_node(self.data)
       
       
    1: def get_merged_lazy_context(lazy_contexts):
           if len(lazy_contexts) > 1:
               return MergedLazyContexts(lazy_contexts)
           else:
               return lazy_contexts[0]
       
       
    2: class MergedLazyContexts(AbstractLazyContext):
    1:     """data is a list of lazy contexts."""
    1:     def infer(self):
               return ContextSet.from_sets(l.infer() for l in self.data)
