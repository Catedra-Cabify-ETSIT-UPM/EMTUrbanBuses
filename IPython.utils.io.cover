       # encoding: utf-8
       """
       IO related utilities.
    1: """
       
       # Copyright (c) IPython Development Team.
       # Distributed under the terms of the Modified BSD License.
       
       
       
    1: import atexit
    1: import os
    1: import sys
    1: import tempfile
    1: import warnings
    1: from warnings import warn
       
    1: from IPython.utils.decorators import undoc
    1: from .capture import CapturedIO, capture_output
       
    2: @undoc
       class IOStream:
       
    1:     def __init__(self, stream, fallback=None):
    3:         warn('IOStream is deprecated since IPython 5.0, use sys.{stdin,stdout,stderr} instead',
    3:              DeprecationWarning, stacklevel=2)
    3:         if not hasattr(stream,'write') or not hasattr(stream,'flush'):
                   if fallback is not None:
                       stream = fallback
                   else:
                       raise ValueError("fallback required, but not specified")
    3:         self.stream = stream
    3:         self._swrite = stream.write
       
               # clone all methods not overridden:
    3:         def clone(meth):
  186:             return not hasattr(self, meth) and not meth.startswith('_')
   69:         for meth in filter(clone, dir(stream)):
   66:             try:
   66:                 val = getattr(stream, meth)
                   except AttributeError:
                       pass
                   else:
   66:                 setattr(self, meth, val)
       
    1:     def __repr__(self):
               cls = self.__class__
               tpl = '{mod}.{cls}({args})'
               return tpl.format(mod=cls.__module__, cls=cls.__name__, args=self.stream)
       
    1:     def write(self,data):
               warn('IOStream is deprecated since IPython 5.0, use sys.{stdin,stdout,stderr} instead',
                    DeprecationWarning, stacklevel=2)
               try:
                   self._swrite(data)
               except:
                   try:
                       # print handles some unicode issues which may trip a plain
                       # write() call.  Emulate write() by using an empty end
                       # argument.
                       print(data, end='', file=self.stream)
                   except:
                       # if we get here, something is seriously broken.
                       print('ERROR - failed to write data to stream:', self.stream,
                             file=sys.stderr)
       
    1:     def writelines(self, lines):
               warn('IOStream is deprecated since IPython 5.0, use sys.{stdin,stdout,stderr} instead',
                    DeprecationWarning, stacklevel=2)
               if isinstance(lines, str):
                   lines = [lines]
               for line in lines:
                   self.write(line)
       
           # This class used to have a writeln method, but regular files and streams
           # in Python don't have this method. We need to keep this completely
           # compatible so we removed it.
       
    1:     @property
           def closed(self):
    3:         return self.stream.closed
       
    1:     def close(self):
               pass
       
       # setup stdin/stdout/stderr to sys.stdin/sys.stdout/sys.stderr
    1: devnull = open(os.devnull, 'w')
    1: atexit.register(devnull.close)
       
       # io.std* are deprecated, but don't show our own deprecation warnings
       # during initialization of the deprecated API.
    1: with warnings.catch_warnings():
    1:     warnings.simplefilter('ignore', DeprecationWarning)
    1:     stdin = IOStream(sys.stdin, fallback=devnull)
    1:     stdout = IOStream(sys.stdout, fallback=devnull)
    1:     stderr = IOStream(sys.stderr, fallback=devnull)
       
    2: class Tee(object):
           """A class to duplicate an output stream to stdout/err.
       
           This works in a manner very similar to the Unix 'tee' command.
       
           When the object is closed or deleted, it closes the original file given to
           it for duplication.
    1:     """
           # Inspired by:
           # http://mail.python.org/pipermail/python-list/2007-May/442737.html
       
    1:     def __init__(self, file_or_name, mode="w", channel='stdout'):
               """Construct a new Tee object.
       
               Parameters
               ----------
               file_or_name : filename or open filehandle (writable)
                 File that will be duplicated
       
               mode : optional, valid mode for open().
                 If a filename was give, open with this mode.
       
               channel : str, one of ['stdout', 'stderr']
               """
               if channel not in ['stdout', 'stderr']:
                   raise ValueError('Invalid channel spec %s' % channel)
       
               if hasattr(file_or_name, 'write') and hasattr(file_or_name, 'seek'):
                   self.file = file_or_name
               else:
                   self.file = open(file_or_name, mode)
               self.channel = channel
               self.ostream = getattr(sys, channel)
               setattr(sys, channel, self)
               self._closed = False
       
    1:     def close(self):
               """Close the file and restore the channel."""
               self.flush()
               setattr(sys, self.channel, self.ostream)
               self.file.close()
               self._closed = True
       
    1:     def write(self, data):
               """Write data to both channels."""
               self.file.write(data)
               self.ostream.write(data)
               self.ostream.flush()
       
    1:     def flush(self):
               """Flush both channels."""
               self.file.flush()
               self.ostream.flush()
       
    1:     def __del__(self):
               if not self._closed:
                   self.close()
       
       
    1: def ask_yes_no(prompt, default=None, interrupt=None):
           """Asks a question and returns a boolean (y/n) answer.
       
           If default is given (one of 'y','n'), it is used if the user input is
           empty. If interrupt is given (one of 'y','n'), it is used if the user
           presses Ctrl-C. Otherwise the question is repeated until an answer is
           given.
       
           An EOF is treated as the default answer.  If there is no default, an
           exception is raised to prevent infinite loops.
       
           Valid answers are: y/yes/n/no (match is not case sensitive)."""
       
           answers = {'y':True,'n':False,'yes':True,'no':False}
           ans = None
           while ans not in answers.keys():
               try:
                   ans = input(prompt+' ').lower()
                   if not ans:  # response was an empty string
                       ans = default
               except KeyboardInterrupt:
                   if interrupt:
                       ans = interrupt
                   print("\r")
               except EOFError:
                   if default in answers.keys():
                       ans = default
                       print()
                   else:
                       raise
       
           return answers[ans]
       
       
    1: def temp_pyfile(src, ext='.py'):
           """Make a temporary python file, return filename and filehandle.
       
           Parameters
           ----------
           src : string or list of strings (no need for ending newlines if list)
             Source code to be written to the file.
       
           ext : optional, string
             Extension for the generated file.
       
           Returns
           -------
           (filename, open filehandle)
             It is the caller's responsibility to close the open file and unlink it.
           """
           fname = tempfile.mkstemp(ext)[1]
           with open(fname,'w') as f:
               f.write(src)
               f.flush()
           return fname
       
    1: @undoc
       def atomic_writing(*args, **kwargs):
           """DEPRECATED: moved to notebook.services.contents.fileio"""
           warn("IPython.utils.io.atomic_writing has moved to notebook.services.contents.fileio since IPython 4.0", DeprecationWarning, stacklevel=2)
           from notebook.services.contents.fileio import atomic_writing
           return atomic_writing(*args, **kwargs)
       
    1: @undoc
       def raw_print(*args, **kw):
           """DEPRECATED: Raw print to sys.__stdout__, otherwise identical interface to print()."""
           warn("IPython.utils.io.raw_print has been deprecated since IPython 7.0", DeprecationWarning, stacklevel=2)
       
           print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\n'),
                 file=sys.__stdout__)
           sys.__stdout__.flush()
       
    1: @undoc
       def raw_print_err(*args, **kw):
           """DEPRECATED: Raw print to sys.__stderr__, otherwise identical interface to print()."""
           warn("IPython.utils.io.raw_print_err has been deprecated since IPython 7.0", DeprecationWarning, stacklevel=2)
       
           print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\n'),
                 file=sys.__stderr__)
           sys.__stderr__.flush()
       
       # used by IPykernel <- 4.9. Removed during IPython 7-dev period and re-added 
       # Keep for a version or two then should remove
    1: rprint = raw_print
    1: rprinte = raw_print_err
       
    1: @undoc
    1: def unicode_std_stream(stream='stdout'):
           """DEPRECATED, moved to nbconvert.utils.io"""
           warn("IPython.utils.io.unicode_std_stream has moved to nbconvert.utils.io since IPython 4.0", DeprecationWarning, stacklevel=2)
           from nbconvert.utils.io import unicode_std_stream
           return unicode_std_stream(stream)
