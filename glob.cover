    1: """Filename globbing utility."""
       
    1: import os
    1: import re
    1: import fnmatch
       
    1: __all__ = ["glob", "iglob", "escape"]
       
    1: def glob(pathname, *, recursive=False):
           """Return a list of paths matching a pathname pattern.
       
           The pattern may contain simple shell-style wildcards a la
           fnmatch. However, unlike fnmatch, filenames starting with a
           dot are special cases that are not matched by '*' and '?'
           patterns.
       
           If recursive is true, the pattern '**' will match any files and
           zero or more directories and subdirectories.
           """
    1:     return list(iglob(pathname, recursive=recursive))
       
    1: def iglob(pathname, *, recursive=False):
           """Return an iterator which yields the paths matching a pathname pattern.
       
           The pattern may contain simple shell-style wildcards a la
           fnmatch. However, unlike fnmatch, filenames starting with a
           dot are special cases that are not matched by '*' and '?'
           patterns.
       
           If recursive is true, the pattern '**' will match any files and
           zero or more directories and subdirectories.
           """
    1:     it = _iglob(pathname, recursive, False)
    1:     if recursive and _isrecursive(pathname):
               s = next(it)  # skip empty string
               assert not s
    1:     return it
       
    1: def _iglob(pathname, recursive, dironly):
    1:     dirname, basename = os.path.split(pathname)
    1:     if not has_magic(pathname):
               assert not dironly
               if basename:
                   if os.path.lexists(pathname):
                       yield pathname
               else:
                   # Patterns ending with a slash should match only directories
                   if os.path.isdir(dirname):
                       yield pathname
               return
    1:     if not dirname:
               if recursive and _isrecursive(basename):
                   yield from _glob2(dirname, basename, dironly)
               else:
                   yield from _glob1(dirname, basename, dironly)
               return
           # `os.path.split()` returns the argument itself as a dirname if it is a
           # drive or UNC path.  Prevent an infinite recursion if a drive or UNC path
           # contains magic characters (i.e. r'\\?\C:').
    1:     if dirname != pathname and has_magic(dirname):
               dirs = _iglob(dirname, recursive, True)
           else:
    1:         dirs = [dirname]
    1:     if has_magic(basename):
    1:         if recursive and _isrecursive(basename):
                   glob_in_dir = _glob2
               else:
    1:             glob_in_dir = _glob1
           else:
               glob_in_dir = _glob0
    2:     for dirname in dirs:
    2:         for name in glob_in_dir(dirname, basename, dironly):
    1:             yield os.path.join(dirname, name)
       
       # These 2 helper functions non-recursively glob inside a literal directory.
       # They return a list of basenames.  _glob1 accepts a pattern while _glob0
       # takes a literal basename (so it only has to check for its existence).
       
    1: def _glob1(dirname, pattern, dironly):
    1:     names = list(_iterdir(dirname, dironly))
    1:     if not _ishidden(pattern):
    4:         names = (x for x in names if not _ishidden(x))
    1:     return fnmatch.filter(names, pattern)
       
    1: def _glob0(dirname, basename, dironly):
           if not basename:
               # `os.path.split()` returns an empty basename for paths ending with a
               # directory separator.  'q*x/' should match only directories.
               if os.path.isdir(dirname):
                   return [basename]
           else:
               if os.path.lexists(os.path.join(dirname, basename)):
                   return [basename]
           return []
       
       # Following functions are not public but can be used by third-party code.
       
    1: def glob0(dirname, pattern):
           return _glob0(dirname, pattern, False)
       
    1: def glob1(dirname, pattern):
           return _glob1(dirname, pattern, False)
       
       # This helper function recursively yields relative pathnames inside a literal
       # directory.
       
    1: def _glob2(dirname, pattern, dironly):
           assert _isrecursive(pattern)
           yield pattern[:0]
           yield from _rlistdir(dirname, dironly)
       
       # If dironly is false, yields all file names inside a directory.
       # If dironly is true, yields only directory names.
    1: def _iterdir(dirname, dironly):
    1:     if not dirname:
               if isinstance(dirname, bytes):
                   dirname = bytes(os.curdir, 'ASCII')
               else:
                   dirname = os.curdir
    1:     try:
    1:         with os.scandir(dirname) as it:
    3:             for entry in it:
    2:                 try:
    2:                     if not dironly or entry.is_dir():
    2:                         yield entry.name
                       except OSError:
                           pass
           except OSError:
               return
       
       # Recursively yields relative pathnames inside a literal directory.
    1: def _rlistdir(dirname, dironly):
           names = list(_iterdir(dirname, dironly))
           for x in names:
               if not _ishidden(x):
                   yield x
                   path = os.path.join(dirname, x) if dirname else x
                   for y in _rlistdir(path, dironly):
                       yield os.path.join(x, y)
       
       
    1: magic_check = re.compile('([*?[])')
    1: magic_check_bytes = re.compile(b'([*?[])')
       
    1: def has_magic(s):
    3:     if isinstance(s, bytes):
               match = magic_check_bytes.search(s)
           else:
    3:         match = magic_check.search(s)
    3:     return match is not None
       
    1: def _ishidden(path):
    3:     return path[0] in ('.', b'.'[0])
       
    1: def _isrecursive(pattern):
           if isinstance(pattern, bytes):
               return pattern == b'**'
           else:
               return pattern == '**'
       
    1: def escape(pathname):
           """Escape all special characters.
           """
           # Escaping is done by wrapping any of "*?[" between square brackets.
           # Metacharacters do not work in the drive part and shouldn't be escaped.
           drive, pathname = os.path.splitdrive(pathname)
           if isinstance(pathname, bytes):
               pathname = magic_check_bytes.sub(br'[\1]', pathname)
           else:
               pathname = magic_check.sub(r'[\1]', pathname)
           return drive + pathname
