       # Fiona's date and time is founded on RFC 3339.
       #
       # OGR knows 3 time "zones": GMT, "local time", amd "unknown". Fiona, when
       # writing will convert times with a timezone offset to GMT (Z) and otherwise
       # will write times with the unknown zone.
       
    1: import datetime
    1: import logging
    1: import re
       
    1: log = logging.getLogger("Fiona")
       
       # Fiona's 'date', 'time', and 'datetime' types are sub types of 'str'.
       
    2: class FionaDateType(str):
    1:     """Dates without time."""
       
    2: class FionaTimeType(str):
    1:     """Times without dates."""
       
    2: class FionaDateTimeType(str):
    1:     """Dates and times."""
       
    1: pattern_date = re.compile(r"(\d\d\d\d)(-)?(\d\d)(-)?(\d\d)")
    1: pattern_time = re.compile(
    1:     r"(\d\d)(:)?(\d\d)(:)?(\d\d)?(\.\d+)?(Z|([+-])?(\d\d)?(:)?(\d\d))?" )
    1: pattern_datetime = re.compile(
    1:     r"(\d\d\d\d)(-)?(\d\d)(-)?(\d\d)(T)?(\d\d)(:)?(\d\d)(:)?(\d\d)?(\.\d+)?(Z|([+-])?(\d\d)?(:)?(\d\d))?" )
       
    2: class group_accessor(object):
    1:     def __init__(self, m):
               self.match = m
    1:     def group(self, i):
               try:
                   return self.match.group(i) or 0
               except IndexError:
                   return 0
       
    1: def parse_time(text):
           """Given a RFC 3339 time, returns a tz-naive datetime tuple"""
           match = re.search(pattern_time, text)
           if match is None:
               raise ValueError("Time data '%s' does not match pattern" % text)
           g = group_accessor(match)
           log.debug("Match groups: %s", match.groups())
           return (0, 0, 0,
               int(g.group(1)), 
               int(g.group(3)), 
               int(g.group(5)), 
               1000000.0*float(g.group(6)) )
       
    1: def parse_date(text):
           """Given a RFC 3339 date, returns a tz-naive datetime tuple"""
           match = re.search(pattern_date, text)
           if match is None:
               raise ValueError("Time data '%s' does not match pattern" % text)
           g = group_accessor(match)
           log.debug("Match groups: %s", match.groups())
           return (
               int(g.group(1)), 
               int(g.group(3)), 
               int(g.group(5)),
               0, 0, 0, 0.0 )
       
    1: def parse_datetime(text):
           """Given a RFC 3339 datetime, returns a tz-naive datetime tuple"""
           match = re.search(pattern_datetime, text)
           if match is None:
               raise ValueError("Time data '%s' does not match pattern" % text)
           g = group_accessor(match)
           log.debug("Match groups: %s", match.groups())
           return (
               int(g.group(1)), 
               int(g.group(3)), 
               int(g.group(5)),
               int(g.group(7)), 
               int(g.group(9)), 
               int(g.group(11)), 
               1000000.0*float(g.group(12)) )
       
