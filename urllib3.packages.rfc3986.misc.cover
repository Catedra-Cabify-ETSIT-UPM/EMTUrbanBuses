       # -*- coding: utf-8 -*-
       # Copyright (c) 2014 Rackspace
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       #    http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
       # implied.
       # See the License for the specific language governing permissions and
       # limitations under the License.
       """
       Module containing compiled regular expressions and constants.
       
       This module contains important constants, patterns, and compiled regular
       expressions for parsing and validating URIs and their components.
    1: """
       
    1: import re
       
    1: from . import abnf_regexp
       
       # These are enumerated for the named tuple used as a superclass of
       # URIReference
    1: URI_COMPONENTS = ['scheme', 'authority', 'path', 'query', 'fragment']
       
       important_characters = {
    1:     'generic_delimiters': abnf_regexp.GENERIC_DELIMITERS,
    1:     'sub_delimiters': abnf_regexp.SUB_DELIMITERS,
           # We need to escape the '*' in this case
    1:     're_sub_delimiters': abnf_regexp.SUB_DELIMITERS_RE,
    1:     'unreserved_chars': abnf_regexp.UNRESERVED_CHARS,
           # We need to escape the '-' in this case:
    1:     're_unreserved': abnf_regexp.UNRESERVED_RE,
       }
       
       # For details about delimiters and reserved characters, see:
       # http://tools.ietf.org/html/rfc3986#section-2.2
    1: GENERIC_DELIMITERS = abnf_regexp.GENERIC_DELIMITERS_SET
    1: SUB_DELIMITERS = abnf_regexp.SUB_DELIMITERS_SET
    1: RESERVED_CHARS = abnf_regexp.RESERVED_CHARS_SET
       # For details about unreserved characters, see:
       # http://tools.ietf.org/html/rfc3986#section-2.3
    1: UNRESERVED_CHARS = abnf_regexp.UNRESERVED_CHARS_SET
    1: NON_PCT_ENCODED = abnf_regexp.NON_PCT_ENCODED_SET
       
    1: URI_MATCHER = re.compile(abnf_regexp.URL_PARSING_RE)
       
    1: SUBAUTHORITY_MATCHER = re.compile((
    1:     '^(?:(?P<userinfo>{0})@)?'  # userinfo
           '(?P<host>{1})'  # host
           ':?(?P<port>{2})?$'  # port
    1:     ).format(abnf_regexp.USERINFO_RE,
    1:              abnf_regexp.HOST_PATTERN,
    1:              abnf_regexp.PORT_RE))
       
       
    1: HOST_MATCHER = re.compile('^' + abnf_regexp.HOST_RE + '$')
    1: IPv4_MATCHER = re.compile('^' + abnf_regexp.IPv4_RE + '$')
    1: IPv6_MATCHER = re.compile(r'^\[' + abnf_regexp.IPv6_ADDRZ_RFC4007_RE + r'\]$')
       
       # Used by host validator
    1: IPv6_NO_RFC4007_MATCHER = re.compile(r'^\[%s\]$' % (
    1:     abnf_regexp.IPv6_ADDRZ_RE
       ))
       
       # Matcher used to validate path components
    1: PATH_MATCHER = re.compile(abnf_regexp.PATH_RE)
       
       
       # ##################################
       # Query and Fragment Matcher Section
       # ##################################
       
    1: QUERY_MATCHER = re.compile(abnf_regexp.QUERY_RE)
       
    1: FRAGMENT_MATCHER = QUERY_MATCHER
       
       # Scheme validation, see: http://tools.ietf.org/html/rfc3986#section-3.1
    1: SCHEME_MATCHER = re.compile('^{0}$'.format(abnf_regexp.SCHEME_RE))
       
    1: RELATIVE_REF_MATCHER = re.compile(r'^%s(\?%s)?(#%s)?$' % (
    1:     abnf_regexp.RELATIVE_PART_RE,
    1:     abnf_regexp.QUERY_RE,
    1:     abnf_regexp.FRAGMENT_RE,
       ))
       
       # See http://tools.ietf.org/html/rfc3986#section-4.3
    1: ABSOLUTE_URI_MATCHER = re.compile(r'^%s:%s(\?%s)?$' % (
    1:     abnf_regexp.COMPONENT_PATTERN_DICT['scheme'],
    1:     abnf_regexp.HIER_PART_RE,
    1:     abnf_regexp.QUERY_RE[1:-1],
       ))
       
       # ###############
       # IRIs / RFC 3987
       # ###############
       
    1: IRI_MATCHER = re.compile(abnf_regexp.URL_PARSING_RE, re.UNICODE)
       
    1: ISUBAUTHORITY_MATCHER = re.compile((
    1:     u'^(?:(?P<userinfo>{0})@)?'  # iuserinfo
           u'(?P<host>{1})'  # ihost
           u':?(?P<port>{2})?$'  # port
    1:     ).format(abnf_regexp.IUSERINFO_RE,
    1:              abnf_regexp.IHOST_RE,
    1:              abnf_regexp.PORT_RE), re.UNICODE)
       
       
       # Path merger as defined in http://tools.ietf.org/html/rfc3986#section-5.2.3
    1: def merge_paths(base_uri, relative_path):
           """Merge a base URI's path with a relative URI's path."""
           if base_uri.path is None and base_uri.authority is not None:
               return '/' + relative_path
           else:
               path = base_uri.path or ''
               index = path.rfind('/')
               return path[:index] + '/' + relative_path
       
       
    1: UseExisting = object()
