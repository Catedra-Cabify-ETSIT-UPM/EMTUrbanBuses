    1: from __future__ import print_function
    1: import inspect
    1: import types
    1: import sys
    1: import operator as op
    1: from collections import namedtuple
       
    1: from jedi._compatibility import unicode, is_py3, builtins, \
           py_version, force_unicode
    1: from jedi.evaluate.compiled.getattr_static import getattr_static
       
    1: ALLOWED_GETITEM_TYPES = (str, list, tuple, unicode, bytes, bytearray, dict)
       
    1: MethodDescriptorType = type(str.replace)
       # These are not considered classes and access is granted even though they have
       # a __class__ attribute.
       NOT_CLASS_TYPES = (
    1:     types.BuiltinFunctionType,
    1:     types.CodeType,
    1:     types.FrameType,
    1:     types.FunctionType,
    1:     types.GeneratorType,
    1:     types.GetSetDescriptorType,
    1:     types.LambdaType,
    1:     types.MemberDescriptorType,
    1:     types.MethodType,
    1:     types.ModuleType,
    1:     types.TracebackType,
    1:     MethodDescriptorType
       )
       
    1: if is_py3:
    1:     NOT_CLASS_TYPES += (
    1:         types.MappingProxyType,
    1:         types.SimpleNamespace,
    1:         types.DynamicClassAttribute,
           )
       
       
       # Those types don't exist in typing.
    1: MethodDescriptorType = type(str.replace)
    1: WrapperDescriptorType = type(set.__iter__)
       # `object.__subclasshook__` is an already executed descriptor.
    1: object_class_dict = type.__dict__["__dict__"].__get__(object)
    1: ClassMethodDescriptorType = type(object_class_dict['__subclasshook__'])
       
    1: _sentinel = object()
       
       # Maps Python syntax to the operator module.
       COMPARISON_OPERATORS = {
    1:     '==': op.eq,
    1:     '!=': op.ne,
    1:     'is': op.is_,
    1:     'is not': op.is_not,
    1:     '<': op.lt,
    1:     '<=': op.le,
    1:     '>': op.gt,
    1:     '>=': op.ge,
       }
       
       _OPERATORS = {
    1:     '+': op.add,
    1:     '-': op.sub,
       }
    1: _OPERATORS.update(COMPARISON_OPERATORS)
       
       ALLOWED_DESCRIPTOR_ACCESS = (
    1:     types.FunctionType,
    1:     types.GetSetDescriptorType,
    1:     types.MemberDescriptorType,
    1:     MethodDescriptorType,
    1:     WrapperDescriptorType,
    1:     ClassMethodDescriptorType,
    1:     staticmethod,
    1:     classmethod,
       )
       
       
    1: def safe_getattr(obj, name, default=_sentinel):
           try:
               attr, is_get_descriptor = getattr_static(obj, name)
           except AttributeError:
               if default is _sentinel:
                   raise
               return default
           else:
               if isinstance(attr, ALLOWED_DESCRIPTOR_ACCESS):
                   # In case of descriptors that have get methods we cannot return
                   # it's value, because that would mean code execution.
                   # Since it's an isinstance call, code execution is still possible,
                   # but this is not really a security feature, but much more of a
                   # safety feature. Code execution is basically always possible when
                   # a module is imported. This is here so people don't shoot
                   # themselves in the foot.
                   return getattr(obj, name)
           return attr
       
       
    1: SignatureParam = namedtuple(
    1:     'SignatureParam',
    1:     'name has_default default default_string has_annotation annotation annotation_string kind_name'
       )
       
       
    1: def compiled_objects_cache(attribute_name):
    1:     def decorator(func):
               """
               This decorator caches just the ids, oopposed to caching the object itself.
               Caching the id has the advantage that an object doesn't need to be
               hashable.
               """
    1:         def wrapper(evaluator, obj, parent_context=None):
                   cache = getattr(evaluator, attribute_name)
                   # Do a very cheap form of caching here.
                   key = id(obj)
                   try:
                       cache[key]
                       return cache[key][0]
                   except KeyError:
                       # TODO wuaaaarrghhhhhhhh
                       if attribute_name == 'mixed_cache':
                           result = func(evaluator, obj, parent_context)
                       else:
                           result = func(evaluator, obj)
                       # Need to cache all of them, otherwise the id could be overwritten.
                       cache[key] = result, obj, parent_context
                       return result
    1:         return wrapper
       
    1:     return decorator
       
       
    1: def create_access(evaluator, obj):
           return evaluator.compiled_subprocess.get_or_create_access_handle(obj)
       
       
    1: def load_module(evaluator, dotted_name, sys_path):
           temp, sys.path = sys.path, sys_path
           try:
               __import__(dotted_name)
           except ImportError:
               # If a module is "corrupt" or not really a Python module or whatever.
               print('Module %s not importable in path %s.' % (dotted_name, sys_path), file=sys.stderr)
               return None
           except Exception:
               # Since __import__ pretty much makes code execution possible, just
               # catch any error here and print it.
               import traceback
               print("Cannot import:\n%s" % traceback.format_exc(), file=sys.stderr)
               return None
           finally:
               sys.path = temp
       
           # Just access the cache after import, because of #59 as well as the very
           # complicated import structure of Python.
           module = sys.modules[dotted_name]
           return create_access_path(evaluator, module)
       
       
    2: class AccessPath(object):
    1:     def __init__(self, accesses):
               self.accesses = accesses
       
           # Writing both of these methods here looks a bit ridiculous. However with
           # the differences of Python 2/3 it's actually necessary, because we will
           # otherwise have a accesses attribute that is bytes instead of unicode.
    1:     def __getstate__(self):
               return self.accesses
       
    1:     def __setstate__(self, value):
               self.accesses = value
       
       
    1: def create_access_path(evaluator, obj):
           access = create_access(evaluator, obj)
           return AccessPath(access.get_access_path_tuples())
       
       
    1: def _force_unicode_decorator(func):
    1:     return lambda *args, **kwargs: force_unicode(func(*args, **kwargs))
       
       
    1: def get_api_type(obj):
           if inspect.isclass(obj):
               return u'class'
           elif inspect.ismodule(obj):
               return u'module'
           elif inspect.isbuiltin(obj) or inspect.ismethod(obj) \
                   or inspect.ismethoddescriptor(obj) or inspect.isfunction(obj):
               return u'function'
           # Everything else...
           return u'instance'
       
       
    2: class DirectObjectAccess(object):
    1:     def __init__(self, evaluator, obj):
               self._evaluator = evaluator
               self._obj = obj
       
    1:     def __repr__(self):
               return '%s(%s)' % (self.__class__.__name__, self.get_repr())
       
    1:     def _create_access(self, obj):
               return create_access(self._evaluator, obj)
       
    1:     def _create_access_path(self, obj):
               return create_access_path(self._evaluator, obj)
       
    1:     def py__bool__(self):
               return bool(self._obj)
       
    1:     def py__file__(self):
               try:
                   return self._obj.__file__
               except AttributeError:
                   return None
       
    1:     def py__doc__(self):
               return force_unicode(inspect.getdoc(self._obj)) or u''
       
    1:     def py__name__(self):
               if not _is_class_instance(self._obj) or \
                       inspect.ismethoddescriptor(self._obj):  # slots
                   cls = self._obj
               else:
                   try:
                       cls = self._obj.__class__
                   except AttributeError:
                       # happens with numpy.core.umath._UFUNC_API (you get it
                       # automatically by doing `import numpy`.
                       return None
       
               try:
                   return force_unicode(cls.__name__)
               except AttributeError:
                   return None
       
    1:     def py__mro__accesses(self):
               return tuple(self._create_access_path(cls) for cls in self._obj.__mro__[1:])
       
    1:     def py__getitem__all_values(self):
               if isinstance(self._obj, dict):
                   return [self._create_access_path(v) for v in self._obj.values()]
               return self.py__iter__list()
       
    1:     def py__simple_getitem__(self, index):
               if type(self._obj) not in ALLOWED_GETITEM_TYPES:
                   # Get rid of side effects, we won't call custom `__getitem__`s.
                   return None
       
               return self._create_access_path(self._obj[index])
       
    1:     def py__iter__list(self):
               if not hasattr(self._obj, '__getitem__'):
                   return None
       
               if type(self._obj) not in ALLOWED_GETITEM_TYPES:
                   # Get rid of side effects, we won't call custom `__getitem__`s.
                   return []
       
               lst = []
               for i, part in enumerate(self._obj):
                   if i > 20:
                       # Should not go crazy with large iterators
                       break
                   lst.append(self._create_access_path(part))
               return lst
       
    1:     def py__class__(self):
               return self._create_access_path(self._obj.__class__)
       
    1:     def py__bases__(self):
               return [self._create_access_path(base) for base in self._obj.__bases__]
       
    1:     def py__path__(self):
               return self._obj.__path__
       
    1:     @_force_unicode_decorator
           def get_repr(self):
               builtins = 'builtins', '__builtin__'
       
               if inspect.ismodule(self._obj):
                   return repr(self._obj)
               # Try to avoid execution of the property.
               if safe_getattr(self._obj, '__module__', default='') in builtins:
                   return repr(self._obj)
       
               type_ = type(self._obj)
               if type_ == type:
                   return type.__repr__(self._obj)
       
               if safe_getattr(type_, '__module__', default='') in builtins:
                   # Allow direct execution of repr for builtins.
                   return repr(self._obj)
               return object.__repr__(self._obj)
       
    1:     def is_class(self):
               return inspect.isclass(self._obj)
       
    1:     def is_module(self):
               return inspect.ismodule(self._obj)
       
    1:     def is_instance(self):
               return _is_class_instance(self._obj)
       
    1:     def ismethoddescriptor(self):
               return inspect.ismethoddescriptor(self._obj)
       
    1:     def get_qualified_names(self):
               def try_to_get_name(obj):
                   return getattr(obj, '__qualname__', getattr(obj, '__name__', None))
       
               if self.is_module():
                   return ()
               name = try_to_get_name(self._obj)
               if name is None:
                   name = try_to_get_name(type(self._obj))
                   if name is None:
                       return ()
               return tuple(name.split('.'))
       
    1:     def dir(self):
               return list(map(force_unicode, dir(self._obj)))
       
    1:     def has_iter(self):
               try:
                   iter(self._obj)
                   return True
               except TypeError:
                   return False
       
    1:     def is_allowed_getattr(self, name):
               # TODO this API is ugly.
               try:
                   attr, is_get_descriptor = getattr_static(self._obj, name)
               except AttributeError:
                   return False, False
               else:
                   if is_get_descriptor and type(attr) not in ALLOWED_DESCRIPTOR_ACCESS:
                       # In case of descriptors that have get methods we cannot return
                       # it's value, because that would mean code execution.
                       return True, True
               return True, False
       
    1:     def getattr_paths(self, name, default=_sentinel):
               try:
                   return_obj = getattr(self._obj, name)
               except Exception as e:
                   if default is _sentinel:
                       if isinstance(e, AttributeError):
                           # Happens e.g. in properties of
                           # PyQt4.QtGui.QStyleOptionComboBox.currentText
                           # -> just set it to None
                           raise
                       # Just in case anything happens, return an AttributeError. It
                       # should not crash.
                       raise AttributeError
                   return_obj = default
               access = self._create_access(return_obj)
               if inspect.ismodule(return_obj):
                   return [access]
       
               module = inspect.getmodule(return_obj)
               if module is None:
                   module = inspect.getmodule(type(return_obj))
                   if module is None:
                       module = builtins
               return [self._create_access(module), access]
       
    1:     def get_safe_value(self):
               if type(self._obj) in (bool, bytes, float, int, str, unicode, slice):
                   return self._obj
               raise ValueError("Object is type %s and not simple" % type(self._obj))
       
    1:     def get_api_type(self):
               return get_api_type(self._obj)
       
    1:     def get_access_path_tuples(self):
               accesses = [create_access(self._evaluator, o) for o in self._get_objects_path()]
               return [(access.py__name__(), access) for access in accesses]
       
    1:     def _get_objects_path(self):
               def get():
                   obj = self._obj
                   yield obj
                   try:
                       obj = obj.__objclass__
                   except AttributeError:
                       pass
                   else:
                       yield obj
       
                   try:
                       # Returns a dotted string path.
                       imp_plz = obj.__module__
                   except AttributeError:
                       # Unfortunately in some cases like `int` there's no __module__
                       if not inspect.ismodule(obj):
                           yield builtins
                   else:
                       if imp_plz is None:
                           # Happens for example in `(_ for _ in []).send.__module__`.
                           yield builtins
                       else:
                           try:
                               yield sys.modules[imp_plz]
                           except KeyError:
                               # __module__ can be something arbitrary that doesn't exist.
                               yield builtins
       
               return list(reversed(list(get())))
       
    1:     def execute_operation(self, other_access_handle, operator):
               other_access = other_access_handle.access
               op = _OPERATORS[operator]
               return self._create_access_path(op(self._obj, other_access._obj))
       
    1:     def needs_type_completions(self):
               return inspect.isclass(self._obj) and self._obj != type
       
    1:     def get_signature_params(self):
               return [
                   SignatureParam(
                       name=p.name,
                       has_default=p.default is not p.empty,
                       default=self._create_access_path(p.default),
                       default_string=repr(p.default),
                       has_annotation=p.annotation is not p.empty,
                       annotation=self._create_access_path(p.annotation),
                       annotation_string=str(p.default),
                       kind_name=str(p.kind)
                   ) for p in self._get_signature().parameters.values()
               ]
       
    1:     def _get_signature(self):
               obj = self._obj
               if py_version < 33:
                   raise ValueError("inspect.signature was introduced in 3.3")
               if py_version == 34:
                   # In 3.4 inspect.signature are wrong for str and int. This has
                   # been fixed in 3.5. The signature of object is returned,
                   # because no signature was found for str. Here we imitate 3.5
                   # logic and just ignore the signature if the magic methods
                   # don't match object.
                   # 3.3 doesn't even have the logic and returns nothing for str
                   # and classes that inherit from object.
                   user_def = inspect._signature_get_user_defined_method
                   if (inspect.isclass(obj)
                           and not user_def(type(obj), '__init__')
                           and not user_def(type(obj), '__new__')
                           and (obj.__init__ != object.__init__
                                or obj.__new__ != object.__new__)):
                       raise ValueError
       
               try:
                   return inspect.signature(obj)
               except (RuntimeError, TypeError):
                   # Reading the code of the function in Python 3.6 implies there are
                   # at least these errors that might occur if something is wrong with
                   # the signature. In that case we just want a simple escape for now.
                   raise ValueError
       
    1:     def get_return_annotation(self):
               try:
                   o = self._obj.__annotations__.get('return')
               except AttributeError:
                   return None
       
               if o is None:
                   return None
       
               return self._create_access_path(o)
       
    1:     def negate(self):
               return self._create_access_path(-self._obj)
       
    1:     def get_dir_infos(self):
               """
               Used to return a couple of infos that are needed when accessing the sub
               objects of an objects
               """
               # TODO is_allowed_getattr might raise an AttributeError
               tuples = dict(
                   (force_unicode(name), self.is_allowed_getattr(name))
                   for name in self.dir()
               )
               return self.needs_type_completions(), tuples
       
       
    1: def _is_class_instance(obj):
           """Like inspect.* methods."""
           try:
               cls = obj.__class__
           except AttributeError:
               return False
           else:
               return cls != type and not issubclass(cls, NOT_CLASS_TYPES)
