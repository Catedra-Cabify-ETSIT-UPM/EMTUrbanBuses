       # -*- coding: utf-8 -*-
       """
           jinja2.asyncsupport
           ~~~~~~~~~~~~~~~~~~~
       
           Has all the code for async support which is implemented as a patch
           for supported Python versions.
       
           :copyright: (c) 2017 by the Jinja Team.
           :license: BSD, see LICENSE for more details.
    1: """
    1: import sys
    1: import asyncio
    1: import inspect
    1: from functools import update_wrapper
       
    1: from jinja2.utils import concat, internalcode, Markup
    1: from jinja2.environment import TemplateModule
    1: from jinja2.runtime import LoopContextBase, _last_iteration
       
       
    1: async def concat_async(async_gen):
           rv = []
           async def collect():
               async for event in async_gen:
                   rv.append(event)
           await collect()
           return concat(rv)
       
       
    1: async def generate_async(self, *args, **kwargs):
           vars = dict(*args, **kwargs)
           try:
               async for event in self.root_render_func(self.new_context(vars)):
                   yield event
           except Exception:
               exc_info = sys.exc_info()
           else:
               return
           yield self.environment.handle_exception(exc_info, True)
       
       
    1: def wrap_generate_func(original_generate):
    1:     def _convert_generator(self, loop, args, kwargs):
               async_gen = self.generate_async(*args, **kwargs)
               try:
                   while 1:
                       yield loop.run_until_complete(async_gen.__anext__())
               except StopAsyncIteration:
                   pass
    1:     def generate(self, *args, **kwargs):
               if not self.environment.is_async:
                   return original_generate(self, *args, **kwargs)
               return _convert_generator(self, asyncio.get_event_loop(), args, kwargs)
    1:     return update_wrapper(generate, original_generate)
       
       
    1: async def render_async(self, *args, **kwargs):
           if not self.environment.is_async:
               raise RuntimeError('The environment was not created with async mode '
                                  'enabled.')
       
           vars = dict(*args, **kwargs)
           ctx = self.new_context(vars)
       
           try:
               return await concat_async(self.root_render_func(ctx))
           except Exception:
               exc_info = sys.exc_info()
           return self.environment.handle_exception(exc_info, True)
       
       
    1: def wrap_render_func(original_render):
    1:     def render(self, *args, **kwargs):
               if not self.environment.is_async:
                   return original_render(self, *args, **kwargs)
               loop = asyncio.get_event_loop()
               return loop.run_until_complete(self.render_async(*args, **kwargs))
    1:     return update_wrapper(render, original_render)
       
       
    1: def wrap_block_reference_call(original_call):
    1:     @internalcode
           async def async_call(self):
               rv = await concat_async(self._stack[self._depth](self._context))
               if self._context.eval_ctx.autoescape:
                   rv = Markup(rv)
               return rv
       
    1:     @internalcode
           def __call__(self):
               if not self._context.environment.is_async:
                   return original_call(self)
               return async_call(self)
       
    1:     return update_wrapper(__call__, original_call)
       
       
    1: def wrap_macro_invoke(original_invoke):
    1:     @internalcode
           async def async_invoke(self, arguments, autoescape):
               rv = await self._func(*arguments)
               if autoescape:
                   rv = Markup(rv)
               return rv
       
    1:     @internalcode
           def _invoke(self, arguments, autoescape):
               if not self._environment.is_async:
                   return original_invoke(self, arguments, autoescape)
               return async_invoke(self, arguments, autoescape)
    1:     return update_wrapper(_invoke, original_invoke)
       
       
    1: @internalcode
       async def get_default_module_async(self):
           if self._module is not None:
               return self._module
           self._module = rv = await self.make_module_async()
           return rv
       
       
    1: def wrap_default_module(original_default_module):
    1:     @internalcode
           def _get_default_module(self):
               if self.environment.is_async:
                   raise RuntimeError('Template module attribute is unavailable '
                                      'in async mode')
               return original_default_module(self)
    1:     return _get_default_module
       
       
    1: async def make_module_async(self, vars=None, shared=False, locals=None):
           context = self.new_context(vars, shared, locals)
           body_stream = []
           async for item in self.root_render_func(context):
               body_stream.append(item)
           return TemplateModule(self, context, body_stream)
       
       
    1: def patch_template():
    1:     from jinja2 import Template
    1:     Template.generate = wrap_generate_func(Template.generate)
    1:     Template.generate_async = update_wrapper(
    1:         generate_async, Template.generate_async)
    1:     Template.render_async = update_wrapper(
    1:         render_async, Template.render_async)
    1:     Template.render = wrap_render_func(Template.render)
    1:     Template._get_default_module = wrap_default_module(
    1:         Template._get_default_module)
    1:     Template._get_default_module_async = get_default_module_async
    1:     Template.make_module_async = update_wrapper(
    1:         make_module_async, Template.make_module_async)
       
       
    1: def patch_runtime():
    1:     from jinja2.runtime import BlockReference, Macro
    1:     BlockReference.__call__ = wrap_block_reference_call(
    1:         BlockReference.__call__)
    1:     Macro._invoke = wrap_macro_invoke(Macro._invoke)
       
       
    1: def patch_filters():
    1:     from jinja2.filters import FILTERS
    1:     from jinja2.asyncfilters import ASYNC_FILTERS
    1:     FILTERS.update(ASYNC_FILTERS)
       
       
    1: def patch_all():
    1:     patch_template()
    1:     patch_runtime()
    1:     patch_filters()
       
       
    1: async def auto_await(value):
           if inspect.isawaitable(value):
               return await value
           return value
       
       
    1: async def auto_aiter(iterable):
           if hasattr(iterable, '__aiter__'):
               async for item in iterable:
                   yield item
               return
           for item in iterable:
               yield item
       
       
    2: class AsyncLoopContext(LoopContextBase):
       
           def __init__(self, async_iterator, undefined, after, length, recurse=None,
    1:                  depth0=0):
               LoopContextBase.__init__(self, undefined, recurse, depth0)
               self._async_iterator = async_iterator
               self._after = after
               self._length = length
       
    1:     @property
           def length(self):
               if self._length is None:
                   raise TypeError('Loop length for some iterators cannot be '
                                   'lazily calculated in async mode')
               return self._length
       
    1:     def __aiter__(self):
               return AsyncLoopContextIterator(self)
       
       
    2: class AsyncLoopContextIterator(object):
    1:     __slots__ = ('context',)
       
    1:     def __init__(self, context):
               self.context = context
       
    1:     def __aiter__(self):
               return self
       
    1:     async def __anext__(self):
               ctx = self.context
               ctx.index0 += 1
               if ctx._after is _last_iteration:
                   raise StopAsyncIteration()
               ctx._before = ctx._current
               ctx._current = ctx._after
               try:
                   ctx._after = await ctx._async_iterator.__anext__()
               except StopAsyncIteration:
                   ctx._after = _last_iteration
               return ctx._current, ctx
       
       
    1: async def make_async_loop_context(iterable, undefined, recurse=None, depth0=0):
           # Length is more complicated and less efficient in async mode.  The
           # reason for this is that we cannot know if length will be used
           # upfront but because length is a property we cannot lazily execute it
           # later.  This means that we need to buffer it up and measure :(
           #
           # We however only do this for actual iterators, not for async
           # iterators as blocking here does not seem like the best idea in the
           # world.
           try:
               length = len(iterable)
           except (TypeError, AttributeError):
               if not hasattr(iterable, '__aiter__'):
                   iterable = tuple(iterable)
                   length = len(iterable)
               else:
                   length = None
           async_iterator = auto_aiter(iterable)
           try:
               after = await async_iterator.__anext__()
           except StopAsyncIteration:
               after = _last_iteration
           return AsyncLoopContext(async_iterator, undefined, after, length, recurse,
                                   depth0)
