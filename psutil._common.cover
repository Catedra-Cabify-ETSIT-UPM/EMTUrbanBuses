       # Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.
       # Use of this source code is governed by a BSD-style license that can be
       # found in the LICENSE file.
       
    1: """Common objects shared by __init__.py and _ps*.py modules."""
       
       # Note: this module is imported by setup.py so it should not import
       # psutil or third-party modules.
       
    1: from __future__ import division
       
    1: import contextlib
    1: import errno
    1: import functools
    1: import os
    1: import socket
    1: import stat
    1: import sys
    1: import threading
    1: import warnings
    1: from collections import defaultdict
    1: from collections import namedtuple
    1: from socket import AF_INET
    1: from socket import SOCK_DGRAM
    1: from socket import SOCK_STREAM
    1: try:
    1:     from socket import AF_INET6
       except ImportError:
           AF_INET6 = None
    1: try:
    1:     from socket import AF_UNIX
       except ImportError:
           AF_UNIX = None
       
    1: if sys.version_info >= (3, 4):
    1:     import enum
       else:
           enum = None
       
       # can't take it from _common.py as this script is imported by setup.py
    1: PY3 = sys.version_info[0] == 3
       
       __all__ = [
           # constants
    1:     'FREEBSD', 'BSD', 'LINUX', 'NETBSD', 'OPENBSD', 'MACOS', 'OSX', 'POSIX',
    1:     'SUNOS', 'WINDOWS',
    1:     'ENCODING', 'ENCODING_ERRS', 'AF_INET6',
           # connection constants
    1:     'CONN_CLOSE', 'CONN_CLOSE_WAIT', 'CONN_CLOSING', 'CONN_ESTABLISHED',
    1:     'CONN_FIN_WAIT1', 'CONN_FIN_WAIT2', 'CONN_LAST_ACK', 'CONN_LISTEN',
    1:     'CONN_NONE', 'CONN_SYN_RECV', 'CONN_SYN_SENT', 'CONN_TIME_WAIT',
           # net constants
    1:     'NIC_DUPLEX_FULL', 'NIC_DUPLEX_HALF', 'NIC_DUPLEX_UNKNOWN',
           # process status constants
    1:     'STATUS_DEAD', 'STATUS_DISK_SLEEP', 'STATUS_IDLE', 'STATUS_LOCKED',
    1:     'STATUS_RUNNING', 'STATUS_SLEEPING', 'STATUS_STOPPED', 'STATUS_SUSPENDED',
    1:     'STATUS_TRACING_STOP', 'STATUS_WAITING', 'STATUS_WAKE_KILL',
    1:     'STATUS_WAKING', 'STATUS_ZOMBIE', 'STATUS_PARKED',
           # named tuples
    1:     'pconn', 'pcputimes', 'pctxsw', 'pgids', 'pio', 'pionice', 'popenfile',
    1:     'pthread', 'puids', 'sconn', 'scpustats', 'sdiskio', 'sdiskpart',
    1:     'sdiskusage', 'snetio', 'snicaddr', 'snicstats', 'sswap', 'suser',
           # utility functions
    1:     'conn_tmap', 'deprecated_method', 'isfile_strict', 'memoize',
    1:     'parse_environ_block', 'path_exists_strict', 'usage_percent',
    1:     'supports_ipv6', 'sockfam_to_enum', 'socktype_to_enum', "wrap_numbers",
    1:     'bytes2human',
       ]
       
       
       # ===================================================================
       # --- OS constants
       # ===================================================================
       
       
    1: POSIX = os.name == "posix"
    1: WINDOWS = os.name == "nt"
    1: LINUX = sys.platform.startswith("linux")
    1: MACOS = sys.platform.startswith("darwin")
    1: OSX = MACOS  # deprecated alias
    1: FREEBSD = sys.platform.startswith("freebsd")
    1: OPENBSD = sys.platform.startswith("openbsd")
    1: NETBSD = sys.platform.startswith("netbsd")
    1: BSD = FREEBSD or OPENBSD or NETBSD
    1: SUNOS = sys.platform.startswith(("sunos", "solaris"))
    1: AIX = sys.platform.startswith("aix")
       
       
       # ===================================================================
       # --- API constants
       # ===================================================================
       
       
       # Process.status()
    1: STATUS_RUNNING = "running"
    1: STATUS_SLEEPING = "sleeping"
    1: STATUS_DISK_SLEEP = "disk-sleep"
    1: STATUS_STOPPED = "stopped"
    1: STATUS_TRACING_STOP = "tracing-stop"
    1: STATUS_ZOMBIE = "zombie"
    1: STATUS_DEAD = "dead"
    1: STATUS_WAKE_KILL = "wake-kill"
    1: STATUS_WAKING = "waking"
    1: STATUS_IDLE = "idle"  # Linux, macOS, FreeBSD
    1: STATUS_LOCKED = "locked"  # FreeBSD
    1: STATUS_WAITING = "waiting"  # FreeBSD
    1: STATUS_SUSPENDED = "suspended"  # NetBSD
    1: STATUS_PARKED = "parked"  # Linux
       
       # Process.connections() and psutil.net_connections()
    1: CONN_ESTABLISHED = "ESTABLISHED"
    1: CONN_SYN_SENT = "SYN_SENT"
    1: CONN_SYN_RECV = "SYN_RECV"
    1: CONN_FIN_WAIT1 = "FIN_WAIT1"
    1: CONN_FIN_WAIT2 = "FIN_WAIT2"
    1: CONN_TIME_WAIT = "TIME_WAIT"
    1: CONN_CLOSE = "CLOSE"
    1: CONN_CLOSE_WAIT = "CLOSE_WAIT"
    1: CONN_LAST_ACK = "LAST_ACK"
    1: CONN_LISTEN = "LISTEN"
    1: CONN_CLOSING = "CLOSING"
    1: CONN_NONE = "NONE"
       
       # net_if_stats()
    1: if enum is None:
           NIC_DUPLEX_FULL = 2
           NIC_DUPLEX_HALF = 1
           NIC_DUPLEX_UNKNOWN = 0
       else:
    2:     class NicDuplex(enum.IntEnum):
    1:         NIC_DUPLEX_FULL = 2
    1:         NIC_DUPLEX_HALF = 1
    1:         NIC_DUPLEX_UNKNOWN = 0
       
    1:     globals().update(NicDuplex.__members__)
       
       # sensors_battery()
    1: if enum is None:
           POWER_TIME_UNKNOWN = -1
           POWER_TIME_UNLIMITED = -2
       else:
    2:     class BatteryTime(enum.IntEnum):
    1:         POWER_TIME_UNKNOWN = -1
    1:         POWER_TIME_UNLIMITED = -2
       
    1:     globals().update(BatteryTime.__members__)
       
       # --- others
       
    1: ENCODING = sys.getfilesystemencoding()
    1: if not PY3:
           ENCODING_ERRS = "replace"
       else:
    1:     try:
    1:         ENCODING_ERRS = sys.getfilesystemencodeerrors()  # py 3.6
           except AttributeError:
               ENCODING_ERRS = "surrogateescape" if POSIX else "replace"
       
       
       # ===================================================================
       # --- namedtuples
       # ===================================================================
       
       # --- for system functions
       
       # psutil.swap_memory()
    1: sswap = namedtuple('sswap', ['total', 'used', 'free', 'percent', 'sin',
    1:                              'sout'])
       # psutil.disk_usage()
    1: sdiskusage = namedtuple('sdiskusage', ['total', 'used', 'free', 'percent'])
       # psutil.disk_io_counters()
    1: sdiskio = namedtuple('sdiskio', ['read_count', 'write_count',
    1:                                  'read_bytes', 'write_bytes',
    1:                                  'read_time', 'write_time'])
       # psutil.disk_partitions()
    1: sdiskpart = namedtuple('sdiskpart', ['device', 'mountpoint', 'fstype', 'opts'])
       # psutil.net_io_counters()
    1: snetio = namedtuple('snetio', ['bytes_sent', 'bytes_recv',
    1:                                'packets_sent', 'packets_recv',
    1:                                'errin', 'errout',
    1:                                'dropin', 'dropout'])
       # psutil.users()
    1: suser = namedtuple('suser', ['name', 'terminal', 'host', 'started', 'pid'])
       # psutil.net_connections()
    1: sconn = namedtuple('sconn', ['fd', 'family', 'type', 'laddr', 'raddr',
    1:                              'status', 'pid'])
       # psutil.net_if_addrs()
    1: snicaddr = namedtuple('snicaddr',
    1:                       ['family', 'address', 'netmask', 'broadcast', 'ptp'])
       # psutil.net_if_stats()
    1: snicstats = namedtuple('snicstats', ['isup', 'duplex', 'speed', 'mtu'])
       # psutil.cpu_stats()
    1: scpustats = namedtuple(
    1:     'scpustats', ['ctx_switches', 'interrupts', 'soft_interrupts', 'syscalls'])
       # psutil.cpu_freq()
    1: scpufreq = namedtuple('scpufreq', ['current', 'min', 'max'])
       # psutil.sensors_temperatures()
    1: shwtemp = namedtuple(
    1:     'shwtemp', ['label', 'current', 'high', 'critical'])
       # psutil.sensors_battery()
    1: sbattery = namedtuple('sbattery', ['percent', 'secsleft', 'power_plugged'])
       # psutil.sensors_fans()
    1: sfan = namedtuple('sfan', ['label', 'current'])
       
       # --- for Process methods
       
       # psutil.Process.cpu_times()
    1: pcputimes = namedtuple('pcputimes',
    1:                        ['user', 'system', 'children_user', 'children_system'])
       # psutil.Process.open_files()
    1: popenfile = namedtuple('popenfile', ['path', 'fd'])
       # psutil.Process.threads()
    1: pthread = namedtuple('pthread', ['id', 'user_time', 'system_time'])
       # psutil.Process.uids()
    1: puids = namedtuple('puids', ['real', 'effective', 'saved'])
       # psutil.Process.gids()
    1: pgids = namedtuple('pgids', ['real', 'effective', 'saved'])
       # psutil.Process.io_counters()
    1: pio = namedtuple('pio', ['read_count', 'write_count',
    1:                          'read_bytes', 'write_bytes'])
       # psutil.Process.ionice()
    1: pionice = namedtuple('pionice', ['ioclass', 'value'])
       # psutil.Process.ctx_switches()
    1: pctxsw = namedtuple('pctxsw', ['voluntary', 'involuntary'])
       # psutil.Process.connections()
    1: pconn = namedtuple('pconn', ['fd', 'family', 'type', 'laddr', 'raddr',
    1:                              'status'])
       
       # psutil.connections() and psutil.Process.connections()
    1: addr = namedtuple('addr', ['ip', 'port'])
       
       
       # ===================================================================
       # --- Process.connections() 'kind' parameter mapping
       # ===================================================================
       
       
       conn_tmap = {
    1:     "all": ([AF_INET, AF_INET6, AF_UNIX], [SOCK_STREAM, SOCK_DGRAM]),
    1:     "tcp": ([AF_INET, AF_INET6], [SOCK_STREAM]),
    1:     "tcp4": ([AF_INET], [SOCK_STREAM]),
    1:     "udp": ([AF_INET, AF_INET6], [SOCK_DGRAM]),
    1:     "udp4": ([AF_INET], [SOCK_DGRAM]),
    1:     "inet": ([AF_INET, AF_INET6], [SOCK_STREAM, SOCK_DGRAM]),
    1:     "inet4": ([AF_INET], [SOCK_STREAM, SOCK_DGRAM]),
    1:     "inet6": ([AF_INET6], [SOCK_STREAM, SOCK_DGRAM]),
       }
       
    1: if AF_INET6 is not None:
    1:     conn_tmap.update({
    1:         "tcp6": ([AF_INET6], [SOCK_STREAM]),
    1:         "udp6": ([AF_INET6], [SOCK_DGRAM]),
           })
       
    1: if AF_UNIX is not None:
    1:     conn_tmap.update({
    1:         "unix": ([AF_UNIX], [SOCK_STREAM, SOCK_DGRAM]),
           })
       
    1: del AF_INET, AF_UNIX, SOCK_STREAM, SOCK_DGRAM
       
       
       # ===================================================================
       # --- utils
       # ===================================================================
       
       
    1: def usage_percent(used, total, round_=None):
           """Calculate percentage usage of 'used' against 'total'."""
           try:
               ret = (used / total) * 100
           except ZeroDivisionError:
               ret = 0.0 if isinstance(used, float) or isinstance(total, float) else 0
           if round_ is not None:
               return round(ret, round_)
           else:
               return ret
       
       
    1: def memoize(fun):
           """A simple memoize decorator for functions supporting (hashable)
           positional arguments.
           It also provides a cache_clear() function for clearing the cache:
       
           >>> @memoize
           ... def foo()
           ...     return 1
               ...
           >>> foo()
           1
           >>> foo.cache_clear()
           >>>
           """
    3:     @functools.wraps(fun)
           def wrapper(*args, **kwargs):
    3:         key = (args, frozenset(sorted(kwargs.items())))
    3:         try:
    3:             return cache[key]
    1:         except KeyError:
    1:             ret = cache[key] = fun(*args, **kwargs)
    1:             return ret
       
    3:     def cache_clear():
               """Clear cache."""
               cache.clear()
       
    3:     cache = {}
    3:     wrapper.cache_clear = cache_clear
    3:     return wrapper
       
       
    1: def memoize_when_activated(fun):
           """A memoize decorator which is disabled by default. It can be
           activated and deactivated on request.
           For efficiency reasons it can be used only against class methods
           accepting no arguments.
       
           >>> class Foo:
           ...     @memoize
           ...     def foo()
           ...         print(1)
           ...
           >>> f = Foo()
           >>> # deactivated (default)
           >>> foo()
           1
           >>> foo()
           1
           >>>
           >>> # activated
           >>> foo.cache_activate(self)
           >>> foo()
           1
           >>> foo()
           >>> foo()
           >>>
           """
    7:     @functools.wraps(fun)
           def wrapper(self):
               try:
                   # case 1: we previously entered oneshot() ctx
                   ret = self._cache[fun]
               except AttributeError:
                   # case 2: we never entered oneshot() ctx
                   return fun(self)
               except KeyError:
                   # case 3: we entered oneshot() ctx but there's no cache
                   # for this entry yet
                   ret = self._cache[fun] = fun(self)
               return ret
       
    7:     def cache_activate(proc):
               """Activate cache. Expects a Process instance. Cache will be
               stored as a "_cache" instance attribute."""
               proc._cache = {}
       
    7:     def cache_deactivate(proc):
               """Deactivate and clear cache."""
               try:
                   del proc._cache
               except AttributeError:
                   pass
       
    7:     wrapper.cache_activate = cache_activate
    7:     wrapper.cache_deactivate = cache_deactivate
    7:     return wrapper
       
       
    1: def isfile_strict(path):
           """Same as os.path.isfile() but does not swallow EACCES / EPERM
           exceptions, see:
           http://mail.python.org/pipermail/python-dev/2012-June/120787.html
           """
           try:
               st = os.stat(path)
           except OSError as err:
               if err.errno in (errno.EPERM, errno.EACCES):
                   raise
               return False
           else:
               return stat.S_ISREG(st.st_mode)
       
       
    1: def path_exists_strict(path):
           """Same as os.path.exists() but does not swallow EACCES / EPERM
           exceptions, see:
           http://mail.python.org/pipermail/python-dev/2012-June/120787.html
           """
           try:
               os.stat(path)
           except OSError as err:
               if err.errno in (errno.EPERM, errno.EACCES):
                   raise
               return False
           else:
               return True
       
       
    1: @memoize
       def supports_ipv6():
           """Return True if IPv6 is supported on this platform."""
           if not socket.has_ipv6 or AF_INET6 is None:
               return False
           try:
               sock = socket.socket(AF_INET6, socket.SOCK_STREAM)
               with contextlib.closing(sock):
                   sock.bind(("::1", 0))
               return True
           except socket.error:
               return False
       
       
    1: def parse_environ_block(data):
           """Parse a C environ block of environment variables into a dictionary."""
           # The block is usually raw data from the target process.  It might contain
           # trailing garbage and lines that do not look like assignments.
           ret = {}
           pos = 0
       
           # localize global variable to speed up access.
           WINDOWS_ = WINDOWS
           while True:
               next_pos = data.find("\0", pos)
               # nul byte at the beginning or double nul byte means finish
               if next_pos <= pos:
                   break
               # there might not be an equals sign
               equal_pos = data.find("=", pos, next_pos)
               if equal_pos > pos:
                   key = data[pos:equal_pos]
                   value = data[equal_pos + 1:next_pos]
                   # Windows expects environment variables to be uppercase only
                   if WINDOWS_:
                       key = key.upper()
                   ret[key] = value
               pos = next_pos + 1
       
           return ret
       
       
    1: def sockfam_to_enum(num):
           """Convert a numeric socket family value to an IntEnum member.
           If it's not a known member, return the numeric value itself.
           """
           if enum is None:
               return num
           else:  # pragma: no cover
               try:
                   return socket.AddressFamily(num)
               except (ValueError, AttributeError):
                   return num
       
       
    1: def socktype_to_enum(num):
           """Convert a numeric socket type value to an IntEnum member.
           If it's not a known member, return the numeric value itself.
           """
           if enum is None:
               return num
           else:  # pragma: no cover
               try:
                   return socket.AddressType(num)
               except (ValueError, AttributeError):
                   return num
       
       
    1: def deprecated_method(replacement):
           """A decorator which can be used to mark a method as deprecated
           'replcement' is the method name which will be called instead.
           """
    1:     def outer(fun):
    1:         msg = "%s() is deprecated and will be removed; use %s() instead" % (
    1:             fun.__name__, replacement)
    1:         if fun.__doc__ is None:
    1:             fun.__doc__ = msg
       
    1:         @functools.wraps(fun)
               def inner(self, *args, **kwargs):
                   warnings.warn(msg, category=DeprecationWarning, stacklevel=2)
                   return getattr(self, replacement)(*args, **kwargs)
    1:         return inner
    1:     return outer
       
       
    2: class _WrapNumbers:
           """Watches numbers so that they don't overflow and wrap
           (reset to zero).
    1:     """
       
    1:     def __init__(self):
    1:         self.lock = threading.Lock()
    1:         self.cache = {}
    1:         self.reminders = {}
    1:         self.reminder_keys = {}
       
    1:     def _add_dict(self, input_dict, name):
               assert name not in self.cache
               assert name not in self.reminders
               assert name not in self.reminder_keys
               self.cache[name] = input_dict
               self.reminders[name] = defaultdict(int)
               self.reminder_keys[name] = defaultdict(set)
       
    1:     def _remove_dead_reminders(self, input_dict, name):
               """In case the number of keys changed between calls (e.g. a
               disk disappears) this removes the entry from self.reminders.
               """
               old_dict = self.cache[name]
               gone_keys = set(old_dict.keys()) - set(input_dict.keys())
               for gone_key in gone_keys:
                   for remkey in self.reminder_keys[name][gone_key]:
                       del self.reminders[name][remkey]
                   del self.reminder_keys[name][gone_key]
       
    1:     def run(self, input_dict, name):
               """Cache dict and sum numbers which overflow and wrap.
               Return an updated copy of `input_dict`
               """
               if name not in self.cache:
                   # This was the first call.
                   self._add_dict(input_dict, name)
                   return input_dict
       
               self._remove_dead_reminders(input_dict, name)
       
               old_dict = self.cache[name]
               new_dict = {}
               for key in input_dict.keys():
                   input_tuple = input_dict[key]
                   try:
                       old_tuple = old_dict[key]
                   except KeyError:
                       # The input dict has a new key (e.g. a new disk or NIC)
                       # which didn't exist in the previous call.
                       new_dict[key] = input_tuple
                       continue
       
                   bits = []
                   for i in range(len(input_tuple)):
                       input_value = input_tuple[i]
                       old_value = old_tuple[i]
                       remkey = (key, i)
                       if input_value < old_value:
                           # it wrapped!
                           self.reminders[name][remkey] += old_value
                           self.reminder_keys[name][key].add(remkey)
                       bits.append(input_value + self.reminders[name][remkey])
       
                   new_dict[key] = tuple(bits)
       
               self.cache[name] = input_dict
               return new_dict
       
    1:     def cache_clear(self, name=None):
               """Clear the internal cache, optionally only for function 'name'."""
               with self.lock:
                   if name is None:
                       self.cache.clear()
                       self.reminders.clear()
                       self.reminder_keys.clear()
                   else:
                       self.cache.pop(name, None)
                       self.reminders.pop(name, None)
                       self.reminder_keys.pop(name, None)
       
    1:     def cache_info(self):
               """Return internal cache dicts as a tuple of 3 elements."""
               with self.lock:
                   return (self.cache, self.reminders, self.reminder_keys)
       
       
    1: def wrap_numbers(input_dict, name):
           """Given an `input_dict` and a function `name`, adjust the numbers
           which "wrap" (restart from zero) across different calls by adding
           "old value" to "new value" and return an updated dict.
           """
           with _wn.lock:
               return _wn.run(input_dict, name)
       
       
    1: _wn = _WrapNumbers()
    1: wrap_numbers.cache_clear = _wn.cache_clear
    1: wrap_numbers.cache_info = _wn.cache_info
       
       
    1: def open_binary(fname, **kwargs):
    3:     return open(fname, "rb", **kwargs)
       
       
    1: def open_text(fname, **kwargs):
           """On Python 3 opens a file in text mode by using fs encoding and
           a proper en/decoding errors handler.
           On Python 2 this is just an alias for open(name, 'rt').
           """
           if PY3:
               # See:
               # https://github.com/giampaolo/psutil/issues/675
               # https://github.com/giampaolo/psutil/pull/733
               kwargs.setdefault('encoding', ENCODING)
               kwargs.setdefault('errors', ENCODING_ERRS)
           return open(fname, "rt", **kwargs)
       
       
    1: def bytes2human(n, format="%(value).1f%(symbol)s"):
           """Used by various scripts. See:
           http://goo.gl/zeJZl
       
           >>> bytes2human(10000)
           '9.8K'
           >>> bytes2human(100001221)
           '95.4M'
           """
           symbols = ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
           prefix = {}
           for i, s in enumerate(symbols[1:]):
               prefix[s] = 1 << (i + 1) * 10
           for symbol in reversed(symbols[1:]):
               if n >= prefix[symbol]:
                   value = float(n) / prefix[symbol]
                   return format % locals()
           return format % dict(symbol=symbols[0], value=n)
       
       
    1: def get_procfs_path():
           """Return updated psutil.PROCFS_PATH constant."""
    2:     return sys.modules['psutil'].PROCFS_PATH
       
       
    1: if PY3:
    1:     def decode(s):
               return s.decode(encoding=ENCODING, errors=ENCODING_ERRS)
       else:
           def decode(s):
               return s
