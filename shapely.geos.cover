       """
       Proxies for libgeos, GEOS-specific exceptions, and utilities
    1: """
       
    1: import atexit
    1: from ctypes import (
           CDLL, cdll, pointer, string_at, DEFAULT_MODE, c_void_p, c_size_t, c_char_p)
    1: from ctypes.util import find_library
    1: import glob
    1: import logging
    1: import os
    1: import re
    1: import sys
    1: import threading
    1: from functools import partial
       
    1: from .ctypes_declarations import prototype, EXCEPTION_HANDLER_FUNCTYPE
    1: from .errors import WKBReadingError, WKTReadingError, TopologicalError, PredicateError
       
       
       # Add message handler to this module's logger
    1: LOG = logging.getLogger(__name__)
       
    1: if sys.version_info[0] >= 3:
    1:     text_types = str
       else:
           text_types = (str, unicode)
       
       
       # Find and load the GEOS and C libraries
       # If this ever gets any longer, we'll break it into separate modules
       
    1: def load_dll(libname, fallbacks=None, mode=DEFAULT_MODE):
    1:     lib = find_library(libname)
    1:     dll = None
    1:     if lib is not None:
    1:         try:
    1:             LOG.debug("Trying `CDLL(%s)`", lib)
    1:             dll = CDLL(lib, mode=mode)
               except OSError:
                   LOG.debug("Failed `CDLL(%s)`", lib)
                   pass
       
    1:     if not dll and fallbacks is not None:
               for name in fallbacks:
                   try:
                       LOG.debug("Trying `CDLL(%s)`", name)
                       dll = CDLL(name, mode=mode)
                   except OSError:
                       # move on to the next fallback
                       LOG.debug("Failed `CDLL(%s)`", name)
                       pass
       
    1:     if dll:
    1:         LOG.debug("Library path: %r", lib or name)
    1:         LOG.debug("DLL: %r", dll)
    1:         return dll
           else:
               # No shared library was loaded. Raise OSError.
               raise OSError(
                   "Could not find lib {} or load any of its variants {}.".format(
                       libname, fallbacks or []))
       
    1: _lgeos = None
       
    1: if sys.platform.startswith('linux'):
           # Test to see if we have a wheel repaired by 'auditwheel' containing its
           # own libgeos_c
    1:     geos_whl_so = glob.glob(os.path.abspath(os.path.join(os.path.dirname(
    1:         __file__), '.libs/libgeos_c-*.so.*')))
    1:     if len(geos_whl_so) == 1:
    1:         _lgeos = CDLL(geos_whl_so[0])
    1:         LOG.debug("Found GEOS DLL: %r, using it.", _lgeos)
           elif hasattr(sys, 'frozen'):
               geos_pyinstaller_so = glob.glob(os.path.join(sys.prefix, 'libgeos_c-*.so.*'))
               if len(geos_pyinstaller_so) == 1:
                   _lgeos = CDLL(geos_pyinstaller_so[0])
                   LOG.debug("Found GEOS DLL: %r, using it.", _lgeos)
           elif os.getenv('CONDA_PREFIX', ''):
               # conda package.
               _lgeos = CDLL(os.path.join(sys.prefix, 'lib', 'libgeos_c.so'))
           else:
               alt_paths = [
                   'libgeos_c.so.1',
                   'libgeos_c.so',
               ]
               _lgeos = load_dll('geos_c', fallbacks=alt_paths)
           # Necessary for environments with only libc.musl
           c_alt_paths = [
    1:         'libc.musl-x86_64.so.1'
           ]
    1:     free = load_dll('c', fallbacks=c_alt_paths).free
    1:     free.argtypes = [c_void_p]
    1:     free.restype = None
       
       elif sys.platform == 'darwin':
           # Test to see if we have a delocated wheel with a GEOS dylib.
           geos_whl_dylib = os.path.abspath(os.path.join(os.path.dirname(
               __file__), '.dylibs/libgeos_c.1.dylib'))
       
           if os.path.exists(geos_whl_dylib):
               handle = CDLL(None)
               if hasattr(handle, "initGEOS_r"):
                   LOG.debug("GEOS already loaded")
                   _lgeos = handle
               else:
                   _lgeos = CDLL(geos_whl_dylib)
                   LOG.debug("Found GEOS DLL: %r, using it.", _lgeos)
       
           elif os.getenv('CONDA_PREFIX', ''):
               # conda package.
               _lgeos = CDLL(os.path.join(sys.prefix, 'lib', 'libgeos_c.dylib'))
           else:
               if hasattr(sys, 'frozen'):
                   try:
                       # .app file from py2app
                       alt_paths = [os.path.join(
                           os.environ['RESOURCEPATH'], '..', 'Frameworks',
                           'libgeos_c.dylib')]
                   except KeyError:
                       # binary from pyinstaller
                       alt_paths = [
                           os.path.join(sys.executable, 'libgeos_c.dylib')]
                       if hasattr(sys, '_MEIPASS'):
                           alt_paths.append(
                               os.path.join(sys._MEIPASS, 'libgeos_c.1.dylib'))
               else:
                   alt_paths = [
                       # The Framework build from Kyng Chaos
                       "/Library/Frameworks/GEOS.framework/Versions/Current/GEOS",
                       # macports
                       '/opt/local/lib/libgeos_c.dylib',
                       # homebrew
                       '/usr/local/lib/libgeos_c.dylib',
                   ]
               _lgeos = load_dll('geos_c', fallbacks=alt_paths)
       
           free = load_dll('c').free
           free.argtypes = [c_void_p]
           free.restype = None
       
       elif sys.platform == 'win32':
           if os.getenv('CONDA_PREFIX', ''):
               # conda package.
               _lgeos = CDLL(os.path.join(sys.prefix, 'Library', 'bin', 'geos_c.dll'))
           else:
               try:
                   egg_dlls = os.path.abspath(
                       os.path.join(os.path.dirname(__file__), 'DLLs'))
                   if hasattr(sys, '_MEIPASS'):
                       wininst_dlls = sys._MEIPASS
                   elif hasattr(sys, "frozen"):
                       wininst_dlls = os.path.normpath(
                           os.path.abspath(sys.executable + '../../DLLS'))
                   else:
                       wininst_dlls = os.path.abspath(os.__file__ + "../../../DLLs")
                   original_path = os.environ['PATH']
                   os.environ['PATH'] = "%s;%s;%s" % \
                       (egg_dlls, wininst_dlls, original_path)
                   _lgeos = load_dll("geos_c.dll")
               except (ImportError, WindowsError, OSError):
                   raise
       
               def free(m):
                   try:
                       cdll.msvcrt.free(m)
                   except WindowsError:
                       # XXX: See http://trac.gispython.org/projects/PCL/ticket/149
                       pass
       
       elif sys.platform == 'sunos5':
           _lgeos = load_dll('geos_c', fallbacks=['libgeos_c.so.1', 'libgeos_c.so'])
           free = CDLL('libc.so.1').free
           free.argtypes = [c_void_p]
           free.restype = None
       else:  # other *nix systems
           _lgeos = load_dll('geos_c', fallbacks=['libgeos_c.so.1', 'libgeos_c.so'])
           free = load_dll('c', fallbacks=['libc.so.6']).free
           free.argtypes = [c_void_p]
           free.restype = None
       
       
    1: def _geos_version():
    1:     GEOSversion = _lgeos.GEOSversion
    1:     GEOSversion.restype = c_char_p
    1:     GEOSversion.argtypes = []
    1:     geos_version_string = GEOSversion()
    1:     if sys.version_info[0] >= 3:
    1:         geos_version_string = geos_version_string.decode('ascii')
    1:     res = re.findall(r'(\d+)\.(\d+)\.(\d+)', geos_version_string)
    1:     assert len(res) == 2, res
    5:     geos_version = tuple(int(x) for x in res[0])
    5:     capi_version = tuple(int(x) for x in res[1])
    1:     return geos_version_string, geos_version, capi_version
       
    1: geos_version_string, geos_version, geos_capi_version = _geos_version()
       
       
       # If we have the new interface, then record a baseline so that we know what
       # additional functions are declared in ctypes_declarations.
    1: if geos_version >= (3, 1, 0):
    1:     start_set = set(_lgeos.__dict__)
       
       # Apply prototypes for the libgeos_c functions
    1: prototype(_lgeos, geos_version)
       
       # If we have the new interface, automatically detect all function
       # declarations, and declare their re-entrant counterpart.
    1: if geos_version >= (3, 1, 0):
    1:     end_set = set(_lgeos.__dict__)
    1:     new_func_names = end_set - start_set
       
  144:     for func_name in new_func_names:
  143:         new_func_name = "%s_r" % func_name
  143:         if hasattr(_lgeos, new_func_name):
  141:             new_func = getattr(_lgeos, new_func_name)
  141:             old_func = getattr(_lgeos, func_name)
  141:             new_func.restype = old_func.restype
  141:             if old_func.argtypes is None:
                       # Handle functions that didn't take an argument before,
                       # finishGEOS.
    1:                 new_func.argtypes = [c_void_p]
                   else:
  140:                 new_func.argtypes = [c_void_p] + old_func.argtypes
  141:             if old_func.errcheck is not None:
                       new_func.errcheck = old_func.errcheck
       
           # Handle special case.
    1:     _lgeos.initGEOS_r.restype = c_void_p
           _lgeos.initGEOS_r.argtypes = \
    1:         [EXCEPTION_HANDLER_FUNCTYPE, EXCEPTION_HANDLER_FUNCTYPE]
    1:     _lgeos.finishGEOS_r.argtypes = [c_void_p]
       
       
    1: def make_logging_callback(func):
           """Error or notice handler callback producr
       
           Wraps a logger method, func, as a GEOS callback.
           """
    2:     def callback(fmt, *fmt_args):
               fmt = fmt.decode('ascii')
               conversions = re.findall(r'%.', fmt)
               args = [
                   string_at(arg).decode('ascii')
                   for spec, arg in zip(conversions, fmt_args)
                   if spec == '%s' and arg is not None]
       
               func(fmt, *args)
       
    2:     return callback
       
    1: error_handler = make_logging_callback(LOG.error)
    1: notice_handler = make_logging_callback(LOG.info)
       
    1: error_h = EXCEPTION_HANDLER_FUNCTYPE(error_handler)
    1: notice_h = EXCEPTION_HANDLER_FUNCTYPE(notice_handler)
       
       
    2: class WKTReader(object):
       
    1:     _lgeos = None
    1:     _reader = None
       
    1:     def __init__(self, lgeos):
               """Create WKT Reader"""
               self._lgeos = lgeos
               self._reader = self._lgeos.GEOSWKTReader_create()
       
    1:     def __del__(self):
               """Destroy WKT Reader"""
               if self._lgeos is not None:
                   self._lgeos.GEOSWKTReader_destroy(self._reader)
                   self._reader = None
                   self._lgeos = None
       
    1:     def read(self, text):
               """Returns geometry from WKT"""
               if not isinstance(text, text_types):
                   raise TypeError("Only str is accepted.")
               if sys.version_info[0] >= 3:
                   text = text.encode()
               c_string = c_char_p(text)
               geom = self._lgeos.GEOSWKTReader_read(self._reader, c_string)
               if not geom:
                   raise WKTReadingError(
                       "Could not create geometry because of errors "
                       "while reading input.")
               # avoid circular import dependency
               from shapely.geometry.base import geom_factory
               return geom_factory(geom)
       
       
    2: class WKTWriter(object):
       
    1:     _lgeos = None
    1:     _writer = None
       
           # Establish default output settings
    1:     defaults = {}
       
    1:     if geos_version >= (3, 3, 0):
       
    1:         defaults['trim'] = True
    1:         defaults['output_dimension'] = 3
       
               # GEOS' defaults for methods without "get"
    1:         _trim = False
    1:         _rounding_precision = -1
    1:         _old_3d = False
       
    1:         @property
               def trim(self):
                   """Trimming of unnecessary decimals (default: True)"""
                   return getattr(self, '_trim')
       
    1:         @trim.setter
               def trim(self, value):
                   self._trim = bool(value)
                   self._lgeos.GEOSWKTWriter_setTrim(self._writer, self._trim)
       
    1:         @property
               def rounding_precision(self):
                   """Rounding precision when writing the WKT.
                   A precision of -1 (default) disables it."""
                   return getattr(self, '_rounding_precision')
       
    1:         @rounding_precision.setter
               def rounding_precision(self, value):
                   self._rounding_precision = int(value)
                   self._lgeos.GEOSWKTWriter_setRoundingPrecision(
                       self._writer, self._rounding_precision)
       
    1:         @property
               def output_dimension(self):
                   """Output dimension, either 2 or 3 (default)"""
                   return self._lgeos.GEOSWKTWriter_getOutputDimension(
                       self._writer)
       
    1:         @output_dimension.setter
               def output_dimension(self, value):
                   self._lgeos.GEOSWKTWriter_setOutputDimension(
                       self._writer, int(value))
       
    1:         @property
               def old_3d(self):
                   """Show older style for 3D WKT, without 'Z' (default: False)"""
                   return getattr(self, '_old_3d')
       
    1:         @old_3d.setter
               def old_3d(self, value):
                   self._old_3d = bool(value)
                   self._lgeos.GEOSWKTWriter_setOld3D(self._writer, self._old_3d)
       
    1:     def __init__(self, lgeos, **settings):
               """Create WKT Writer
       
               Note: writer defaults are set differently for GEOS 3.3.0 and up.
               For example, with 'POINT Z (1 2 3)':
       
                   newer: POINT Z (1 2 3)
                   older: POINT (1.0000000000000000 2.0000000000000000)
       
               The older formatting can be achieved for GEOS 3.3.0 and up by setting
               the properties:
                   trim = False
                   output_dimension = 2
               """
               self._lgeos = lgeos
               self._writer = self._lgeos.GEOSWKTWriter_create()
       
               applied_settings = self.defaults.copy()
               applied_settings.update(settings)
               for name in applied_settings:
                   setattr(self, name, applied_settings[name])
       
    1:     def __setattr__(self, name, value):
               """Limit setting attributes"""
               if hasattr(self, name):
                   object.__setattr__(self, name, value)
               else:
                   raise AttributeError('%r object has no attribute %r' %
                                        (self.__class__.__name__, name))
       
    1:     def __del__(self):
               """Destroy WKT Writer"""
               if self._lgeos is not None:
                   self._lgeos.GEOSWKTWriter_destroy(self._writer)
                   self._writer = None
                   self._lgeos = None
       
    1:     def write(self, geom):
               """Returns WKT string for geometry"""
               if geom is None or geom._geom is None:
                   raise ValueError("Null geometry supports no operations")
               result = self._lgeos.GEOSWKTWriter_write(self._writer, geom._geom)
               text = string_at(result)
               lgeos.GEOSFree(result)
               if sys.version_info[0] >= 3:
                   return text.decode('ascii')
               else:
                   return text
       
       
    2: class WKBReader(object):
       
    1:     _lgeos = None
    1:     _reader = None
       
    1:     def __init__(self, lgeos):
               """Create WKB Reader"""
               self._lgeos = lgeos
               self._reader = self._lgeos.GEOSWKBReader_create()
       
    1:     def __del__(self):
               """Destroy WKB Reader"""
               if self._lgeos is not None:
                   self._lgeos.GEOSWKBReader_destroy(self._reader)
                   self._reader = None
                   self._lgeos = None
       
    1:     def read(self, data):
               """Returns geometry from WKB"""
               geom = self._lgeos.GEOSWKBReader_read(
                   self._reader, c_char_p(data), c_size_t(len(data)))
               if not geom:
                   raise WKBReadingError(
                       "Could not create geometry because of errors "
                       "while reading input.")
               # avoid circular import dependency
               from shapely import geometry
               return geometry.base.geom_factory(geom)
       
    1:     def read_hex(self, data):
               """Returns geometry from WKB hex"""
               if sys.version_info[0] >= 3:
                   data = data.encode('ascii')
               geom = self._lgeos.GEOSWKBReader_readHEX(
                   self._reader, c_char_p(data), c_size_t(len(data)))
               if not geom:
                   raise WKBReadingError(
                       "Could not create geometry because of errors "
                       "while reading input.")
               # avoid circular import dependency
               from shapely import geometry
               return geometry.base.geom_factory(geom)
       
       
    2: class WKBWriter(object):
       
    1:     _lgeos = None
    1:     _writer = None
       
           # EndianType enum in ByteOrderValues.h
    1:     _ENDIAN_BIG = 0
    1:     _ENDIAN_LITTLE = 1
       
           # Establish default output setting
    1:     defaults = {'output_dimension': 3}
       
    1:     @property
           def output_dimension(self):
               """Output dimension, either 2 or 3 (default)"""
               return self._lgeos.GEOSWKBWriter_getOutputDimension(self._writer)
       
    1:     @output_dimension.setter
           def output_dimension(self, value):
               self._lgeos.GEOSWKBWriter_setOutputDimension(
                   self._writer, int(value))
       
    1:     @property
           def big_endian(self):
               """Byte order is big endian, True (default) or False"""
               return (self._lgeos.GEOSWKBWriter_getByteOrder(self._writer) ==
                       self._ENDIAN_BIG)
       
    1:     @big_endian.setter
           def big_endian(self, value):
               self._lgeos.GEOSWKBWriter_setByteOrder(
                   self._writer, self._ENDIAN_BIG if value else self._ENDIAN_LITTLE)
       
    1:     @property
           def include_srid(self):
               """Include SRID, True or False (default)"""
               return bool(self._lgeos.GEOSWKBWriter_getIncludeSRID(self._writer))
       
    1:     @include_srid.setter
           def include_srid(self, value):
               self._lgeos.GEOSWKBWriter_setIncludeSRID(self._writer, bool(value))
       
    1:     def __init__(self, lgeos, **settings):
               """Create WKB Writer"""
               self._lgeos = lgeos
               self._writer = self._lgeos.GEOSWKBWriter_create()
       
               applied_settings = self.defaults.copy()
               applied_settings.update(settings)
               for name in applied_settings:
                   setattr(self, name, applied_settings[name])
       
    1:     def __setattr__(self, name, value):
               """Limit setting attributes"""
               if hasattr(self, name):
                   object.__setattr__(self, name, value)
               else:
                   raise AttributeError('%r object has no attribute %r' %
                                        (self.__class__.__name__, name))
       
    1:     def __del__(self):
               """Destroy WKB Writer"""
               if self._lgeos is not None:
                   self._lgeos.GEOSWKBWriter_destroy(self._writer)
                   self._writer = None
                   self._lgeos = None
       
    1:     def write(self, geom):
               """Returns WKB byte string for geometry"""
               if geom is None or geom._geom is None:
                   raise ValueError("Null geometry supports no operations")
               size = c_size_t()
               result = self._lgeos.GEOSWKBWriter_write(
                   self._writer, geom._geom, pointer(size))
               data = string_at(result, size.value)
               lgeos.GEOSFree(result)
               return data
       
    1:     def write_hex(self, geom):
               """Returns WKB hex string for geometry"""
               if geom is None or geom._geom is None:
                   raise ValueError("Null geometry supports no operations")
               size = c_size_t()
               result = self._lgeos.GEOSWKBWriter_writeHEX(
                   self._writer, geom._geom, pointer(size))
               data = string_at(result, size.value)
               lgeos.GEOSFree(result)
               if sys.version_info[0] >= 3:
                   return data.decode('ascii')
               else:
                   return data
       
       
       # Errcheck functions for ctypes
       
    1: def errcheck_wkb(result, func, argtuple):
           """Returns bytes from a C pointer"""
           if not result:
               return None
           size_ref = argtuple[-1]
           size = size_ref.contents
           retval = string_at(result, size.value)[:]
           lgeos.GEOSFree(result)
           return retval
       
       
    1: def errcheck_just_free(result, func, argtuple):
           """Returns string from a C pointer"""
           retval = string_at(result)
           lgeos.GEOSFree(result)
           if sys.version_info[0] >= 3:
               return retval.decode('ascii')
           else:
               return retval
       
       
    1: def errcheck_null_exception(result, func, argtuple):
           """Wraps errcheck_just_free
       
           Raises TopologicalError if result is NULL.
           """
           if not result:
               raise TopologicalError(
                   "The operation '{}' could not be performed."
                   "Likely cause is invalidity of the geometry.".format(
                       func.__name__))
           return errcheck_just_free(result, func, argtuple)
       
       
    1: def errcheck_predicate(result, func, argtuple):
           """Result is 2 on exception, 1 on True, 0 on False"""
           if result == 2:
               raise PredicateError("Failed to evaluate %s" % repr(func))
           return result
       
       
    2: class LGEOSBase(threading.local):
           """Proxy for GEOS C API
       
           This is a base class. Do not instantiate.
    1:     """
    1:     methods = {}
       
    1:     def __init__(self, dll):
    1:         self._lgeos = dll
    1:         self.geos_handle = None
       
    1:     def __del__(self):
               """Cleanup GEOS related processes"""
               if self._lgeos is not None:
                   self._lgeos.finishGEOS()
                   self._lgeos = None
                   self.geos_handle = None
       
       
    2: class LGEOS300(LGEOSBase):
           """Proxy for GEOS 3.0.0-CAPI-1.4.1
    1:     """
    1:     geos_version = (3, 0, 0)
    1:     geos_capi_version = (1, 4, 0)
       
    1:     def __init__(self, dll):
               super(LGEOS300, self).__init__(dll)
               self.geos_handle = self._lgeos.initGEOS(notice_h, error_h)
               keys = list(self._lgeos.__dict__.keys())
               for key in keys:
                   setattr(self, key, getattr(self._lgeos, key))
               self.GEOSFree = self._lgeos.free
               # Deprecated
               self.GEOSGeomToWKB_buf.errcheck = errcheck_wkb
               self.GEOSGeomToWKT.errcheck = errcheck_just_free
               self.GEOSRelate.errcheck = errcheck_null_exception
               for pred in (
                       self.GEOSDisjoint,
                       self.GEOSTouches,
                       self.GEOSIntersects,
                       self.GEOSCrosses,
                       self.GEOSWithin,
                       self.GEOSContains,
                       self.GEOSOverlaps,
                       self.GEOSEquals,
                       self.GEOSEqualsExact,
                       self.GEOSRelatePattern,
                       self.GEOSisEmpty,
                       self.GEOSisValid,
                       self.GEOSisSimple,
                       self.GEOSisRing,
                       self.GEOSHasZ):
                   pred.errcheck = errcheck_predicate
       
               self.methods['area'] = self.GEOSArea
               self.methods['boundary'] = self.GEOSBoundary
               self.methods['buffer'] = self.GEOSBuffer
               self.methods['centroid'] = self.GEOSGetCentroid
               self.methods['representative_point'] = self.GEOSPointOnSurface
               self.methods['convex_hull'] = self.GEOSConvexHull
               self.methods['distance'] = self.GEOSDistance
               self.methods['envelope'] = self.GEOSEnvelope
               self.methods['length'] = self.GEOSLength
               self.methods['has_z'] = self.GEOSHasZ
               self.methods['is_empty'] = self.GEOSisEmpty
               self.methods['is_ring'] = self.GEOSisRing
               self.methods['is_simple'] = self.GEOSisSimple
               self.methods['is_valid'] = self.GEOSisValid
               self.methods['disjoint'] = self.GEOSDisjoint
               self.methods['touches'] = self.GEOSTouches
               self.methods['intersects'] = self.GEOSIntersects
               self.methods['crosses'] = self.GEOSCrosses
               self.methods['within'] = self.GEOSWithin
               self.methods['contains'] = self.GEOSContains
               self.methods['overlaps'] = self.GEOSOverlaps
               self.methods['equals'] = self.GEOSEquals
               self.methods['equals_exact'] = self.GEOSEqualsExact
               self.methods['relate'] = self.GEOSRelate
               self.methods['difference'] = self.GEOSDifference
               self.methods['symmetric_difference'] = self.GEOSSymDifference
               self.methods['union'] = self.GEOSUnion
               self.methods['intersection'] = self.GEOSIntersection
               self.methods['relate_pattern'] = self.GEOSRelatePattern
               self.methods['simplify'] = self.GEOSSimplify
               self.methods['topology_preserve_simplify'] = \
                   self.GEOSTopologyPreserveSimplify
       
       
    2: class LGEOS310(LGEOSBase):
           """Proxy for GEOS 3.1.0-CAPI-1.5.0
    1:     """
    1:     geos_version = (3, 1, 0)
    1:     geos_capi_version = (1, 5, 0)
       
    1:     def __init__(self, dll):
    1:         super(LGEOS310, self).__init__(dll)
    1:         self.geos_handle = self._lgeos.initGEOS_r(notice_h, error_h)
    1:         keys = list(self._lgeos.__dict__.keys())
  437:         for key in [x for x in keys if not x.endswith('_r')]:
  147:             if key + '_r' in keys:
  141:                 reentr_func = getattr(self._lgeos, key + '_r')
  141:                 attr = partial(reentr_func, self.geos_handle)
  141:                 attr.__name__ = reentr_func.__name__
  141:                 setattr(self, key, attr)
                   else:
    6:                 setattr(self, key, getattr(self._lgeos, key))
    1:         if not hasattr(self, 'GEOSFree'):
                   # GEOS < 3.1.1
                   self.GEOSFree = self._lgeos.free
               # Deprecated
    1:         self.GEOSGeomToWKB_buf.func.errcheck = errcheck_wkb
    1:         self.GEOSGeomToWKT.func.errcheck = errcheck_just_free
    1:         self.GEOSRelate.func.errcheck = errcheck_null_exception
    1:         for pred in (
    1:                 self.GEOSDisjoint,
    1:                 self.GEOSTouches,
    1:                 self.GEOSIntersects,
    1:                 self.GEOSCrosses,
    1:                 self.GEOSWithin,
    1:                 self.GEOSContains,
    1:                 self.GEOSOverlaps,
    1:                 self.GEOSCovers,
    1:                 self.GEOSEquals,
    1:                 self.GEOSEqualsExact,
    1:                 self.GEOSPreparedDisjoint,
    1:                 self.GEOSPreparedTouches,
    1:                 self.GEOSPreparedCrosses,
    1:                 self.GEOSPreparedWithin,
    1:                 self.GEOSPreparedOverlaps,
    1:                 self.GEOSPreparedContains,
    1:                 self.GEOSPreparedContainsProperly,
    1:                 self.GEOSPreparedCovers,
    1:                 self.GEOSPreparedIntersects,
    1:                 self.GEOSRelatePattern,
    1:                 self.GEOSisEmpty,
    1:                 self.GEOSisValid,
    1:                 self.GEOSisSimple,
    1:                 self.GEOSisRing,
   26:                 self.GEOSHasZ):
   25:             pred.func.errcheck = errcheck_predicate
       
    1:         self.GEOSisValidReason.func.errcheck = errcheck_just_free
       
    1:         self.methods['area'] = self.GEOSArea
    1:         self.methods['boundary'] = self.GEOSBoundary
    1:         self.methods['buffer'] = self.GEOSBuffer
    1:         self.methods['centroid'] = self.GEOSGetCentroid
    1:         self.methods['representative_point'] = self.GEOSPointOnSurface
    1:         self.methods['convex_hull'] = self.GEOSConvexHull
    1:         self.methods['distance'] = self.GEOSDistance
    1:         self.methods['envelope'] = self.GEOSEnvelope
    1:         self.methods['length'] = self.GEOSLength
    1:         self.methods['has_z'] = self.GEOSHasZ
    1:         self.methods['is_empty'] = self.GEOSisEmpty
    1:         self.methods['is_ring'] = self.GEOSisRing
    1:         self.methods['is_simple'] = self.GEOSisSimple
    1:         self.methods['is_valid'] = self.GEOSisValid
    1:         self.methods['disjoint'] = self.GEOSDisjoint
    1:         self.methods['touches'] = self.GEOSTouches
    1:         self.methods['intersects'] = self.GEOSIntersects
    1:         self.methods['crosses'] = self.GEOSCrosses
    1:         self.methods['within'] = self.GEOSWithin
    1:         self.methods['contains'] = self.GEOSContains
    1:         self.methods['overlaps'] = self.GEOSOverlaps
    1:         self.methods['covers'] = self.GEOSCovers
    1:         self.methods['equals'] = self.GEOSEquals
    1:         self.methods['equals_exact'] = self.GEOSEqualsExact
    1:         self.methods['relate'] = self.GEOSRelate
    1:         self.methods['difference'] = self.GEOSDifference
    1:         self.methods['symmetric_difference'] = self.GEOSSymDifference
    1:         self.methods['union'] = self.GEOSUnion
    1:         self.methods['intersection'] = self.GEOSIntersection
    1:         self.methods['prepared_disjoint'] = self.GEOSPreparedDisjoint
    1:         self.methods['prepared_touches'] = self.GEOSPreparedTouches
    1:         self.methods['prepared_intersects'] = self.GEOSPreparedIntersects
    1:         self.methods['prepared_crosses'] = self.GEOSPreparedCrosses
    1:         self.methods['prepared_within'] = self.GEOSPreparedWithin
    1:         self.methods['prepared_contains'] = self.GEOSPreparedContains
               self.methods['prepared_contains_properly'] = \
    1:             self.GEOSPreparedContainsProperly
    1:         self.methods['prepared_overlaps'] = self.GEOSPreparedOverlaps
    1:         self.methods['prepared_covers'] = self.GEOSPreparedCovers
    1:         self.methods['relate_pattern'] = self.GEOSRelatePattern
    1:         self.methods['simplify'] = self.GEOSSimplify
               self.methods['topology_preserve_simplify'] = \
    1:             self.GEOSTopologyPreserveSimplify
    1:         self.methods['cascaded_union'] = self.GEOSUnionCascaded
       
       
    2: class LGEOS311(LGEOS310):
           """Proxy for GEOS 3.1.1-CAPI-1.6.0
    1:     """
    1:     geos_version = (3, 1, 1)
    1:     geos_capi_version = (1, 6, 0)
       
    1:     def __init__(self, dll):
    1:         super(LGEOS311, self).__init__(dll)
       
       
    2: class LGEOS320(LGEOS311):
           """Proxy for GEOS 3.2.0-CAPI-1.6.0
    1:     """
    1:     geos_version = (3, 2, 0)
    1:     geos_capi_version = (1, 6, 0)
       
    1:     def __init__(self, dll):
    1:         super(LGEOS320, self).__init__(dll)
       
    1:         if geos_version >= (3, 2, 0):
       
                   def parallel_offset(geom, distance, resolution=16, join_style=1,
    1:                                 mitre_limit=5.0, side='right'):
                       side = side == 'left'
                       if distance < 0:
                           distance = abs(distance)
                           side = not side
                       return self.GEOSSingleSidedBuffer(
                           geom, distance, resolution, join_style, mitre_limit, side)
       
    1:             self.methods['parallel_offset'] = parallel_offset
       
    1:         self.methods['project'] = self.GEOSProject
    1:         self.methods['project_normalized'] = self.GEOSProjectNormalized
    1:         self.methods['interpolate'] = self.GEOSInterpolate
               self.methods['interpolate_normalized'] = \
    1:             self.GEOSInterpolateNormalized
    1:         self.methods['buffer_with_style'] = self.GEOSBufferWithStyle
    1:         self.methods['hausdorff_distance'] = self.GEOSHausdorffDistance
       
       
    2: class LGEOS330(LGEOS320):
           """Proxy for GEOS 3.3.0-CAPI-1.7.0
    1:     """
    1:     geos_version = (3, 3, 0)
    1:     geos_capi_version = (1, 7, 0)
       
    1:     def __init__(self, dll):
    1:         super(LGEOS330, self).__init__(dll)
       
               # GEOS 3.3.8 from homebrew has, but doesn't advertise
               # GEOSPolygonize_full. We patch it in explicitly here.
    1:         key = 'GEOSPolygonize_full'
    1:         func = getattr(self._lgeos, key + '_r')
    1:         attr = partial(func, self.geos_handle)
    1:         attr.__name__ = func.__name__
    1:         setattr(self, key, attr)
       
    2:         for pred in (self.GEOSisClosed,):
    1:             pred.func.errcheck = errcheck_predicate
       
               def parallel_offset(geom, distance, resolution=16, join_style=1,
    1:                             mitre_limit=5.0, side='right'):
                   if side == 'right':
                       distance *= -1
                   return self.GEOSOffsetCurve(
                       geom, distance, resolution, join_style, mitre_limit)
       
    1:         self.methods['parallel_offset'] = parallel_offset
    1:         self.methods['unary_union'] = self.GEOSUnaryUnion
    1:         self.methods['is_closed'] = self.GEOSisClosed
    1:         self.methods['cascaded_union'] = self.methods['unary_union']
    1:         self.methods['snap'] = self.GEOSSnap
    1:         self.methods['shared_paths'] = self.GEOSSharedPaths
    1:         self.methods['buffer_with_params'] = self.GEOSBufferWithParams
       
       
    2: class LGEOS340(LGEOS330):
           """Proxy for GEOS 3.4.0-CAPI-1.8.0
    1:     """
    1:     geos_version = (3, 4, 0)
    1:     geos_capi_version = (1, 8, 0)
       
    1:     def __init__(self, dll):
    1:         super(LGEOS340, self).__init__(dll)
    1:         self.methods['delaunay_triangulation'] = self.GEOSDelaunayTriangulation
    1:         self.methods['nearest_points'] = self.GEOSNearestPoints
       
       
    2: class LGEOS350(LGEOS340):
           """Proxy for GEOS 3.5.0-CAPI-1.9.0
    1:     """
       
    1:     def __init__(self, dll):
    1:         super(LGEOS350, self).__init__(dll)
    1:         self.methods['clip_by_rect'] = self.GEOSClipByRect
       
       
    1: if geos_version >= (3, 5, 0):
    1:     L = LGEOS350
       elif geos_version >= (3, 4, 0):
           L = LGEOS340
       elif geos_version >= (3, 3, 0):
           L = LGEOS330
       elif geos_version >= (3, 2, 0):
           L = LGEOS320
       elif geos_version >= (3, 1, 1):
           L = LGEOS311
       elif geos_version >= (3, 1, 0):
           L = LGEOS310
       else:
           L = LGEOS300
       
    1: lgeos = L(_lgeos)
       
       
    1: def cleanup(proxy):
           del proxy
       
    1: atexit.register(cleanup, lgeos)
