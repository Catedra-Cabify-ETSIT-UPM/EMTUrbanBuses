    1: from __future__ import absolute_import, division
       
    1: import textwrap
    1: from copy import copy
       
    1: import six
    1: import os
    1: from distutils.version import LooseVersion
       
    1: from plotly import optional_imports
       
    1: from plotly.io._base_renderers import (
           MimetypeRenderer,
           ExternalRenderer,
           PlotlyRenderer,
           NotebookRenderer,
           KaggleRenderer,
           AzureRenderer,
           ColabRenderer,
           JsonRenderer,
           PngRenderer,
           JpegRenderer,
           SvgRenderer,
           PdfRenderer,
           BrowserRenderer,
           IFrameRenderer,
           SphinxGalleryRenderer,
           CoCalcRenderer,
           DatabricksRenderer,
       )
    1: from plotly.io._utils import validate_coerce_fig_to_dict
       
    1: ipython = optional_imports.get_module("IPython")
    1: ipython_display = optional_imports.get_module("IPython.display")
    1: nbformat = optional_imports.get_module("nbformat")
       
       
       # Renderer configuration class
       # -----------------------------
    2: class RenderersConfig(object):
           """
           Singleton object containing the current renderer configurations
    1:     """
       
    1:     def __init__(self):
    1:         self._renderers = {}
    1:         self._default_name = None
    1:         self._default_renderers = []
    1:         self._render_on_display = False
    1:         self._to_activate = []
       
           # ### Magic methods ###
           # Make this act as a dict of renderers
    1:     def __len__(self):
               return len(self._renderers)
       
    1:     def __contains__(self, item):
               return item in self._renderers
       
    1:     def __iter__(self):
               return iter(self._renderers)
       
    1:     def __getitem__(self, item):
               renderer = self._renderers[item]
               return renderer
       
    1:     def __setitem__(self, key, value):
   24:         if not isinstance(value, (MimetypeRenderer, ExternalRenderer)):
                   raise ValueError(
                       """\
       Renderer must be a subclass of MimetypeRenderer or ExternalRenderer.
           Received value with type: {typ}""".format(
                           typ=type(value)
                       )
                   )
       
   24:         self._renderers[key] = value
       
    1:     def __delitem__(self, key):
               # Remove template
               del self._renderers[key]
       
               # Check if we need to remove it as the default
               if self._default == key:
                   self._default = None
       
    1:     def keys(self):
               return self._renderers.keys()
       
    1:     def items(self):
               return self._renderers.items()
       
    1:     def update(self, d={}, **kwargs):
               """
               Update one or more renderers from a dict or from input keyword
               arguments.
       
               Parameters
               ----------
               d: dict
                   Dictionary from renderer names to new renderer objects.
       
               kwargs
                   Named argument value pairs where the name is a renderer name
                   and the value is a new renderer object
               """
               for k, v in dict(d, **kwargs).items():
                   self[k] = v
       
           # ### Properties ###
    1:     @property
           def default(self):
               """
               The default renderer, or None if no there is no default
       
               If not None, the default renderer is used to render
               figures when the `plotly.io.show` function is called on a Figure.
       
               If `plotly.io.renderers.render_on_display` is True, then the default
               renderer will also be used to display Figures automatically when
               displayed in the Jupyter Notebook
       
               Multiple renderers may be registered by separating their names with
               '+' characters. For example, to specify rendering compatible with
               the classic Jupyter Notebook, JupyterLab, and PDF export:
       
               >>> import plotly.io as pio
               >>> pio.renderers.default = 'notebook+jupyterlab+pdf'
       
               The names of available renderers may be retrieved with:
       
               >>> import plotly.io as pio
               >>> list(pio.renderers)
       
               Returns
               -------
               str
               """
               return self._default_name
       
    1:     @default.setter
           def default(self, value):
               # Handle None
    1:         if not value:
                   # _default_name should always be a string so we can do
                   # pio.renderers.default.split('+')
    1:             self._default_name = ""
    1:             self._default_renderers = []
    1:             return
       
               # Store defaults name and list of renderer(s)
               renderer_names = self._validate_coerce_renderers(value)
               self._default_name = value
               self._default_renderers = [self[name] for name in renderer_names]
       
               # Register renderers for activation before their next use
               self._to_activate = list(self._default_renderers)
       
    1:     @property
           def render_on_display(self):
               """
               If True, the default mimetype renderers will be used to render
               figures when they are displayed in an IPython context.
       
               Returns
               -------
               bool
               """
               return self._render_on_display
       
    1:     @render_on_display.setter
           def render_on_display(self, val):
    1:         self._render_on_display = bool(val)
       
    1:     def _activate_pending_renderers(self, cls=object):
               """
               Activate all renderers that are waiting in the _to_activate list
       
               Parameters
               ----------
               cls
                   Only activate renders that are subclasses of this class
               """
               to_activate_with_cls = [
                   r for r in self._to_activate if cls and isinstance(r, cls)
               ]
       
               while to_activate_with_cls:
                   # Activate renderers from left to right so that right-most
                   # renderers take precedence
                   renderer = to_activate_with_cls.pop(0)
                   renderer.activate()
       
               self._to_activate = [
                   r for r in self._to_activate if not (cls and isinstance(r, cls))
               ]
       
    1:     def _validate_coerce_renderers(self, renderers_string):
               """
               Input a string and validate that it contains the names of one or more
               valid renderers separated on '+' characters.  If valid, return
               a list of the renderer names
       
               Parameters
               ----------
               renderers_string: str
       
               Returns
               -------
               list of str
               """
               # Validate value
               if not isinstance(renderers_string, six.string_types):
                   raise ValueError("Renderer must be specified as a string")
       
               renderer_names = renderers_string.split("+")
               invalid = [name for name in renderer_names if name not in self]
               if invalid:
                   raise ValueError(
                       """
       Invalid named renderer(s) received: {}""".format(
                           str(invalid)
                       )
                   )
       
               return renderer_names
       
    1:     def __repr__(self):
               return """\
       Renderers configuration
       -----------------------
           Default renderer: {default}
           Available renderers:
       {available}
       """.format(
                   default=repr(self.default), available=self._available_renderers_str()
               )
       
    1:     def _available_renderers_str(self):
               """
               Return nicely wrapped string representation of all
               available renderer names
               """
               available = "\n".join(
                   textwrap.wrap(
                       repr(list(self)),
                       width=79 - 8,
                       initial_indent=" " * 8,
                       subsequent_indent=" " * 9,
                   )
               )
               return available
       
    1:     def _build_mime_bundle(self, fig_dict, renderers_string=None, **kwargs):
               """
               Build a mime bundle dict containing a kev/value pair for each
               MimetypeRenderer specified in either the default renderer string,
               or in the supplied renderers_string argument.
       
               Note that this method skips any renderers that are not subclasses
               of MimetypeRenderer.
       
               Parameters
               ----------
               fig_dict: dict
                   Figure dictionary
               renderers_string: str or None (default None)
                   Renderer string to process rather than the current default
                   renderer string
       
               Returns
               -------
               dict
               """
               if renderers_string:
                   renderer_names = self._validate_coerce_renderers(renderers_string)
                   renderers_list = [self[name] for name in renderer_names]
       
                   # Activate these non-default renderers
                   for renderer in renderers_list:
                       if isinstance(renderer, MimetypeRenderer):
                           renderer.activate()
               else:
                   # Activate any pending default renderers
                   self._activate_pending_renderers(cls=MimetypeRenderer)
                   renderers_list = self._default_renderers
       
               bundle = {}
               for renderer in renderers_list:
                   if isinstance(renderer, MimetypeRenderer):
                       renderer = copy(renderer)
                       for k, v in kwargs.items():
                           if hasattr(renderer, k):
                               setattr(renderer, k, v)
       
                       bundle.update(renderer.to_mimebundle(fig_dict))
       
               return bundle
       
    1:     def _perform_external_rendering(self, fig_dict, renderers_string=None, **kwargs):
               """
               Perform external rendering for each ExternalRenderer specified
               in either the default renderer string, or in the supplied
               renderers_string argument.
       
               Note that this method skips any renderers that are not subclasses
               of ExternalRenderer.
       
               Parameters
               ----------
               fig_dict: dict
                   Figure dictionary
               renderers_string: str or None (default None)
                   Renderer string to process rather than the current default
                   renderer string
       
               Returns
               -------
               None
               """
               if renderers_string:
                   renderer_names = self._validate_coerce_renderers(renderers_string)
                   renderers_list = [self[name] for name in renderer_names]
       
                   # Activate these non-default renderers
                   for renderer in renderers_list:
                       if isinstance(renderer, ExternalRenderer):
                           renderer.activate()
               else:
                   self._activate_pending_renderers(cls=ExternalRenderer)
                   renderers_list = self._default_renderers
       
               for renderer in renderers_list:
                   if isinstance(renderer, ExternalRenderer):
                       renderer = copy(renderer)
                       for k, v in kwargs.items():
                           if hasattr(renderer, k):
                               setattr(renderer, k, v)
       
                       renderer.render(fig_dict)
       
       
       # Make renderers a singleton object
       # ---------------------------------
    1: renderers = RenderersConfig()
    1: del RenderersConfig
       
       
       # Show
    1: def show(fig, renderer=None, validate=True, **kwargs):
           """
           Show a figure using either the default renderer(s) or the renderer(s)
           specified by the renderer argument
       
           Parameters
           ----------
           fig: dict of Figure
               The Figure object or figure dict to display
       
           renderer: str or None (default None)
               A string containing the names of one or more registered renderers
               (separated by '+' characters) or None.  If None, then the default
               renderers specified in plotly.io.renderers.default are used.
       
           validate: bool (default True)
               True if the figure should be validated before being shown,
               False otherwise.
       
           Returns
           -------
           None
           """
           fig_dict = validate_coerce_fig_to_dict(fig, validate)
       
           # Mimetype renderers
           bundle = renderers._build_mime_bundle(fig_dict, renderers_string=renderer, **kwargs)
           if bundle:
               if not ipython_display:
                   raise ValueError(
                       "Mime type rendering requires ipython but it is not installed"
                   )
       
               if not nbformat or LooseVersion(nbformat.__version__) < LooseVersion("4.2.0"):
                   raise ValueError(
                       "Mime type rendering requires nbformat>=4.2.0 but it is not installed"
                   )
       
               ipython_display.display(bundle, raw=True)
       
           # external renderers
           renderers._perform_external_rendering(fig_dict, renderers_string=renderer, **kwargs)
       
       
       # Register renderers
       # ------------------
       
       # Plotly mime type
    1: plotly_renderer = PlotlyRenderer()
    1: renderers["plotly_mimetype"] = plotly_renderer
    1: renderers["jupyterlab"] = plotly_renderer
    1: renderers["nteract"] = plotly_renderer
    1: renderers["vscode"] = plotly_renderer
       
       # HTML-based
    1: config = {}
    1: renderers["notebook"] = NotebookRenderer(config=config)
    1: renderers["notebook_connected"] = NotebookRenderer(config=config, connected=True)
    1: renderers["kaggle"] = KaggleRenderer(config=config)
    1: renderers["azure"] = AzureRenderer(config=config)
    1: renderers["colab"] = ColabRenderer(config=config)
    1: renderers["cocalc"] = CoCalcRenderer()
    1: renderers["databricks"] = DatabricksRenderer()
       
       # JSON
    1: renderers["json"] = JsonRenderer()
       
       # Static Image
    1: img_kwargs = dict(height=450, width=700)
    1: renderers["png"] = PngRenderer(**img_kwargs)
    1: jpeg_renderer = JpegRenderer(**img_kwargs)
    1: renderers["jpeg"] = jpeg_renderer
    1: renderers["jpg"] = jpeg_renderer
    1: renderers["svg"] = SvgRenderer(**img_kwargs)
    1: renderers["pdf"] = PdfRenderer(**img_kwargs)
       
       # External
    1: renderers["browser"] = BrowserRenderer(config=config)
    1: renderers["firefox"] = BrowserRenderer(config=config, using="firefox")
    1: renderers["chrome"] = BrowserRenderer(config=config, using="chrome")
    1: renderers["chromium"] = BrowserRenderer(config=config, using="chromium")
    1: renderers["iframe"] = IFrameRenderer(config=config, include_plotlyjs=True)
    1: renderers["iframe_connected"] = IFrameRenderer(config=config, include_plotlyjs="cdn")
    1: renderers["sphinx_gallery"] = SphinxGalleryRenderer()
       
       # Set default renderer
       # --------------------
       # Version 4 renderer configuration
    1: default_renderer = None
       
       # Handle the PLOTLY_RENDERER environment variable
    1: env_renderer = os.environ.get("PLOTLY_RENDERER", None)
    1: if env_renderer:
           try:
               renderers._validate_coerce_renderers(env_renderer)
           except ValueError:
               raise ValueError(
                   """
       Invalid named renderer(s) specified in the 'PLOTLY_RENDERER'
       environment variable: {env_renderer}""".format(
                       env_renderer=env_renderer
                   )
               )
       
           default_renderer = env_renderer
    1: elif ipython and ipython.get_ipython():
           # Try to detect environment so that we can enable a useful
           # default renderer
           if not default_renderer:
               try:
                   import google.colab
       
                   default_renderer = "colab"
               except ImportError:
                   pass
       
           # Check if we're running in a Kaggle notebook
           if not default_renderer and os.path.exists("/kaggle/input"):
               default_renderer = "kaggle"
       
           # Check if we're running in an Azure Notebook
           if not default_renderer and "AZURE_NOTEBOOKS_HOST" in os.environ:
               default_renderer = "azure"
       
           # Check if we're running in VSCode
           if not default_renderer and "VSCODE_PID" in os.environ:
               default_renderer = "vscode"
       
           # Check if we're running in nteract
           if not default_renderer and "NTERACT_EXE" in os.environ:
               default_renderer = "nteract"
       
           # Check if we're running in CoCalc
           if not default_renderer and "COCALC_PROJECT_ID" in os.environ:
               default_renderer = "cocalc"
       
           if not default_renderer and "DATABRICKS_RUNTIME_VERSION" in os.environ:
               default_renderer = "databricks"
       
           # Check if we're running in spyder and orca is installed
           if not default_renderer and "SPYDER_ARGS" in os.environ:
               try:
                   from plotly.io.orca import validate_executable
       
                   validate_executable()
                   default_renderer = "svg"
               except ValueError:
                   # orca not found
                   pass
       
           # Fallback to renderer combination that will work automatically
           # in the classic notebook (offline), jupyterlab, nteract, vscode, and
           # nbconvert HTML export.
           if not default_renderer:
               default_renderer = "plotly_mimetype+notebook"
       else:
           # If ipython isn't available, try to display figures in the default
           # browser
    1:     import webbrowser
       
    1:     try:
    1:         webbrowser.get()
               default_renderer = "browser"
    1:     except webbrowser.Error:
               # Default browser could not be loaded
    1:         pass
       
    1: renderers.render_on_display = True
    1: renderers.default = default_renderer
