       # -*- coding: utf-8 -*-
       """
           pygments.formatters
           ~~~~~~~~~~~~~~~~~~~
       
           Pygments formatters.
       
           :copyright: Copyright 2006-2019 by the Pygments team, see AUTHORS.
           :license: BSD, see LICENSE for details.
    1: """
       
    1: import re
    1: import sys
    1: import types
    1: import fnmatch
    1: from os.path import basename
       
    1: from pygments.formatters._mapping import FORMATTERS
    1: from pygments.plugin import find_plugin_formatters
    1: from pygments.util import ClassNotFound, itervalues
       
    1: __all__ = ['get_formatter_by_name', 'get_formatter_for_filename',
    1:            'get_all_formatters', 'load_formatter_from_file'] + list(FORMATTERS)
       
    1: _formatter_cache = {}  # classes by name
    1: _pattern_cache = {}
       
       
    1: def _fn_matches(fn, glob):
           """Return whether the supplied file name fn matches pattern filename."""
           if glob not in _pattern_cache:
               pattern = _pattern_cache[glob] = re.compile(fnmatch.translate(glob))
               return pattern.match(fn)
           return _pattern_cache[glob].match(fn)
       
       
    1: def _load_formatters(module_name):
           """Load a formatter (and all others in the module too)."""
    1:     mod = __import__(module_name, None, None, ['__all__'])
    2:     for formatter_name in mod.__all__:
    1:         cls = getattr(mod, formatter_name)
    1:         _formatter_cache[cls.name] = cls
       
       
    1: def get_all_formatters():
           """Return a generator for all formatter classes."""
           # NB: this returns formatter classes, not info like get_all_lexers().
           for info in itervalues(FORMATTERS):
               if info[1] not in _formatter_cache:
                   _load_formatters(info[0])
               yield _formatter_cache[info[1]]
           for _, formatter in find_plugin_formatters():
               yield formatter
       
       
    1: def find_formatter_class(alias):
           """Lookup a formatter by alias.
       
           Returns None if not found.
           """
           for module_name, name, aliases, _, _ in itervalues(FORMATTERS):
               if alias in aliases:
                   if name not in _formatter_cache:
                       _load_formatters(module_name)
                   return _formatter_cache[name]
           for _, cls in find_plugin_formatters():
               if alias in cls.aliases:
                   return cls
       
       
    1: def get_formatter_by_name(_alias, **options):
           """Lookup and instantiate a formatter by alias.
       
           Raises ClassNotFound if not found.
           """
           cls = find_formatter_class(_alias)
           if cls is None:
               raise ClassNotFound("no formatter found for name %r" % _alias)
           return cls(**options)
       
       
    1: def load_formatter_from_file(filename, formattername="CustomFormatter",
                                    **options):
           """Load a formatter from a file.
       
           This method expects a file located relative to the current working
           directory, which contains a class named CustomFormatter. By default,
           it expects the Formatter to be named CustomFormatter; you can specify
           your own class name as the second argument to this function.
       
           Users should be very careful with the input, because this method
           is equivalent to running eval on the input file.
       
           Raises ClassNotFound if there are any problems importing the Formatter.
       
           .. versionadded:: 2.2
           """
           try:
               # This empty dict will contain the namespace for the exec'd file
               custom_namespace = {}
               with open(filename, 'rb') as f:
                   exec(f.read(), custom_namespace)
               # Retrieve the class `formattername` from that namespace
               if formattername not in custom_namespace:
                   raise ClassNotFound('no valid %s class found in %s' %
                                       (formattername, filename))
               formatter_class = custom_namespace[formattername]
               # And finally instantiate it with the options
               return formatter_class(**options)
           except IOError as err:
               raise ClassNotFound('cannot read %s' % filename)
           except ClassNotFound as err:
               raise
           except Exception as err:
               raise ClassNotFound('error when loading custom formatter: %s' % err)
       
       
    1: def get_formatter_for_filename(fn, **options):
           """Lookup and instantiate a formatter by filename pattern.
       
           Raises ClassNotFound if not found.
           """
           fn = basename(fn)
           for modname, name, _, filenames, _ in itervalues(FORMATTERS):
               for filename in filenames:
                   if _fn_matches(fn, filename):
                       if name not in _formatter_cache:
                           _load_formatters(modname)
                       return _formatter_cache[name](**options)
           for cls in find_plugin_formatters():
               for filename in cls.filenames:
                   if _fn_matches(fn, filename):
                       return cls(**options)
           raise ClassNotFound("no formatter found for file name %r" % fn)
       
       
    2: class _automodule(types.ModuleType):
    1:     """Automatically import formatters."""
       
    1:     def __getattr__(self, name):
    1:         info = FORMATTERS.get(name)
    1:         if info:
    1:             _load_formatters(info[0])
    1:             cls = _formatter_cache[info[1]]
    1:             setattr(self, name, cls)
    1:             return cls
               raise AttributeError(name)
       
       
    1: oldmod = sys.modules[__name__]
    1: newmod = _automodule(__name__)
    1: newmod.__dict__.update(oldmod.__dict__)
    1: sys.modules[__name__] = newmod
    1: del newmod.newmod, newmod.oldmod, newmod.sys, newmod.types
