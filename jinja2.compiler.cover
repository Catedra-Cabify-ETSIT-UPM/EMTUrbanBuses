       # -*- coding: utf-8 -*-
       """
           jinja2.compiler
           ~~~~~~~~~~~~~~~
       
           Compiles nodes into python code.
       
           :copyright: (c) 2017 by the Jinja Team.
           :license: BSD, see LICENSE for more details.
    1: """
    1: from itertools import chain
    1: from copy import deepcopy
    1: from keyword import iskeyword as is_python_keyword
    1: from functools import update_wrapper
    1: from jinja2 import nodes
    1: from jinja2.nodes import EvalContext
    1: from jinja2.visitor import NodeVisitor
    1: from jinja2.optimizer import Optimizer
    1: from jinja2.exceptions import TemplateAssertionError
    1: from jinja2.utils import Markup, concat, escape
    1: from jinja2._compat import range_type, text_type, string_types, \
            iteritems, NativeStringIO, imap, izip
    1: from jinja2.idtracking import Symbols, VAR_LOAD_PARAMETER, \
            VAR_LOAD_RESOLVE, VAR_LOAD_ALIAS, VAR_LOAD_UNDEFINED
       
       
       operators = {
    1:     'eq':       '==',
    1:     'ne':       '!=',
    1:     'gt':       '>',
    1:     'gteq':     '>=',
    1:     'lt':       '<',
    1:     'lteq':     '<=',
    1:     'in':       'in',
    1:     'notin':    'not in'
       }
       
       # what method to iterate over items do we want to use for dict iteration
       # in generated code?  on 2.x let's go with iteritems, on 3.x with items
    1: if hasattr(dict, 'iteritems'):
           dict_item_iter = 'iteritems'
       else:
    1:     dict_item_iter = 'items'
       
    1: code_features = ['division']
       
       # does this python version support generator stops? (PEP 0479)
    1: try:
    1:     exec('from __future__ import generator_stop')
    1:     code_features.append('generator_stop')
       except SyntaxError:
           pass
       
       # does this python version support yield from?
    1: try:
    1:     exec('def f(): yield from x()')
       except SyntaxError:
           supports_yield_from = False
       else:
    1:     supports_yield_from = True
       
       
    1: def optimizeconst(f):
   20:     def new_func(self, node, frame, **kwargs):
               # Only optimize if the frame is not volatile
  128:         if self.optimized and not frame.eval_ctx.volatile:
  128:             new_node = self.optimizer.visit(node, frame.eval_ctx)
  128:             if new_node != node:
                       return self.visit(new_node, frame)
  128:         return f(self, node, frame, **kwargs)
   20:     return update_wrapper(new_func, f)
       
       
       def generate(node, environment, name, filename, stream=None,
    1:              defer_init=False, optimized=True):
           """Generate the python source for a node tree."""
    8:     if not isinstance(node, nodes.Template):
               raise TypeError('Can\'t compile non template nodes')
    8:     generator = environment.code_generator_class(environment, name, filename,
    8:                                                  stream, defer_init,
    8:                                                  optimized)
    8:     generator.visit(node)
    8:     if stream is None:
    8:         return generator.stream.getvalue()
       
       
    1: def has_safe_repr(value):
           """Does the node have a safe representation?"""
    2:     if value is None or value is NotImplemented or value is Ellipsis:
               return True
    2:     if type(value) in (bool, int, float, complex, range_type, Markup) + string_types:
    2:         return True
           if type(value) in (tuple, list, set, frozenset):
               for item in value:
                   if not has_safe_repr(item):
                       return False
               return True
           elif type(value) is dict:
               for key, value in iteritems(value):
                   if not has_safe_repr(key):
                       return False
                   if not has_safe_repr(value):
                       return False
               return True
           return False
       
       
    1: def find_undeclared(nodes, names):
           """Check if the names passed are accessed undeclared.  The return value
           is a set of all the undeclared names from the sequence of names found.
           """
   12:     visitor = UndeclaredNameVisitor(names)
   12:     try:
   30:         for node in nodes:
   18:             visitor.visit(node)
           except VisitorExit:
               pass
   12:     return visitor.undeclared
       
       
    2: class MacroRef(object):
       
    1:     def __init__(self, node):
    3:         self.node = node
    3:         self.accesses_caller = False
    3:         self.accesses_kwargs = False
    3:         self.accesses_varargs = False
       
       
    2: class Frame(object):
    1:     """Holds compile time information for us."""
       
    1:     def __init__(self, eval_ctx, parent=None, level=None):
   14:         self.eval_ctx = eval_ctx
   14:         self.symbols = Symbols(parent and parent.symbols or None,
   14:                                level=level)
       
               # a toplevel frame is the root + soft frames such as if conditions.
   14:         self.toplevel = False
       
               # the root frame is basically just the outermost frame, so no if
               # conditions.  This information is used to optimize inheritance
               # situations.
   14:         self.rootlevel = False
       
               # in some dynamic inheritance situations the compiler needs to add
               # write tests around output statements.
   14:         self.require_output_check = parent and parent.require_output_check
       
               # inside some tags we are using a buffer rather than yield statements.
               # this for example affects {% filter %} or {% macro %}.  If a frame
               # is buffered this variable points to the name of the list used as
               # buffer.
   14:         self.buffer = None
       
               # the name of the block we're in, otherwise None.
   14:         self.block = parent and parent.block or None
       
               # the parent of this frame
   14:         self.parent = parent
       
   14:         if parent is not None:
    6:             self.buffer = parent.buffer
       
    1:     def copy(self):
               """Create a copy of the current one."""
    5:         rv = object.__new__(self.__class__)
    5:         rv.__dict__.update(self.__dict__)
    5:         rv.symbols = self.symbols.copy()
    5:         return rv
       
    1:     def inner(self, isolated=False):
               """Return an inner frame."""
    6:         if isolated:
                   return Frame(self.eval_ctx, level=self.symbols.level + 1)
    6:         return Frame(self.eval_ctx, self)
       
    1:     def soft(self):
               """Return a soft frame.  A soft frame may not be modified as
               standalone thing as it shares the resources with the frame it
               was created of, but it's not a rootlevel frame any longer.
       
               This is only used to implement if-statements.
               """
    5:         rv = self.copy()
    5:         rv.rootlevel = False
    5:         return rv
       
    1:     __copy__ = copy
       
       
    2: class VisitorExit(RuntimeError):
    1:     """Exception used by the `UndeclaredNameVisitor` to signal a stop."""
       
       
    2: class DependencyFinderVisitor(NodeVisitor):
    1:     """A visitor that collects filter and test calls."""
       
    1:     def __init__(self):
    8:         self.filters = set()
    8:         self.tests = set()
       
    1:     def visit_Filter(self, node):
    1:         self.generic_visit(node)
    1:         self.filters.add(node.name)
       
    1:     def visit_Test(self, node):
               self.generic_visit(node)
               self.tests.add(node.name)
       
    1:     def visit_Block(self, node):
               """Stop visiting at blocks."""
       
       
    2: class UndeclaredNameVisitor(NodeVisitor):
           """A visitor that checks if a name is accessed without being
           declared.  This is different from the frame visitor as it will
           not stop at closure frames.
    1:     """
       
    1:     def __init__(self, names):
   12:         self.names = set(names)
   12:         self.undeclared = set()
       
    1:     def visit_Name(self, node):
  131:         if node.ctx == 'load' and node.name in self.names:
    1:             self.undeclared.add(node.name)
    1:             if self.undeclared == self.names:
                       raise VisitorExit()
               else:
  130:             self.names.discard(node.name)
       
    1:     def visit_Block(self, node):
               """Stop visiting a blocks."""
       
       
    2: class CompilerExit(Exception):
           """Raised if the compiler encountered a situation where it just
           doesn't make sense to further process the code.  Any block that
           raises such an exception is not further processed.
    1:     """
       
       
    2: class CodeGenerator(NodeVisitor):
       
           def __init__(self, environment, name, filename, stream=None,
    1:                  defer_init=False, optimized=True):
    8:         if stream is None:
    8:             stream = NativeStringIO()
    8:         self.environment = environment
    8:         self.name = name
    8:         self.filename = filename
    8:         self.stream = stream
    8:         self.created_block_context = False
    8:         self.defer_init = defer_init
    8:         self.optimized = optimized
    8:         if optimized:
    8:             self.optimizer = Optimizer(environment)
       
               # aliases for imports
    8:         self.import_aliases = {}
       
               # a registry for all blocks.  Because blocks are moved out
               # into the global python scope they are registered here
    8:         self.blocks = {}
       
               # the number of extends statements so far
    8:         self.extends_so_far = 0
       
               # some templates have a rootlevel extends.  In this case we
               # can safely assume that we're a child template and do some
               # more optimizations.
    8:         self.has_known_extends = False
       
               # the current line number
    8:         self.code_lineno = 1
       
               # registry of all filters and tests (global, not block local)
    8:         self.tests = {}
    8:         self.filters = {}
       
               # the debug information
    8:         self.debug_info = []
    8:         self._write_debug_info = None
       
               # the number of new lines before the next write()
    8:         self._new_lines = 0
       
               # the line number of the last written statement
    8:         self._last_line = 0
       
               # true if nothing was written so far.
    8:         self._first_write = True
       
               # used by the `temporary_identifier` method to get new
               # unique, temporary identifier
    8:         self._last_identifier = 0
       
               # the current indentation
    8:         self._indentation = 0
       
               # Tracks toplevel assignments
    8:         self._assign_stack = []
       
               # Tracks parameter definition blocks
    8:         self._param_def_block = []
       
               # Tracks the current context.
    8:         self._context_reference_stack = ['context']
       
           # -- Various compilation helpers
       
    1:     def fail(self, msg, lineno):
               """Fail with a :exc:`TemplateAssertionError`."""
               raise TemplateAssertionError(msg, lineno, self.name, self.filename)
       
    1:     def temporary_identifier(self):
               """Get a new unique identifier."""
    4:         self._last_identifier += 1
    4:         return 't_%d' % self._last_identifier
       
    1:     def buffer(self, frame):
               """Enable buffering for the frame from that point onwards."""
    3:         frame.buffer = self.temporary_identifier()
    3:         self.writeline('%s = []' % frame.buffer)
       
    1:     def return_buffer_contents(self, frame, force_unescaped=False):
               """Return the buffer contents of the frame."""
    3:         if not force_unescaped:
                   if frame.eval_ctx.volatile:
                       self.writeline('if context.eval_ctx.autoescape:')
                       self.indent()
                       self.writeline('return Markup(concat(%s))' % frame.buffer)
                       self.outdent()
                       self.writeline('else:')
                       self.indent()
                       self.writeline('return concat(%s)' % frame.buffer)
                       self.outdent()
                       return
                   elif frame.eval_ctx.autoescape:
                       self.writeline('return Markup(concat(%s))' % frame.buffer)
                       return
    3:         self.writeline('return concat(%s)' % frame.buffer)
       
    1:     def indent(self):
               """Indent by one."""
   40:         self._indentation += 1
       
    1:     def outdent(self, step=1):
               """Outdent by step."""
   40:         self._indentation -= step
       
    1:     def start_write(self, frame, node=None):
               """Yield or write into the frame buffer."""
               if frame.buffer is None:
                   self.writeline('yield ', node)
               else:
                   self.writeline('%s.append(' % frame.buffer, node)
       
    1:     def end_write(self, frame):
               """End the writing process started by `start_write`."""
               if frame.buffer is not None:
                   self.write(')')
       
    1:     def simple_write(self, s, frame, node=None):
               """Simple shortcut for start_write + write + end_write."""
               self.start_write(frame, node)
               self.write(s)
               self.end_write(frame)
       
    1:     def blockvisit(self, nodes, frame):
               """Visit a list of nodes as block in a frame.  If the current frame
               is no buffer a dummy ``if 0: yield None`` is written automatically.
               """
   21:         try:
   21:             self.writeline('pass')
   48:             for node in nodes:
   27:                 self.visit(node, frame)
               except CompilerExit:
                   pass
       
    1:     def write(self, x):
               """Write a string into the output stream."""
  779:         if self._new_lines:
  282:             if not self._first_write:
  274:                 self.stream.write('\n' * self._new_lines)
  274:                 self.code_lineno += self._new_lines
  274:                 if self._write_debug_info is not None:
   40:                     self.debug_info.append((self._write_debug_info,
   40:                                             self.code_lineno))
   40:                     self._write_debug_info = None
  282:             self._first_write = False
  282:             self.stream.write('    ' * self._indentation)
  282:             self._new_lines = 0
  779:         self.stream.write(x)
       
    1:     def writeline(self, x, node=None, extra=0):
               """Combination of newline and write."""
  220:         self.newline(node, extra)
  220:         self.write(x)
       
    1:     def newline(self, node=None, extra=0):
               """Add one or more newlines before the next write."""
  282:         self._new_lines = max(self._new_lines, 1 + extra)
  282:         if node is not None and node.lineno != self._last_line:
   40:             self._write_debug_info = node.lineno
   40:             self._last_line = node.lineno
       
    1:     def signature(self, node, frame, extra_kwargs=None):
               """Writes a function call to the stream for the current node.
               A leading comma is added automatically.  The extra keyword
               arguments may not include python keywords otherwise a syntax
               error could occour.  The extra keyword arguments should be given
               as python dict.
               """
               # if any of the given keyword arguments is a python keyword
               # we have to make sure that no invalid call is created.
   38:         kwarg_workaround = False
   76:         for kwarg in chain((x.key for x in node.kwargs), extra_kwargs or ()):
                   if is_python_keyword(kwarg):
                       kwarg_workaround = True
                       break
       
   42:         for arg in node.args:
    4:             self.write(', ')
    4:             self.visit(arg, frame)
       
   38:         if not kwarg_workaround:
   38:             for kwarg in node.kwargs:
                       self.write(', ')
                       self.visit(kwarg, frame)
   38:             if extra_kwargs is not None:
                       for key, value in iteritems(extra_kwargs):
                           self.write(', %s=%s' % (key, value))
   38:         if node.dyn_args:
                   self.write(', *')
                   self.visit(node.dyn_args, frame)
       
   38:         if kwarg_workaround:
                   if node.dyn_kwargs is not None:
                       self.write(', **dict({')
                   else:
                       self.write(', **{')
                   for kwarg in node.kwargs:
                       self.write('%r: ' % kwarg.key)
                       self.visit(kwarg.value, frame)
                       self.write(', ')
                   if extra_kwargs is not None:
                       for key, value in iteritems(extra_kwargs):
                           self.write('%r: %s, ' % (key, value))
                   if node.dyn_kwargs is not None:
                       self.write('}, **')
                       self.visit(node.dyn_kwargs, frame)
                       self.write(')')
                   else:
                       self.write('}')
       
   38:         elif node.dyn_kwargs is not None:
    5:             self.write(', **')
    5:             self.visit(node.dyn_kwargs, frame)
       
    1:     def pull_dependencies(self, nodes):
               """Pull all the dependencies."""
    8:         visitor = DependencyFinderVisitor()
   20:         for node in nodes:
   12:             visitor.visit(node)
   24:         for dependency in 'filters', 'tests':
   16:             mapping = getattr(self, dependency)
   17:             for name in getattr(visitor, dependency):
    1:                 if name not in mapping:
    1:                     mapping[name] = self.temporary_identifier()
    1:                 self.writeline('%s = environment.%s[%r]' %
    1:                                (mapping[name], dependency, name))
       
    1:     def enter_frame(self, frame):
   12:         undefs = []
   32:         for target, (action, param) in iteritems(frame.symbols.loads):
   20:             if action == VAR_LOAD_PARAMETER:
    8:                 pass
   12:             elif action == VAR_LOAD_RESOLVE:
    9:                 self.writeline('%s = %s(%r)' %
    9:                                (target, self.get_resolve_func(), param))
    3:             elif action == VAR_LOAD_ALIAS:
                       self.writeline('%s = %s' % (target, param))
    3:             elif action == VAR_LOAD_UNDEFINED:
    3:                 undefs.append(target)
                   else:
                       raise NotImplementedError('unknown load instruction')
   12:         if undefs:
    2:             self.writeline('%s = missing' % ' = '.join(undefs))
       
    1:     def leave_frame(self, frame, with_python_scope=False):
   12:         if not with_python_scope:
    1:             undefs = []
    4:             for target, _ in iteritems(frame.symbols.loads):
    3:                 undefs.append(target)
    1:             if undefs:
    1:                 self.writeline('%s = missing' % ' = '.join(undefs))
       
    1:     def func(self, name):
   11:         if self.environment.is_async:
                   return 'async def %s' % name
   11:         return 'def %s' % name
       
    1:     def macro_body(self, node, frame):
               """Dump the function def of a macro or call block."""
    3:         frame = frame.inner()
    3:         frame.symbols.analyze_node(node)
    3:         macro_ref = MacroRef(node)
       
    3:         explicit_caller = None
    3:         skip_special_params = set()
    3:         args = []
    9:         for idx, arg in enumerate(node.args):
    6:             if arg.name == 'caller':
                       explicit_caller = idx
    6:             if arg.name in ('kwargs', 'varargs'):
    3:                 skip_special_params.add(arg.name)
    6:             args.append(frame.symbols.ref(arg.name))
       
    3:         undeclared = find_undeclared(node.body, ('caller', 'kwargs', 'varargs'))
       
    3:         if 'caller' in undeclared:
                   # In older Jinja2 versions there was a bug that allowed caller
                   # to retain the special behavior even if it was mentioned in
                   # the argument list.  However thankfully this was only really
                   # working if it was the last argument.  So we are explicitly
                   # checking this now and error out if it is anywhere else in
                   # the argument list.
                   if explicit_caller is not None:
                       try:
                           node.defaults[explicit_caller - len(node.args)]
                       except IndexError:
                           self.fail('When defining macros or call blocks the '
                                     'special "caller" argument must be omitted '
                                     'or be given a default.', node.lineno)
                   else:
                       args.append(frame.symbols.declare_parameter('caller'))
                   macro_ref.accesses_caller = True
    3:         if 'kwargs' in undeclared and not 'kwargs' in skip_special_params:
                   args.append(frame.symbols.declare_parameter('kwargs'))
                   macro_ref.accesses_kwargs = True
    3:         if 'varargs' in undeclared and not 'varargs' in skip_special_params:
                   args.append(frame.symbols.declare_parameter('varargs'))
                   macro_ref.accesses_varargs = True
       
               # macros are delayed, they never require output checks
    3:         frame.require_output_check = False
    3:         frame.symbols.analyze_node(node)
    3:         self.writeline('%s(%s):' % (self.func('macro'), ', '.join(args)), node)
    3:         self.indent()
       
    3:         self.buffer(frame)
    3:         self.enter_frame(frame)
       
    3:         self.push_parameter_definitions(frame)
    9:         for idx, arg in enumerate(node.args):
    6:             ref = frame.symbols.ref(arg.name)
    6:             self.writeline('if %s is missing:' % ref)
    6:             self.indent()
    6:             try:
    6:                 default = node.defaults[idx - len(node.args)]
    6:             except IndexError:
    6:                 self.writeline('%s = undefined(%r, name=%r)' % (
    6:                     ref,
    6:                     'parameter %r was not provided' % arg.name,
    6:                     arg.name))
                   else:
                       self.writeline('%s = ' % ref)
                       self.visit(default, frame)
    6:             self.mark_parameter_stored(ref)
    6:             self.outdent()
    3:         self.pop_parameter_definitions()
       
    3:         self.blockvisit(node.body, frame)
    3:         self.return_buffer_contents(frame, force_unescaped=True)
    3:         self.leave_frame(frame, with_python_scope=True)
    3:         self.outdent()
       
    3:         return frame, macro_ref
       
    1:     def macro_def(self, macro_ref, frame):
               """Dump the macro definition for the def created by macro_body."""
   12:         arg_tuple = ', '.join(repr(x.name) for x in macro_ref.node.args)
    3:         name = getattr(macro_ref.node, 'name', None)
    3:         if len(macro_ref.node.args) == 1:
                   arg_tuple += ','
    3:         self.write('Macro(environment, macro, %r, (%s), %r, %r, %r, '
                          'context.eval_ctx.autoescape)' %
    3:                    (name, arg_tuple, macro_ref.accesses_kwargs,
    3:                     macro_ref.accesses_varargs, macro_ref.accesses_caller))
       
    1:     def position(self, node):
               """Return a human readable position for the node."""
               rv = 'line %d' % node.lineno
               if self.name is not None:
                   rv += ' in ' + repr(self.name)
               return rv
       
    1:     def dump_local_context(self, frame):
               return '{%s}' % ', '.join(
                   '%r: %s' % (name, target) for name, target
                   in iteritems(frame.symbols.dump_stores()))
       
    1:     def write_commons(self):
               """Writes a common preamble that is used by root and block functions.
               Primarily this sets up common local helpers and enforces a generator
               through a dead branch.
               """
    8:         self.writeline('resolve = context.resolve_or_missing')
    8:         self.writeline('undefined = environment.undefined')
    8:         self.writeline('if 0: yield None')
       
    1:     def push_parameter_definitions(self, frame):
               """Pushes all parameter targets from the given frame into a local
               stack that permits tracking of yet to be assigned parameters.  In
               particular this enables the optimization from `visit_Name` to skip
               undefined expressions for parameters in macros as macros can reference
               otherwise unbound parameters.
               """
    3:         self._param_def_block.append(frame.symbols.dump_param_targets())
       
    1:     def pop_parameter_definitions(self):
               """Pops the current parameter definitions set."""
    3:         self._param_def_block.pop()
       
    1:     def mark_parameter_stored(self, target):
               """Marks a parameter in the current parameter definitions as stored.
               This will skip the enforced undefined checks.
               """
    6:         if self._param_def_block:
    6:             self._param_def_block[-1].discard(target)
       
    1:     def push_context_reference(self, target):
               self._context_reference_stack.append(target)
       
    1:     def pop_context_reference(self):
               self._context_reference_stack.pop()
       
    1:     def get_context_ref(self):
               return self._context_reference_stack[-1]
       
    1:     def get_resolve_func(self):
    9:         target = self._context_reference_stack[-1]
    9:         if target == 'context':
    9:             return 'resolve'
               return '%s.resolve' % target
       
    1:     def derive_context(self, frame):
               return '%s.derived(%s)' % (
                   self.get_context_ref(),
                   self.dump_local_context(frame),
               )
       
    1:     def parameter_is_undeclared(self, target):
               """Checks if a given target is an undeclared parameter."""
   49:         if not self._param_def_block:
   49:             return False
               return target in self._param_def_block[-1]
       
    1:     def push_assign_tracking(self):
               """Pushes a new layer for assignment tracking."""
               self._assign_stack.append(set())
       
    1:     def pop_assign_tracking(self, frame):
               """Pops the topmost level for assignment tracking and updates the
               context variables if necessary.
               """
               vars = self._assign_stack.pop()
               if not frame.toplevel or not vars:
                   return
               public_names = [x for x in vars if x[:1] != '_']
               if len(vars) == 1:
                   name = next(iter(vars))
                   ref = frame.symbols.ref(name)
                   self.writeline('context.vars[%r] = %s' % (name, ref))
               else:
                   self.writeline('context.vars.update({')
                   for idx, name in enumerate(vars):
                       if idx:
                           self.write(', ')
                       ref = frame.symbols.ref(name)
                       self.write('%r: %s' % (name, ref))
                   self.write('})')
               if public_names:
                   if len(public_names) == 1:
                       self.writeline('context.exported_vars.add(%r)' %
                                      public_names[0])
                   else:
                       self.writeline('context.exported_vars.update((%s))' %
                                      ', '.join(imap(repr, public_names)))
       
           # -- Statement Visitors
       
    1:     def visit_Template(self, node, frame=None):
    8:         assert frame is None, 'no root frame allowed'
    8:         eval_ctx = EvalContext(self.environment, self.name)
       
    8:         from jinja2.runtime import __all__ as exported
    8:         self.writeline('from __future__ import %s' % ', '.join(code_features))
    8:         self.writeline('from jinja2.runtime import ' + ', '.join(exported))
       
    8:         if self.environment.is_async:
                   self.writeline('from jinja2.asyncsupport import auto_await, '
                                  'auto_aiter, make_async_loop_context')
       
               # if we want a deferred initialization we cannot move the
               # environment into a local name
    8:         envenv = not self.defer_init and ', environment=environment' or ''
       
               # do we have an extends tag at all?  If not, we can save some
               # overhead by just not processing any inheritance code.
    8:         have_extends = node.find(nodes.Extends) is not None
       
               # find all blocks
    8:         for block in node.find_all(nodes.Block):
                   if block.name in self.blocks:
                       self.fail('block %r defined twice' % block.name, block.lineno)
                   self.blocks[block.name] = block
       
               # find all imports and import them
    8:         for import_ in node.find_all(nodes.ImportedName):
                   if import_.importname not in self.import_aliases:
                       imp = import_.importname
                       self.import_aliases[imp] = alias = self.temporary_identifier()
                       if '.' in imp:
                           module, obj = imp.rsplit('.', 1)
                           self.writeline('from %s import %s as %s' %
                                          (module, obj, alias))
                       else:
                           self.writeline('import %s as %s' % (imp, alias))
       
               # add the load name
    8:         self.writeline('name = %r' % self.name)
       
               # generate the root render function.
    8:         self.writeline('%s(context, missing=missing%s):' %
    8:                        (self.func('root'), envenv), extra=1)
    8:         self.indent()
    8:         self.write_commons()
       
               # process the root
    8:         frame = Frame(eval_ctx)
    8:         if 'self' in find_undeclared(node.body, ('self',)):
                   ref = frame.symbols.declare_parameter('self')
                   self.writeline('%s = TemplateReference(context)' % ref)
    8:         frame.symbols.analyze_node(node)
    8:         frame.toplevel = frame.rootlevel = True
    8:         frame.require_output_check = have_extends and not self.has_known_extends
    8:         if have_extends:
                   self.writeline('parent_template = None')
    8:         self.enter_frame(frame)
    8:         self.pull_dependencies(node.body)
    8:         self.blockvisit(node.body, frame)
    8:         self.leave_frame(frame, with_python_scope=True)
    8:         self.outdent()
       
               # make sure that the parent root is called.
    8:         if have_extends:
                   if not self.has_known_extends:
                       self.indent()
                       self.writeline('if parent_template is not None:')
                   self.indent()
                   if supports_yield_from and not self.environment.is_async:
                       self.writeline('yield from parent_template.'
                                      'root_render_func(context)')
                   else:
                       self.writeline('%sfor event in parent_template.'
                                      'root_render_func(context):' %
                                      (self.environment.is_async and 'async ' or ''))
                       self.indent()
                       self.writeline('yield event')
                       self.outdent()
                   self.outdent(1 + (not self.has_known_extends))
       
               # at this point we now have the blocks collected and can visit them too.
    8:         for name, block in iteritems(self.blocks):
                   self.writeline('%s(context, missing=missing%s):' %
                                  (self.func('block_' + name), envenv),
                                  block, 1)
                   self.indent()
                   self.write_commons()
                   # It's important that we do not make this frame a child of the
                   # toplevel template.  This would cause a variety of
                   # interesting issues with identifier tracking.
                   block_frame = Frame(eval_ctx)
                   undeclared = find_undeclared(block.body, ('self', 'super'))
                   if 'self' in undeclared:
                       ref = block_frame.symbols.declare_parameter('self')
                       self.writeline('%s = TemplateReference(context)' % ref)
                   if 'super' in undeclared:
                       ref = block_frame.symbols.declare_parameter('super')
                       self.writeline('%s = context.super(%r, '
                                      'block_%s)' % (ref, name, name))
                   block_frame.symbols.analyze_node(block)
                   block_frame.block = name
                   self.enter_frame(block_frame)
                   self.pull_dependencies(block.body)
                   self.blockvisit(block.body, block_frame)
                   self.leave_frame(block_frame, with_python_scope=True)
                   self.outdent()
       
   16:         self.writeline('blocks = {%s}' % ', '.join('%r: block_%s' % (x, x)
    8:                                                    for x in self.blocks),
    8:                        extra=1)
       
               # add a function that returns the debug info
   56:         self.writeline('debug_info = %r' % '&'.join('%s=%s' % x for x
    8:                                                     in self.debug_info))
       
    1:     def visit_Block(self, node, frame):
               """Call a block and register it for the template."""
               level = 0
               if frame.toplevel:
                   # if we know that we are a child template, there is no need to
                   # check if we are one
                   if self.has_known_extends:
                       return
                   if self.extends_so_far > 0:
                       self.writeline('if parent_template is None:')
                       self.indent()
                       level += 1
       
               if node.scoped:
                   context = self.derive_context(frame)
               else:
                   context = self.get_context_ref()
       
               if supports_yield_from and not self.environment.is_async and \
                  frame.buffer is None:
                   self.writeline('yield from context.blocks[%r][0](%s)' % (
                                  node.name, context), node)
               else:
                   loop = self.environment.is_async and 'async for' or 'for'
                   self.writeline('%s event in context.blocks[%r][0](%s):' % (
                                  loop, node.name, context), node)
                   self.indent()
                   self.simple_write('event', frame)
                   self.outdent()
       
               self.outdent(level)
       
    1:     def visit_Extends(self, node, frame):
               """Calls the extender."""
               if not frame.toplevel:
                   self.fail('cannot use extend from a non top-level scope',
                             node.lineno)
       
               # if the number of extends statements in general is zero so
               # far, we don't have to add a check if something extended
               # the template before this one.
               if self.extends_so_far > 0:
       
                   # if we have a known extends we just add a template runtime
                   # error into the generated code.  We could catch that at compile
                   # time too, but i welcome it not to confuse users by throwing the
                   # same error at different times just "because we can".
                   if not self.has_known_extends:
                       self.writeline('if parent_template is not None:')
                       self.indent()
                   self.writeline('raise TemplateRuntimeError(%r)' %
                                  'extended multiple times')
       
                   # if we have a known extends already we don't need that code here
                   # as we know that the template execution will end here.
                   if self.has_known_extends:
                       raise CompilerExit()
                   else:
                       self.outdent()
       
               self.writeline('parent_template = environment.get_template(', node)
               self.visit(node.template, frame)
               self.write(', %r)' % self.name)
               self.writeline('for name, parent_block in parent_template.'
                              'blocks.%s():' % dict_item_iter)
               self.indent()
               self.writeline('context.blocks.setdefault(name, []).'
                              'append(parent_block)')
               self.outdent()
       
               # if this extends statement was in the root level we can take
               # advantage of that information and simplify the generated code
               # in the top level from this point onwards
               if frame.rootlevel:
                   self.has_known_extends = True
       
               # and now we have one more
               self.extends_so_far += 1
       
    1:     def visit_Include(self, node, frame):
               """Handles includes."""
               if node.ignore_missing:
                   self.writeline('try:')
                   self.indent()
       
               func_name = 'get_or_select_template'
               if isinstance(node.template, nodes.Const):
                   if isinstance(node.template.value, string_types):
                       func_name = 'get_template'
                   elif isinstance(node.template.value, (tuple, list)):
                       func_name = 'select_template'
               elif isinstance(node.template, (nodes.Tuple, nodes.List)):
                   func_name = 'select_template'
       
               self.writeline('template = environment.%s(' % func_name, node)
               self.visit(node.template, frame)
               self.write(', %r)' % self.name)
               if node.ignore_missing:
                   self.outdent()
                   self.writeline('except TemplateNotFound:')
                   self.indent()
                   self.writeline('pass')
                   self.outdent()
                   self.writeline('else:')
                   self.indent()
       
               skip_event_yield = False
               if node.with_context:
                   loop = self.environment.is_async and 'async for' or 'for'
                   self.writeline('%s event in template.root_render_func('
                                  'template.new_context(context.get_all(), True, '
                                  '%s)):' % (loop, self.dump_local_context(frame)))
               elif self.environment.is_async:
                   self.writeline('for event in (await '
                                  'template._get_default_module_async())'
                                  '._body_stream:')
               else:
                   if supports_yield_from:
                       self.writeline('yield from template._get_default_module()'
                                      '._body_stream')
                       skip_event_yield = True
                   else:
                       self.writeline('for event in template._get_default_module()'
                                      '._body_stream:')
       
               if not skip_event_yield:
                   self.indent()
                   self.simple_write('event', frame)
                   self.outdent()
       
               if node.ignore_missing:
                   self.outdent()
       
    1:     def visit_Import(self, node, frame):
               """Visit regular imports."""
               self.writeline('%s = ' % frame.symbols.ref(node.target), node)
               if frame.toplevel:
                   self.write('context.vars[%r] = ' % node.target)
               if self.environment.is_async:
                   self.write('await ')
               self.write('environment.get_template(')
               self.visit(node.template, frame)
               self.write(', %r).' % self.name)
               if node.with_context:
                   self.write('make_module%s(context.get_all(), True, %s)'
                              % (self.environment.is_async and '_async' or '',
                                 self.dump_local_context(frame)))
               elif self.environment.is_async:
                   self.write('_get_default_module_async()')
               else:
                   self.write('_get_default_module()')
               if frame.toplevel and not node.target.startswith('_'):
                   self.writeline('context.exported_vars.discard(%r)' % node.target)
       
    1:     def visit_FromImport(self, node, frame):
               """Visit named imports."""
               self.newline(node)
               self.write('included_template = %senvironment.get_template('
                          % (self.environment.is_async and 'await ' or ''))
               self.visit(node.template, frame)
               self.write(', %r).' % self.name)
               if node.with_context:
                   self.write('make_module%s(context.get_all(), True, %s)'
                              % (self.environment.is_async and '_async' or '',
                                 self.dump_local_context(frame)))
               elif self.environment.is_async:
                   self.write('_get_default_module_async()')
               else:
                   self.write('_get_default_module()')
       
               var_names = []
               discarded_names = []
               for name in node.names:
                   if isinstance(name, tuple):
                       name, alias = name
                   else:
                       alias = name
                   self.writeline('%s = getattr(included_template, '
                                  '%r, missing)' % (frame.symbols.ref(alias), name))
                   self.writeline('if %s is missing:' % frame.symbols.ref(alias))
                   self.indent()
                   self.writeline('%s = undefined(%r %% '
                                  'included_template.__name__, '
                                  'name=%r)' %
                                  (frame.symbols.ref(alias),
                                   'the template %%r (imported on %s) does '
                                   'not export the requested name %s' % (
                                       self.position(node),
                                       repr(name)
                                  ), name))
                   self.outdent()
                   if frame.toplevel:
                       var_names.append(alias)
                       if not alias.startswith('_'):
                           discarded_names.append(alias)
       
               if var_names:
                   if len(var_names) == 1:
                       name = var_names[0]
                       self.writeline('context.vars[%r] = %s' %
                                      (name, frame.symbols.ref(name)))
                   else:
                       self.writeline('context.vars.update({%s})' % ', '.join(
                           '%r: %s' % (name, frame.symbols.ref(name)) for name in var_names
                       ))
               if discarded_names:
                   if len(discarded_names) == 1:
                       self.writeline('context.exported_vars.discard(%r)' %
                                      discarded_names[0])
                   else:
                       self.writeline('context.exported_vars.difference_'
                                      'update((%s))' % ', '.join(imap(repr, discarded_names)))
       
    1:     def visit_For(self, node, frame):
    1:         loop_frame = frame.inner()
    1:         test_frame = frame.inner()
    1:         else_frame = frame.inner()
       
               # try to figure out if we have an extended loop.  An extended loop
               # is necessary if the loop is in recursive mode if the special loop
               # variable is accessed in the body.
    1:         extended_loop = node.recursive or 'loop' in \
    1:                         find_undeclared(node.iter_child_nodes(
    1:                             only=('body',)), ('loop',))
       
    1:         loop_ref = None
    1:         if extended_loop:
                   loop_ref = loop_frame.symbols.declare_parameter('loop')
       
    1:         loop_frame.symbols.analyze_node(node, for_branch='body')
    1:         if node.else_:
                   else_frame.symbols.analyze_node(node, for_branch='else')
       
    1:         if node.test:
                   loop_filter_func = self.temporary_identifier()
                   test_frame.symbols.analyze_node(node, for_branch='test')
                   self.writeline('%s(fiter):' % self.func(loop_filter_func), node.test)
                   self.indent()
                   self.enter_frame(test_frame)
                   self.writeline(self.environment.is_async and 'async for ' or 'for ')
                   self.visit(node.target, loop_frame)
                   self.write(' in ')
                   self.write(self.environment.is_async and 'auto_aiter(fiter)' or 'fiter')
                   self.write(':')
                   self.indent()
                   self.writeline('if ', node.test)
                   self.visit(node.test, test_frame)
                   self.write(':')
                   self.indent()
                   self.writeline('yield ')
                   self.visit(node.target, loop_frame)
                   self.outdent(3)
                   self.leave_frame(test_frame, with_python_scope=True)
       
               # if we don't have an recursive loop we have to find the shadowed
               # variables at that point.  Because loops can be nested but the loop
               # variable is a special one we have to enforce aliasing for it.
    1:         if node.recursive:
                   self.writeline('%s(reciter, loop_render_func, depth=0):' %
                                  self.func('loop'), node)
                   self.indent()
                   self.buffer(loop_frame)
       
                   # Use the same buffer for the else frame
                   else_frame.buffer = loop_frame.buffer
       
               # make sure the loop variable is a special one and raise a template
               # assertion error if a loop tries to write to loop
    1:         if extended_loop:
                   self.writeline('%s = missing' % loop_ref)
       
    6:         for name in node.find_all(nodes.Name):
    5:             if name.ctx == 'store' and name.name == 'loop':
                       self.fail('Can\'t assign to special loop variable '
                                 'in for-loop target', name.lineno)
       
    1:         if node.else_:
                   iteration_indicator = self.temporary_identifier()
                   self.writeline('%s = 1' % iteration_indicator)
       
    1:         self.writeline(self.environment.is_async and 'async for ' or 'for ', node)
    1:         self.visit(node.target, loop_frame)
    1:         if extended_loop:
                   if self.environment.is_async:
                       self.write(', %s in await make_async_loop_context(' % loop_ref)
                   else:
                       self.write(', %s in LoopContext(' % loop_ref)
               else:
    1:             self.write(' in ')
       
    1:         if node.test:
                   self.write('%s(' % loop_filter_func)
    1:         if node.recursive:
                   self.write('reciter')
               else:
    1:             if self.environment.is_async and not extended_loop:
                       self.write('auto_aiter(')
    1:             self.visit(node.iter, frame)
    1:             if self.environment.is_async and not extended_loop:
                       self.write(')')
    1:         if node.test:
                   self.write(')')
       
    1:         if node.recursive:
                   self.write(', undefined, loop_render_func, depth):')
               else:
    1:             self.write(extended_loop and ', undefined):' or ':')
       
    1:         self.indent()
    1:         self.enter_frame(loop_frame)
       
    1:         self.blockvisit(node.body, loop_frame)
    1:         if node.else_:
                   self.writeline('%s = 0' % iteration_indicator)
    1:         self.outdent()
    1:         self.leave_frame(loop_frame, with_python_scope=node.recursive
                                and not node.else_)
       
    1:         if node.else_:
                   self.writeline('if %s:' % iteration_indicator)
                   self.indent()
                   self.enter_frame(else_frame)
                   self.blockvisit(node.else_, else_frame)
                   self.leave_frame(else_frame)
                   self.outdent()
       
               # if the node was recursive we have to return the buffer contents
               # and start the iteration code
    1:         if node.recursive:
                   self.return_buffer_contents(loop_frame)
                   self.outdent()
                   self.start_write(frame, node)
                   if self.environment.is_async:
                       self.write('await ')
                   self.write('loop(')
                   if self.environment.is_async:
                       self.write('auto_aiter(')
                   self.visit(node.iter, frame)
                   if self.environment.is_async:
                       self.write(')')
                   self.write(', loop)')
                   self.end_write(frame)
       
    1:     def visit_If(self, node, frame):
    5:         if_frame = frame.soft()
    5:         self.writeline('if ', node)
    5:         self.visit(node.test, if_frame)
    5:         self.write(':')
    5:         self.indent()
    5:         self.blockvisit(node.body, if_frame)
    5:         self.outdent()
    5:         for elif_ in node.elif_:
                   self.writeline('elif ', elif_)
                   self.visit(elif_.test, if_frame)
                   self.write(':')
                   self.indent()
                   self.blockvisit(elif_.body, if_frame)
                   self.outdent()
    5:         if node.else_:
    4:             self.writeline('else:')
    4:             self.indent()
    4:             self.blockvisit(node.else_, if_frame)
    4:             self.outdent()
       
    1:     def visit_Macro(self, node, frame):
    3:         macro_frame, macro_ref = self.macro_body(node, frame)
    3:         self.newline()
    3:         if frame.toplevel:
    3:             if not node.name.startswith('_'):
    3:                 self.write('context.exported_vars.add(%r)' % node.name)
    3:             ref = frame.symbols.ref(node.name)
    3:             self.writeline('context.vars[%r] = ' % node.name)
    3:         self.write('%s = ' % frame.symbols.ref(node.name))
    3:         self.macro_def(macro_ref, macro_frame)
       
    1:     def visit_CallBlock(self, node, frame):
               call_frame, macro_ref = self.macro_body(node, frame)
               self.writeline('caller = ')
               self.macro_def(macro_ref, call_frame)
               self.start_write(frame, node)
               self.visit_Call(node.call, frame, forward_caller=True)
               self.end_write(frame)
       
    1:     def visit_FilterBlock(self, node, frame):
               filter_frame = frame.inner()
               filter_frame.symbols.analyze_node(node)
               self.enter_frame(filter_frame)
               self.buffer(filter_frame)
               self.blockvisit(node.body, filter_frame)
               self.start_write(frame, node)
               self.visit_Filter(node.filter, filter_frame)
               self.end_write(frame)
               self.leave_frame(filter_frame)
       
    1:     def visit_With(self, node, frame):
               with_frame = frame.inner()
               with_frame.symbols.analyze_node(node)
               self.enter_frame(with_frame)
               for idx, (target, expr) in enumerate(izip(node.targets, node.values)):
                   self.newline()
                   self.visit(target, with_frame)
                   self.write(' = ')
                   self.visit(expr, frame)
               self.blockvisit(node.body, with_frame)
               self.leave_frame(with_frame)
       
    1:     def visit_ExprStmt(self, node, frame):
               self.newline(node)
               self.visit(node.node, frame)
       
    1:     def visit_Output(self, node, frame):
               # if we have a known extends statement, we don't output anything
               # if we are in a require_output_check section
   18:         if self.has_known_extends and frame.require_output_check:
                   return
       
   18:         allow_constant_finalize = True
   18:         if self.environment.finalize:
                   func = self.environment.finalize
                   if getattr(func, 'contextfunction', False) or \
                      getattr(func, 'evalcontextfunction', False):
                       allow_constant_finalize = False
                   elif getattr(func, 'environmentfunction', False):
                       finalize = lambda x: text_type(
                           self.environment.finalize(self.environment, x))
                   else:
                       finalize = lambda x: text_type(self.environment.finalize(x))
               else:
   18:             finalize = text_type
       
               # if we are inside a frame that requires output checking, we do so
   18:         outdent_later = False
   18:         if frame.require_output_check:
                   self.writeline('if parent_template is None:')
                   self.indent()
                   outdent_later = True
       
               # try to evaluate as many chunks as possible into a static
               # string at compile time.
   18:         body = []
  149:         for child in node.nodes:
  131:             try:
  131:                 if not allow_constant_finalize:
                           raise nodes.Impossible()
  131:                 const = child.as_const(frame.eval_ctx)
   62:             except nodes.Impossible:
   62:                 body.append(child)
   62:                 continue
                   # the frame can't be volatile here, becaus otherwise the
                   # as_const() function would raise an Impossible exception
                   # at that point.
   69:             try:
   69:                 if frame.eval_ctx.autoescape:
                           if hasattr(const, '__html__'):
                               const = const.__html__()
                           else:
                               const = escape(const)
   69:                 const = finalize(const)
                   except Exception:
                       # if something goes wrong here we evaluate the node
                       # at runtime for easier debugging
                       body.append(child)
                       continue
   69:             if body and isinstance(body[-1], list):
                       body[-1].append(const)
                   else:
   69:                 body.append([const])
       
               # if we have less than 3 nodes or a buffer we yield or extend/append
   18:         if len(body) < 3 or frame.buffer is not None:
   11:             if frame.buffer is not None:
                       # for one item we append, for more we extend
    6:                 if len(body) == 1:
                           self.writeline('%s.append(' % frame.buffer)
                       else:
    6:                     self.writeline('%s.extend((' % frame.buffer)
    6:                 self.indent()
  111:             for item in body:
  100:                 if isinstance(item, list):
   51:                     val = repr(concat(item))
   51:                     if frame.buffer is None:
    3:                         self.writeline('yield ' + val)
                           else:
   48:                         self.writeline(val + ',')
                       else:
   49:                     if frame.buffer is None:
    3:                         self.writeline('yield ', item)
                           else:
   46:                         self.newline(item)
   49:                     close = 1
   49:                     if frame.eval_ctx.volatile:
                               self.write('(escape if context.eval_ctx.autoescape'
                                          ' else to_string)(')
   49:                     elif frame.eval_ctx.autoescape:
                               self.write('escape(')
                           else:
   49:                         self.write('to_string(')
   49:                     if self.environment.finalize is not None:
                               self.write('environment.finalize(')
                               if getattr(self.environment.finalize,
                                          "contextfunction", False):
                                   self.write('context, ')
                               close += 1
   49:                     self.visit(item, frame)
   49:                     self.write(')' * close)
   49:                     if frame.buffer is not None:
   46:                         self.write(',')
   11:             if frame.buffer is not None:
                       # close the open parentheses
    6:                 self.outdent()
    6:                 self.writeline(len(body) == 1 and ')' or '))')
       
               # otherwise we create a format string as this is faster in that case
               else:
    7:             format = []
    7:             arguments = []
   38:             for item in body:
   31:                 if isinstance(item, list):
   18:                     format.append(concat(item).replace('%', '%%'))
                       else:
   13:                     format.append('%s')
   13:                     arguments.append(item)
    7:             self.writeline('yield ')
    7:             self.write(repr(concat(format)) + ' % (')
    7:             self.indent()
   20:             for argument in arguments:
   13:                 self.newline(argument)
   13:                 close = 0
   13:                 if frame.eval_ctx.volatile:
                           self.write('(escape if context.eval_ctx.autoescape else'
                                      ' to_string)(')
                           close += 1
   13:                 elif frame.eval_ctx.autoescape:
                           self.write('escape(')
                           close += 1
   13:                 if self.environment.finalize is not None:
                           self.write('environment.finalize(')
                           if getattr(self.environment.finalize,
                                      'contextfunction', False):
                               self.write('context, ')
                           elif getattr(self.environment.finalize,
                                      'evalcontextfunction', False):
                               self.write('context.eval_ctx, ')
                           elif getattr(self.environment.finalize,
                                      'environmentfunction', False):
                               self.write('environment, ')
                           close += 1
   13:                 self.visit(argument, frame)
   13:                 self.write(')' * close + ', ')
    7:             self.outdent()
    7:             self.writeline(')')
       
   18:         if outdent_later:
                   self.outdent()
       
    1:     def visit_Assign(self, node, frame):
               self.push_assign_tracking()
               self.newline(node)
               self.visit(node.target, frame)
               self.write(' = ')
               self.visit(node.node, frame)
               self.pop_assign_tracking(frame)
       
    1:     def visit_AssignBlock(self, node, frame):
               self.push_assign_tracking()
               block_frame = frame.inner()
               # This is a special case.  Since a set block always captures we
               # will disable output checks.  This way one can use set blocks
               # toplevel even in extended templates.
               block_frame.require_output_check = False
               block_frame.symbols.analyze_node(node)
               self.enter_frame(block_frame)
               self.buffer(block_frame)
               self.blockvisit(node.body, block_frame)
               self.newline(node)
               self.visit(node.target, frame)
               self.write(' = (Markup if context.eval_ctx.autoescape '
                          'else identity)(')
               if node.filter is not None:
                   self.visit_Filter(node.filter, block_frame)
               else:
                   self.write('concat(%s)' % block_frame.buffer)
               self.write(')')
               self.pop_assign_tracking(frame)
               self.leave_frame(block_frame)
       
           # -- Expression Visitors
       
    1:     def visit_Name(self, node, frame):
   75:         if node.ctx == 'store' and frame.toplevel:
                   if self._assign_stack:
                       self._assign_stack[-1].add(node.name)
   75:         ref = frame.symbols.ref(node.name)
       
               # If we are looking up a variable we might have to deal with the
               # case where it's undefined.  We can skip that case if the load
               # instruction indicates a parameter which are always defined.
   75:         if node.ctx == 'load':
   73:             load = frame.symbols.find_load(ref)
   73:             if not (load is not None and load[0] == VAR_LOAD_PARAMETER and \
   49:                     not self.parameter_is_undeclared(ref)):
   24:                 self.write('(undefined(name=%r) if %s is missing else %s)' %
   24:                            (node.name, ref, ref))
   24:                 return
       
   51:         self.write(ref)
       
    1:     def visit_NSRef(self, node, frame):
               # NSRefs can only be used to store values; since they use the normal
               # `foo.bar` notation they will be parsed as a normal attribute access
               # when used anywhere but in a `set` context
               ref = frame.symbols.ref(node.name)
               self.writeline('if not isinstance(%s, Namespace):' % ref)
               self.indent()
               self.writeline('raise TemplateRuntimeError(%r)' %
                              'cannot assign attribute on non-namespace object')
               self.outdent()
               self.writeline('%s[%r]' % (ref, node.attr))
       
    1:     def visit_Const(self, node, frame):
   20:         val = node.as_const(frame.eval_ctx)
   20:         if isinstance(val, float):
                   self.write(str(val))
               else:
   20:             self.write(repr(val))
       
    1:     def visit_TemplateData(self, node, frame):
               try:
                   self.write(repr(node.as_const(frame.eval_ctx)))
               except nodes.Impossible:
                   self.write('(Markup if context.eval_ctx.autoescape else identity)(%r)'
                              % node.data)
       
    1:     def visit_Tuple(self, node, frame):
    1:         self.write('(')
    1:         idx = -1
    3:         for idx, item in enumerate(node.items):
    2:             if idx:
    1:                 self.write(', ')
    2:             self.visit(item, frame)
    1:         self.write(idx == 0 and ',)' or ')')
       
    1:     def visit_List(self, node, frame):
               self.write('[')
               for idx, item in enumerate(node.items):
                   if idx:
                       self.write(', ')
                   self.visit(item, frame)
               self.write(']')
       
    1:     def visit_Dict(self, node, frame):
               self.write('{')
               for idx, item in enumerate(node.items):
                   if idx:
                       self.write(', ')
                   self.visit(item.key, frame)
                   self.write(': ')
                   self.visit(item.value, frame)
               self.write('}')
       
    1:     def binop(operator, interceptable=True):
    9:         @optimizeconst
               def visitor(self, node, frame):
                   if self.environment.sandboxed and \
                      operator in self.environment.intercepted_binops:
                       self.write('environment.call_binop(context, %r, ' % operator)
                       self.visit(node.left, frame)
                       self.write(', ')
                       self.visit(node.right, frame)
                   else:
                       self.write('(')
                       self.visit(node.left, frame)
                       self.write(' %s ' % operator)
                       self.visit(node.right, frame)
                   self.write(')')
    9:         return visitor
       
    1:     def uaop(operator, interceptable=True):
    3:         @optimizeconst
               def visitor(self, node, frame):
                   if self.environment.sandboxed and \
                      operator in self.environment.intercepted_unops:
                       self.write('environment.call_unop(context, %r, ' % operator)
                       self.visit(node.node, frame)
                   else:
                       self.write('(' + operator)
                       self.visit(node.node, frame)
                   self.write(')')
    3:         return visitor
       
    1:     visit_Add = binop('+')
    1:     visit_Sub = binop('-')
    1:     visit_Mul = binop('*')
    1:     visit_Div = binop('/')
    1:     visit_FloorDiv = binop('//')
    1:     visit_Pow = binop('**')
    1:     visit_Mod = binop('%')
    1:     visit_And = binop('and', interceptable=False)
    1:     visit_Or = binop('or', interceptable=False)
    1:     visit_Pos = uaop('+')
    1:     visit_Neg = uaop('-')
    1:     visit_Not = uaop('not ', interceptable=False)
    1:     del binop, uaop
       
    1:     @optimizeconst
           def visit_Concat(self, node, frame):
               if frame.eval_ctx.volatile:
                   func_name = '(context.eval_ctx.volatile and' \
                               ' markup_join or unicode_join)'
               elif frame.eval_ctx.autoescape:
                   func_name = 'markup_join'
               else:
                   func_name = 'unicode_join'
               self.write('%s((' % func_name)
               for arg in node.nodes:
                   self.visit(arg, frame)
                   self.write(', ')
               self.write('))')
       
    1:     @optimizeconst
           def visit_Compare(self, node, frame):
               self.visit(node.expr, frame)
               for op in node.ops:
                   self.visit(op, frame)
       
    1:     def visit_Operand(self, node, frame):
               self.write(' %s ' % operators[node.op])
               self.visit(node.expr, frame)
       
    1:     @optimizeconst
           def visit_Getattr(self, node, frame):
   74:         self.write('environment.getattr(')
   74:         self.visit(node.node, frame)
   74:         self.write(', %r)' % node.attr)
       
    1:     @optimizeconst
           def visit_Getitem(self, node, frame):
               # slices bypass the environment getitem method.
   16:         if isinstance(node.arg, nodes.Slice):
                   self.visit(node.node, frame)
                   self.write('[')
                   self.visit(node.arg, frame)
                   self.write(']')
               else:
   16:             self.write('environment.getitem(')
   16:             self.visit(node.node, frame)
   16:             self.write(', ')
   16:             self.visit(node.arg, frame)
   16:             self.write(')')
       
    1:     def visit_Slice(self, node, frame):
               if node.start is not None:
                   self.visit(node.start, frame)
               self.write(':')
               if node.stop is not None:
                   self.visit(node.stop, frame)
               if node.step is not None:
                   self.write(':')
                   self.visit(node.step, frame)
       
    1:     @optimizeconst
           def visit_Filter(self, node, frame):
    1:         if self.environment.is_async:
                   self.write('await auto_await(')
    1:         self.write(self.filters[node.name] + '(')
    1:         func = self.environment.filters.get(node.name)
    1:         if func is None:
                   self.fail('no filter named %r' % node.name, node.lineno)
    1:         if getattr(func, 'contextfilter', False):
                   self.write('context, ')
    1:         elif getattr(func, 'evalcontextfilter', False):
                   self.write('context.eval_ctx, ')
    1:         elif getattr(func, 'environmentfilter', False):
                   self.write('environment, ')
       
               # if the filter node is None we are inside a filter block
               # and want to write to the current buffer
    1:         if node.node is not None:
    1:             self.visit(node.node, frame)
               elif frame.eval_ctx.volatile:
                   self.write('(context.eval_ctx.autoescape and'
                              ' Markup(concat(%s)) or concat(%s))' %
                              (frame.buffer, frame.buffer))
               elif frame.eval_ctx.autoescape:
                   self.write('Markup(concat(%s))' % frame.buffer)
               else:
                   self.write('concat(%s)' % frame.buffer)
    1:         self.signature(node, frame)
    1:         self.write(')')
    1:         if self.environment.is_async:
                   self.write(')')
       
    1:     @optimizeconst
           def visit_Test(self, node, frame):
               self.write(self.tests[node.name] + '(')
               if node.name not in self.environment.tests:
                   self.fail('no test named %r' % node.name, node.lineno)
               self.visit(node.node, frame)
               self.signature(node, frame)
               self.write(')')
       
    1:     @optimizeconst
           def visit_CondExpr(self, node, frame):
               def write_expr2():
                   if node.expr2 is not None:
                       return self.visit(node.expr2, frame)
                   self.write('undefined(%r)' % ('the inline if-'
                              'expression on %s evaluated to false and '
                              'no else section was defined.' % self.position(node)))
       
               self.write('(')
               self.visit(node.expr1, frame)
               self.write(' if ')
               self.visit(node.test, frame)
               self.write(' else ')
               write_expr2()
               self.write(')')
       
    1:     @optimizeconst
    1:     def visit_Call(self, node, frame, forward_caller=False):
   37:         if self.environment.is_async:
                   self.write('await auto_await(')
   37:         if self.environment.sandboxed:
                   self.write('environment.call(context, ')
               else:
   37:             self.write('context.call(')
   37:         self.visit(node.node, frame)
   37:         extra_kwargs = forward_caller and {'caller': 'caller'} or None
   37:         self.signature(node, frame, extra_kwargs)
   37:         self.write(')')
   37:         if self.environment.is_async:
                   self.write(')')
       
    1:     def visit_Keyword(self, node, frame):
               self.write(node.key + '=')
               self.visit(node.value, frame)
       
           # -- Unused nodes for extensions
       
    1:     def visit_MarkSafe(self, node, frame):
               self.write('Markup(')
               self.visit(node.expr, frame)
               self.write(')')
       
    1:     def visit_MarkSafeIfAutoescape(self, node, frame):
               self.write('(context.eval_ctx.autoescape and Markup or identity)(')
               self.visit(node.expr, frame)
               self.write(')')
       
    1:     def visit_EnvironmentAttribute(self, node, frame):
               self.write('environment.' + node.name)
       
    1:     def visit_ExtensionAttribute(self, node, frame):
               self.write('environment.extensions[%r].%s' % (node.identifier, node.name))
       
    1:     def visit_ImportedName(self, node, frame):
               self.write(self.import_aliases[node.importname])
       
    1:     def visit_InternalName(self, node, frame):
               self.write(node.name)
       
    1:     def visit_ContextReference(self, node, frame):
               self.write('context')
       
    1:     def visit_Continue(self, node, frame):
               self.writeline('continue', node)
       
    1:     def visit_Break(self, node, frame):
               self.writeline('break', node)
       
    1:     def visit_Scope(self, node, frame):
               scope_frame = frame.inner()
               scope_frame.symbols.analyze_node(node)
               self.enter_frame(scope_frame)
               self.blockvisit(node.body, scope_frame)
               self.leave_frame(scope_frame)
       
    1:     def visit_OverlayScope(self, node, frame):
               ctx = self.temporary_identifier()
               self.writeline('%s = %s' % (ctx, self.derive_context(frame)))
               self.writeline('%s.vars = ' % ctx)
               self.visit(node.context, frame)
               self.push_context_reference(ctx)
       
               scope_frame = frame.inner(isolated=True)
               scope_frame.symbols.analyze_node(node)
               self.enter_frame(scope_frame)
               self.blockvisit(node.body, scope_frame)
               self.leave_frame(scope_frame)
               self.pop_context_reference()
       
    1:     def visit_EvalContextModifier(self, node, frame):
               for keyword in node.options:
                   self.writeline('context.eval_ctx.%s = ' % keyword.key)
                   self.visit(keyword.value, frame)
                   try:
                       val = keyword.value.as_const(frame.eval_ctx)
                   except nodes.Impossible:
                       frame.eval_ctx.volatile = True
                   else:
                       setattr(frame.eval_ctx, keyword.key, val)
       
    1:     def visit_ScopedEvalContextModifier(self, node, frame):
               old_ctx_name = self.temporary_identifier()
               saved_ctx = frame.eval_ctx.save()
               self.writeline('%s = context.eval_ctx.save()' % old_ctx_name)
               self.visit_EvalContextModifier(node, frame)
               for child in node.body:
                   self.visit(child, frame)
               frame.eval_ctx.revert(saved_ctx)
               self.writeline('context.eval_ctx.revert(%s)' % old_ctx_name)
