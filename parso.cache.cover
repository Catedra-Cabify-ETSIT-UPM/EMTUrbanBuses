    1: import time
    1: import os
    1: import sys
    1: import hashlib
    1: import gc
    1: import shutil
    1: import platform
    1: import errno
    1: import logging
       
    1: try:
    1:     import cPickle as pickle
    1: except:
    1:     import pickle
       
    1: from parso._compatibility import FileNotFoundError
       
    1: LOG = logging.getLogger(__name__)
       
       
    1: _PICKLE_VERSION = 32
       """
       Version number (integer) for file system cache.
       
       Increment this number when there are any incompatible changes in
       the parser tree classes.  For example, the following changes
       are regarded as incompatible.
       
       - A class name is changed.
       - A class is moved to another module.
       - A __slot__ of a class is changed.
       """
       
    1: _VERSION_TAG = '%s-%s%s-%s' % (
    1:     platform.python_implementation(),
    1:     sys.version_info[0],
    1:     sys.version_info[1],
    1:     _PICKLE_VERSION
       )
       """
       Short name for distinguish Python implementations and versions.
       
       It's like `sys.implementation.cache_tag` but for Python < 3.3
       we generate something similar.  See:
       http://docs.python.org/3/library/sys.html#sys.implementation
       """
       
       
    1: def _get_default_cache_path():
    1:     if platform.system().lower() == 'windows':
               dir_ = os.path.join(os.getenv('LOCALAPPDATA') or '~', 'Parso', 'Parso')
    1:     elif platform.system().lower() == 'darwin':
               dir_ = os.path.join('~', 'Library', 'Caches', 'Parso')
           else:
    1:         dir_ = os.path.join(os.getenv('XDG_CACHE_HOME') or '~/.cache', 'parso')
    1:     return os.path.expanduser(dir_)
       
       
    1: _default_cache_path = _get_default_cache_path()
       """
       The path where the cache is stored.
       
       On Linux, this defaults to ``~/.cache/parso/``, on OS X to
       ``~/Library/Caches/Parso/`` and on Windows to ``%LOCALAPPDATA%\\Parso\\Parso\\``.
       On Linux, if environment variable ``$XDG_CACHE_HOME`` is set,
       ``$XDG_CACHE_HOME/parso`` is used instead of the default one.
       """
       
    1: parser_cache = {}
       
       
    2: class _NodeCacheItem(object):
    1:     def __init__(self, node, lines, change_time=None):
               self.node = node
               self.lines = lines
               if change_time is None:
                   change_time = time.time()
               self.change_time = change_time
       
       
    1: def load_module(hashed_grammar, file_io, cache_path=None):
           """
           Returns a module or None, if it fails.
           """
           p_time = file_io.get_last_modified()
           if p_time is None:
               return None
       
           try:
               module_cache_item = parser_cache[hashed_grammar][file_io.path]
               if p_time <= module_cache_item.change_time:
                   return module_cache_item.node
           except KeyError:
               return _load_from_file_system(
                   hashed_grammar,
                   file_io.path,
                   p_time,
                   cache_path=cache_path
               )
       
       
    1: def _load_from_file_system(hashed_grammar, path, p_time, cache_path=None):
           cache_path = _get_hashed_path(hashed_grammar, path, cache_path=cache_path)
           try:
               try:
                   if p_time > os.path.getmtime(cache_path):
                       # Cache is outdated
                       return None
               except OSError as e:
                   if e.errno == errno.ENOENT:
                       # In Python 2 instead of an IOError here we get an OSError.
                       raise FileNotFoundError
                   else:
                       raise
       
               with open(cache_path, 'rb') as f:
                   gc.disable()
                   try:
                       module_cache_item = pickle.load(f)
                   finally:
                       gc.enable()
           except FileNotFoundError:
               return None
           else:
               parser_cache.setdefault(hashed_grammar, {})[path] = module_cache_item
               LOG.debug('pickle loaded: %s', path)
               return module_cache_item.node
       
       
    1: def save_module(hashed_grammar, file_io, module, lines, pickling=True, cache_path=None):
           path = file_io.path
           try:
               p_time = None if path is None else file_io.get_last_modified()
           except OSError:
               p_time = None
               pickling = False
       
           item = _NodeCacheItem(module, lines, p_time)
           parser_cache.setdefault(hashed_grammar, {})[path] = item
           if pickling and path is not None:
               _save_to_file_system(hashed_grammar, path, item, cache_path=cache_path)
       
       
    1: def _save_to_file_system(hashed_grammar, path, item, cache_path=None):
           with open(_get_hashed_path(hashed_grammar, path, cache_path=cache_path), 'wb') as f:
               pickle.dump(item, f, pickle.HIGHEST_PROTOCOL)
       
       
    1: def clear_cache(cache_path=None):
           if cache_path is None:
               cache_path = _default_cache_path
           shutil.rmtree(cache_path)
           parser_cache.clear()
       
       
    1: def _get_hashed_path(hashed_grammar, path, cache_path=None):
           directory = _get_cache_directory_path(cache_path=cache_path)
       
           file_hash = hashlib.sha256(path.encode("utf-8")).hexdigest()
           return os.path.join(directory, '%s-%s.pkl' % (hashed_grammar, file_hash))
       
       
    1: def _get_cache_directory_path(cache_path=None):
           if cache_path is None:
               cache_path = _default_cache_path
           directory = os.path.join(cache_path, _VERSION_TAG)
           if not os.path.exists(directory):
               os.makedirs(directory)
           return directory
