       """
       Task local storage for coroutines.
       
       Example::
       
           # Create a new task local.
           my_local = TaskLocal()
       
           # Set/retrieve/erase:
           my_local.set(value)
       
           value = my_local.get()
       
           my_local.delete()
       
       A new scope can be created as follows::
       
           with context():
               ...
       
       Within this scope, a new value can be assigned, which is only visible within
       the scope. The scope as passed along when code is sent to an executor and back.
    1: """
    1: from __future__ import unicode_literals
    1: from threading import local
    1: from functools import wraps
       
       __all__ = [
    1:     'context',
    1:     'get_context_id',
    1:     'wrap_in_current_context',
    1:     'TaskLocal',
    1:     'TaskLocalNotSetError',
       ]
       
       
    1: _storage = local()
    1: _last_context_id = 0
       
       
    1: def get_context_id():
           " Return the current context ID or None. "
           try:
               return _storage.context_id
           except AttributeError:
               return 0  # Default context.
       
       
    2: class context(object):
           """
           Context manager that activates a new scope.
    1:     """
    1:     def __init__(self, context_id=None):
               global _last_context_id
       
               if context_id is not None:
                   self.id = context_id
               else:
                   _last_context_id += 1
                   self.id = _last_context_id
       
    1:     def __enter__(self):
               try:
                   self._previous_id = _storage.context_id
               except AttributeError:
                   self._previous_id = None
       
               _storage.context_id = self.id
               return self.id
       
    1:     def __exit__(self, *a):
               if self._previous_id is None:
                   del _storage.context_id
               else:
                   _storage.context_id = self._previous_id
       
       
    2: class TaskLocal(object):
           """
           Like a thread local, but tied to the current task.
    1:     """
    1:     def __init__(self):
    3:         self._storage = {}
       
    1:     def get(self):
               try:
                   ctx = get_context_id()
                   return self._storage[ctx]
               except KeyError:
                   raise TaskLocalNotSetError
       
    1:     def set(self, value):
               ctx = get_context_id()
               self._storage[ctx] = value
       
    1:     def delete(self):
               ctx = get_context_id()
               try:
                   del self._storage[ctx]
               except KeyError:
                   pass
       
       
    1: def wrap_in_current_context(func):
           """
           Decorator that takes a function, and ensures that when it's called, the
           current context will apply.
           """
           assert callable(func)
           ctx_id = get_context_id()
       
           @wraps(func)
           def new_func(*a, **kw):
               with context(ctx_id):
                   return func(*a, **kw)
           return new_func
       
       
    2: class TaskLocalNotSetError(Exception):
    1:     pass
