       ''' A decorator-based method of constructing IPython magics with `argparse`
       option handling.
       
       New magic functions can be defined like so::
       
           from IPython.core.magic_arguments import (argument, magic_arguments,
               parse_argstring)
       
           @magic_arguments()
           @argument('-o', '--option', help='An optional argument.')
           @argument('arg', type=int, help='An integer positional argument.')
           def magic_cool(self, arg):
               """ A really cool magic command.
       
           """
               args = parse_argstring(magic_cool, arg)
               ...
       
       The `@magic_arguments` decorator marks the function as having argparse arguments.
       The `@argument` decorator adds an argument using the same syntax as argparse's
       `add_argument()` method. More sophisticated uses may also require the
       `@argument_group` or `@kwds` decorator to customize the formatting and the
       parsing.
       
       Help text for the magic is automatically generated from the docstring and the
       arguments::
       
           In[1]: %cool?
               %cool [-o OPTION] arg
               
               A really cool magic command.
               
               positional arguments:
                 arg                   An integer positional argument.
               
               optional arguments:
                 -o OPTION, --option OPTION
                                       An optional argument.
       
       Inheritance diagram:
       
       .. inheritance-diagram:: IPython.core.magic_arguments
          :parts: 3
       
    1: '''
       #-----------------------------------------------------------------------------
       # Copyright (C) 2010-2011, IPython Development Team.
       #
       # Distributed under the terms of the Modified BSD License.
       #
       # The full license is in the file COPYING.txt, distributed with this software.
       #-----------------------------------------------------------------------------
    1: import argparse
    1: import re
       
       # Our own imports
    1: from IPython.core.error import UsageError
    1: from IPython.utils.decorators import undoc
    1: from IPython.utils.process import arg_split
    1: from IPython.utils.text import dedent
       
    1: NAME_RE = re.compile(r"[a-zA-Z][a-zA-Z0-9_-]*$")
       
    2: @undoc
    1: class MagicHelpFormatter(argparse.RawDescriptionHelpFormatter):
           """A HelpFormatter with a couple of changes to meet our needs.
    1:     """
           # Modified to dedent text.
    1:     def _fill_text(self, text, width, indent):
   11:         return argparse.RawDescriptionHelpFormatter._fill_text(self, dedent(text), width, indent)
       
           # Modified to wrap argument placeholders in <> where necessary.
    1:     def _format_action_invocation(self, action):
   72:         if not action.option_strings:
   18:             metavar, = self._metavar_formatter(action, action.dest)(1)
   18:             return metavar
       
               else:
   54:             parts = []
       
                   # if the Optional doesn't take a value, format is:
                   #    -s, --long
   54:             if action.nargs == 0:
   38:                 parts.extend(action.option_strings)
       
                   # if the Optional takes a value, format is:
                   #    -s ARGS, --long ARGS
                   else:
   16:                 default = action.dest.upper()
   16:                 args_string = self._format_args(action, default)
                       # IPYTHON MODIFICATION: If args_string is not a plain name, wrap
                       # it in <> so it's valid RST.
   16:                 if not NAME_RE.match(args_string):
    6:                     args_string = "<%s>" % args_string
   36:                 for option_string in action.option_strings:
   20:                     parts.append('%s %s' % (option_string, args_string))
       
   54:             return ', '.join(parts)
       
           # Override the default prefix ('usage') to our % magic escape,
           # in a code block.
    1:     def add_usage(self, usage, actions, groups, prefix="::\n\n  %"):
   11:         super(MagicHelpFormatter, self).add_usage(usage, actions, groups, prefix)
       
    2: class MagicArgumentParser(argparse.ArgumentParser):
           """ An ArgumentParser tweaked for use by IPython magics.
    1:     """
           def __init__(self,
    1:                  prog=None,
    1:                  usage=None,
    1:                  description=None,
    1:                  epilog=None,
    1:                  parents=None,
    1:                  formatter_class=MagicHelpFormatter,
    1:                  prefix_chars='-',
    1:                  argument_default=None,
    1:                  conflict_handler='error',
    1:                  add_help=False):
   11:         if parents is None:
   11:             parents = []
   11:         super(MagicArgumentParser, self).__init__(prog=prog, usage=usage,
   11:             description=description, epilog=epilog,
   11:             parents=parents, formatter_class=formatter_class,
   11:             prefix_chars=prefix_chars, argument_default=argument_default,
   11:             conflict_handler=conflict_handler, add_help=add_help)
       
    1:     def error(self, message):
               """ Raise a catchable error instead of exiting.
               """
               raise UsageError(message)
       
    1:     def parse_argstring(self, argstring):
               """ Split a string into an argument list and parse that argument list.
               """
               argv = arg_split(argstring)
               return self.parse_args(argv)
       
       
    1: def construct_parser(magic_func):
           """ Construct an argument parser using the function decorations.
           """
   11:     kwds = getattr(magic_func, 'argcmd_kwds', {})
   11:     if 'description' not in kwds:
   11:         kwds['description'] = getattr(magic_func, '__doc__', None)
   11:     arg_name = real_name(magic_func)
   11:     parser = MagicArgumentParser(arg_name, **kwds)
           # Reverse the list of decorators in order to apply them in the
           # order in which they appear in the source.
   11:     group = None
   48:     for deco in magic_func.decorators[::-1]:
   37:         result = deco.add_to_parser(parser, group)
   37:         if result is not None:
                   group = result
       
           # Replace the magic function's docstring with the full help text.
   11:     magic_func.__doc__ = parser.format_help()
       
   11:     return parser
       
       
    1: def parse_argstring(magic_func, argstring):
           """ Parse the string of arguments for the given magic function.
           """
           return magic_func.parser.parse_argstring(argstring)
       
       
    1: def real_name(magic_func):
           """ Find the real name of the magic.
           """
   11:     magic_name = magic_func.__name__
   11:     if magic_name.startswith('magic_'):
               magic_name = magic_name[len('magic_'):]
   11:     return getattr(magic_func, 'argcmd_name', magic_name)
       
       
    2: class ArgDecorator(object):
           """ Base class for decorators to add ArgumentParser information to a method.
    1:     """
       
    1:     def __call__(self, func):
   37:         if not getattr(func, 'has_arguments', False):
   11:             func.has_arguments = True
   11:             func.decorators = []
   37:         func.decorators.append(self)
   37:         return func
       
    1:     def add_to_parser(self, parser, group):
               """ Add this object's information to the parser, if necessary.
               """
               pass
       
       
    2: class magic_arguments(ArgDecorator):
           """ Mark the magic as having argparse arguments and possibly adjust the
           name.
    1:     """
       
    1:     def __init__(self, name=None):
   11:         self.name = name
       
    1:     def __call__(self, func):
   11:         if not getattr(func, 'has_arguments', False):
                   func.has_arguments = True
                   func.decorators = []
   11:         if self.name is not None:
                   func.argcmd_name = self.name
               # This should be the first decorator in the list of decorators, thus the
               # last to execute. Build the parser.
   11:         func.parser = construct_parser(func)
   11:         return func
       
       
    2: class ArgMethodWrapper(ArgDecorator):
       
           """
           Base class to define a wrapper for ArgumentParser method.
       
           Child class must define either `_method_name` or `add_to_parser`.
       
    1:     """
       
    1:     _method_name = None
       
    1:     def __init__(self, *args, **kwds):
   36:         self.args = args
   36:         self.kwds = kwds
       
    1:     def add_to_parser(self, parser, group):
               """ Add this object's information to the parser.
               """
   37:         if group is not None:
                   parser = group
   37:         getattr(parser, self._method_name)(*self.args, **self.kwds)
   37:         return None
       
       
    2: class argument(ArgMethodWrapper):
           """ Store arguments and keywords to pass to add_argument().
       
           Instances also serve to decorate command methods.
    1:     """
    1:     _method_name = 'add_argument'
       
       
    2: class defaults(ArgMethodWrapper):
           """ Store arguments and keywords to pass to set_defaults().
       
           Instances also serve to decorate command methods.
    1:     """
    1:     _method_name = 'set_defaults'
       
       
    2: class argument_group(ArgMethodWrapper):
           """ Store arguments and keywords to pass to add_argument_group().
       
           Instances also serve to decorate command methods.
    1:     """
       
    1:     def add_to_parser(self, parser, group):
               """ Add this object's information to the parser.
               """
               return parser.add_argument_group(*self.args, **self.kwds)
       
       
    2: class kwds(ArgDecorator):
           """ Provide other keywords to the sub-parser constructor.
    1:     """
    1:     def __init__(self, **kwds):
               self.kwds = kwds
       
    1:     def __call__(self, func):
               func = super(kwds, self).__call__(func)
               func.argcmd_kwds = self.kwds
               return func
       
       
    1: __all__ = ['magic_arguments', 'argument', 'argument_group', 'kwds',
    1:     'parse_argstring']
