    1: from . import idnadata
    1: import bisect
    1: import unicodedata
    1: import re
    1: import sys
    1: from .intranges import intranges_contain
       
    1: _virama_combining_class = 9
    1: _alabel_prefix = b'xn--'
    1: _unicode_dots_re = re.compile(u'[\u002e\u3002\uff0e\uff61]')
       
    1: if sys.version_info[0] == 3:
    1:     unicode = str
    1:     unichr = chr
       
    2: class IDNAError(UnicodeError):
    1:     """ Base exception for all IDNA-encoding related problems """
    1:     pass
       
       
    2: class IDNABidiError(IDNAError):
    1:     """ Exception when bidirectional requirements are not satisfied """
    1:     pass
       
       
    2: class InvalidCodepoint(IDNAError):
    1:     """ Exception when a disallowed or unallocated codepoint is used """
    1:     pass
       
       
    2: class InvalidCodepointContext(IDNAError):
    1:     """ Exception when the codepoint is not valid in the context it is used """
    1:     pass
       
       
    1: def _combining_class(cp):
           v = unicodedata.combining(unichr(cp))
           if v == 0:
               if not unicodedata.name(unichr(cp)):
                   raise ValueError("Unknown character in unicodedata")
           return v
       
    1: def _is_script(cp, script):
           return intranges_contain(ord(cp), idnadata.scripts[script])
       
    1: def _punycode(s):
           return s.encode('punycode')
       
    1: def _unot(s):
           return 'U+{0:04X}'.format(s)
       
       
    1: def valid_label_length(label):
       
   69:     if len(label) > 63:
               return False
   69:     return True
       
       
    1: def valid_string_length(label, trailing_dot):
       
   23:     if len(label) > (254 if trailing_dot else 253):
               return False
   23:     return True
       
       
    1: def check_bidi(label, check_ltr=False):
       
           # Bidi rules should only be applied if string contains RTL characters
   69:     bidi_label = False
  505:     for (idx, cp) in enumerate(label, 1):
  436:         direction = unicodedata.bidirectional(cp)
  436:         if direction == '':
                   # String likely comes from a newer version of Unicode
                   raise IDNABidiError('Unknown directionality in label {0} at position {1}'.format(repr(label), idx))
  436:         if direction in ['R', 'AL', 'AN']:
                   bidi_label = True
   69:     if not bidi_label and not check_ltr:
   69:         return True
       
           # Bidi rule 1
           direction = unicodedata.bidirectional(label[0])
           if direction in ['R', 'AL']:
               rtl = True
           elif direction == 'L':
               rtl = False
           else:
               raise IDNABidiError('First codepoint in label {0} must be directionality L, R or AL'.format(repr(label)))
       
           valid_ending = False
           number_type = False
           for (idx, cp) in enumerate(label, 1):
               direction = unicodedata.bidirectional(cp)
       
               if rtl:
                   # Bidi rule 2
                   if not direction in ['R', 'AL', 'AN', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:
                       raise IDNABidiError('Invalid direction for codepoint at position {0} in a right-to-left label'.format(idx))
                   # Bidi rule 3
                   if direction in ['R', 'AL', 'EN', 'AN']:
                       valid_ending = True
                   elif direction != 'NSM':
                       valid_ending = False
                   # Bidi rule 4
                   if direction in ['AN', 'EN']:
                       if not number_type:
                           number_type = direction
                       else:
                           if number_type != direction:
                               raise IDNABidiError('Can not mix numeral types in a right-to-left label')
               else:
                   # Bidi rule 5
                   if not direction in ['L', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:
                       raise IDNABidiError('Invalid direction for codepoint at position {0} in a left-to-right label'.format(idx))
                   # Bidi rule 6
                   if direction in ['L', 'EN']:
                       valid_ending = True
                   elif direction != 'NSM':
                       valid_ending = False
       
           if not valid_ending:
               raise IDNABidiError('Label ends with illegal codepoint directionality')
       
           return True
       
       
    1: def check_initial_combiner(label):
       
   69:     if unicodedata.category(label[0])[0] == 'M':
               raise IDNAError('Label begins with an illegal combining character')
   69:     return True
       
       
    1: def check_hyphen_ok(label):
       
   69:     if label[2:4] == '--':
               raise IDNAError('Label has disallowed hyphens in 3rd and 4th position')
   69:     if label[0] == '-' or label[-1] == '-':
               raise IDNAError('Label must not start or end with a hyphen')
   69:     return True
       
       
    1: def check_nfc(label):
       
   69:     if unicodedata.normalize('NFC', label) != label:
               raise IDNAError('Label must be in Normalization Form C')
       
       
    1: def valid_contextj(label, pos):
       
           cp_value = ord(label[pos])
       
           if cp_value == 0x200c:
       
               if pos > 0:
                   if _combining_class(ord(label[pos - 1])) == _virama_combining_class:
                       return True
       
               ok = False
               for i in range(pos-1, -1, -1):
                   joining_type = idnadata.joining_types.get(ord(label[i]))
                   if joining_type == ord('T'):
                       continue
                   if joining_type in [ord('L'), ord('D')]:
                       ok = True
                       break
       
               if not ok:
                   return False
       
               ok = False
               for i in range(pos+1, len(label)):
                   joining_type = idnadata.joining_types.get(ord(label[i]))
                   if joining_type == ord('T'):
                       continue
                   if joining_type in [ord('R'), ord('D')]:
                       ok = True
                       break
               return ok
       
           if cp_value == 0x200d:
       
               if pos > 0:
                   if _combining_class(ord(label[pos - 1])) == _virama_combining_class:
                       return True
               return False
       
           else:
       
               return False
       
       
    1: def valid_contexto(label, pos, exception=False):
       
           cp_value = ord(label[pos])
       
           if cp_value == 0x00b7:
               if 0 < pos < len(label)-1:
                   if ord(label[pos - 1]) == 0x006c and ord(label[pos + 1]) == 0x006c:
                       return True
               return False
       
           elif cp_value == 0x0375:
               if pos < len(label)-1 and len(label) > 1:
                   return _is_script(label[pos + 1], 'Greek')
               return False
       
           elif cp_value == 0x05f3 or cp_value == 0x05f4:
               if pos > 0:
                   return _is_script(label[pos - 1], 'Hebrew')
               return False
       
           elif cp_value == 0x30fb:
               for cp in label:
                   if cp == u'\u30fb':
                       continue
                   if _is_script(cp, 'Hiragana') or _is_script(cp, 'Katakana') or _is_script(cp, 'Han'):
                       return True
               return False
       
           elif 0x660 <= cp_value <= 0x669:
               for cp in label:
                   if 0x6f0 <= ord(cp) <= 0x06f9:
                       return False
               return True
       
           elif 0x6f0 <= cp_value <= 0x6f9:
               for cp in label:
                   if 0x660 <= ord(cp) <= 0x0669:
                       return False
               return True
       
       
    1: def check_label(label):
       
   69:     if isinstance(label, (bytes, bytearray)):
   69:         label = label.decode('utf-8')
   69:     if len(label) == 0:
               raise IDNAError('Empty Label')
       
   69:     check_nfc(label)
   69:     check_hyphen_ok(label)
   69:     check_initial_combiner(label)
       
  505:     for (pos, cp) in enumerate(label):
  436:         cp_value = ord(cp)
  436:         if intranges_contain(cp_value, idnadata.codepoint_classes['PVALID']):
  436:             continue
               elif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTJ']):
                   try:
                       if not valid_contextj(label, pos):
                           raise InvalidCodepointContext('Joiner {0} not allowed at position {1} in {2}'.format(
                               _unot(cp_value), pos+1, repr(label)))
                   except ValueError:
                       raise IDNAError('Unknown codepoint adjacent to joiner {0} at position {1} in {2}'.format(
                           _unot(cp_value), pos+1, repr(label)))
               elif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTO']):
                   if not valid_contexto(label, pos):
                       raise InvalidCodepointContext('Codepoint {0} not allowed at position {1} in {2}'.format(_unot(cp_value), pos+1, repr(label)))
               else:
                   raise InvalidCodepoint('Codepoint {0} at position {1} of {2} not allowed'.format(_unot(cp_value), pos+1, repr(label)))
       
   69:     check_bidi(label)
       
       
    1: def alabel(label):
       
   69:     try:
   69:         label = label.encode('ascii')
   69:         ulabel(label)
   69:         if not valid_label_length(label):
                   raise IDNAError('Label too long')
   69:         return label
           except UnicodeEncodeError:
               pass
       
           if not label:
               raise IDNAError('No Input')
       
           label = unicode(label)
           check_label(label)
           label = _punycode(label)
           label = _alabel_prefix + label
       
           if not valid_label_length(label):
               raise IDNAError('Label too long')
       
           return label
       
       
    1: def ulabel(label):
       
   69:     if not isinstance(label, (bytes, bytearray)):
               try:
                   label = label.encode('ascii')
               except UnicodeEncodeError:
                   check_label(label)
                   return label
       
   69:     label = label.lower()
   69:     if label.startswith(_alabel_prefix):
               label = label[len(_alabel_prefix):]
           else:
   69:         check_label(label)
   69:         return label.decode('ascii')
       
           label = label.decode('punycode')
           check_label(label)
           return label
       
       
    1: def uts46_remap(domain, std3_rules=True, transitional=False):
           """Re-map the characters in the string according to UTS46 processing."""
           from .uts46data import uts46data
           output = u""
           try:
               for pos, char in enumerate(domain):
                   code_point = ord(char)
                   uts46row = uts46data[code_point if code_point < 256 else
                       bisect.bisect_left(uts46data, (code_point, "Z")) - 1]
                   status = uts46row[1]
                   replacement = uts46row[2] if len(uts46row) == 3 else None
                   if (status == "V" or
                           (status == "D" and not transitional) or
                           (status == "3" and not std3_rules and replacement is None)):
                       output += char
                   elif replacement is not None and (status == "M" or
                           (status == "3" and not std3_rules) or
                           (status == "D" and transitional)):
                       output += replacement
                   elif status != "I":
                       raise IndexError()
               return unicodedata.normalize("NFC", output)
           except IndexError:
               raise InvalidCodepoint(
                   "Codepoint {0} not allowed at position {1} in {2}".format(
                   _unot(code_point), pos + 1, repr(domain)))
       
       
    1: def encode(s, strict=False, uts46=False, std3_rules=False, transitional=False):
       
   23:     if isinstance(s, (bytes, bytearray)):
               s = s.decode("ascii")
   23:     if uts46:
               s = uts46_remap(s, std3_rules, transitional)
   23:     trailing_dot = False
   23:     result = []
   23:     if strict:
               labels = s.split('.')
           else:
   23:         labels = _unicode_dots_re.split(s)
   23:     if not labels or labels == ['']:
               raise IDNAError('Empty domain')
   23:     if labels[-1] == '':
               del labels[-1]
               trailing_dot = True
   92:     for label in labels:
   69:         s = alabel(label)
   69:         if s:
   69:             result.append(s)
               else:
                   raise IDNAError('Empty label')
   23:     if trailing_dot:
               result.append(b'')
   23:     s = b'.'.join(result)
   23:     if not valid_string_length(s, trailing_dot):
               raise IDNAError('Domain too long')
   23:     return s
       
       
    1: def decode(s, strict=False, uts46=False, std3_rules=False):
       
           if isinstance(s, (bytes, bytearray)):
               s = s.decode("ascii")
           if uts46:
               s = uts46_remap(s, std3_rules, False)
           trailing_dot = False
           result = []
           if not strict:
               labels = _unicode_dots_re.split(s)
           else:
               labels = s.split(u'.')
           if not labels or labels == ['']:
               raise IDNAError('Empty domain')
           if not labels[-1]:
               del labels[-1]
               trailing_dot = True
           for label in labels:
               s = ulabel(label)
               if s:
                   result.append(s)
               else:
                   raise IDNAError('Empty label')
           if trailing_dot:
               result.append(u'')
           return u'.'.join(result)
