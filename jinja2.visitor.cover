       # -*- coding: utf-8 -*-
       """
           jinja2.visitor
           ~~~~~~~~~~~~~~
       
           This module implements a visitor for the nodes.
       
           :copyright: (c) 2017 by the Jinja Team.
           :license: BSD.
    1: """
    1: from jinja2.nodes import Node
       
       
    2: class NodeVisitor(object):
           """Walks the abstract syntax tree and call visitor functions for every
           node found.  The visitor functions may return values which will be
           forwarded by the `visit` method.
       
           Per default the visitor functions for the nodes are ``'visit_'`` +
           class name of the node.  So a `TryFinally` node visit function would
           be `visit_TryFinally`.  This behavior can be changed by overriding
           the `get_visitor` function.  If no visitor function exists for a node
           (return value `None`) the `generic_visit` visitor is used instead.
    1:     """
       
    1:     def get_visitor(self, node):
               """Return the visitor function for this node or `None` if no visitor
               exists for this node.  In that case the generic visit function is
               used instead.
               """
 2029:         method = 'visit_' + node.__class__.__name__
 2029:         return getattr(self, method, None)
       
    1:     def visit(self, node, *args, **kwargs):
               """Visit a node."""
 2029:         f = self.get_visitor(node)
 2029:         if f is not None:
  747:             return f(node, *args, **kwargs)
 1282:         return self.generic_visit(node, *args, **kwargs)
       
    1:     def generic_visit(self, node, *args, **kwargs):
               """Called if no explicit visitor function exists for a node."""
 2452:         for node in node.iter_child_nodes():
 1322:             self.visit(node, *args, **kwargs)
       
       
    2: class NodeTransformer(NodeVisitor):
           """Walks the abstract syntax tree and allows modifications of nodes.
       
           The `NodeTransformer` will walk the AST and use the return value of the
           visitor functions to replace or remove the old node.  If the return
           value of the visitor function is `None` the node will be removed
           from the previous location otherwise it's replaced with the return
           value.  The return value may be the original node in which case no
           replacement takes place.
    1:     """
       
    1:     def generic_visit(self, node, *args, **kwargs):
 1296:         for field, old_value in node.iter_fields():
  947:             if isinstance(old_value, list):
   76:                 new_values = []
   80:                 for value in old_value:
    4:                     if isinstance(value, Node):
    4:                         value = self.visit(value, *args, **kwargs)
    4:                         if value is None:
                                   continue
    4:                         elif not isinstance(value, Node):
                                   new_values.extend(value)
                                   continue
    4:                     new_values.append(value)
   76:                 old_value[:] = new_values
  871:             elif isinstance(old_value, Node):
  217:                 new_node = self.visit(old_value, *args, **kwargs)
  217:                 if new_node is None:
                           delattr(node, field)
                       else:
  217:                     setattr(node, field, new_node)
  349:         return node
       
    1:     def visit_list(self, node, *args, **kwargs):
               """As transformers may return lists in some places this method
               can be used to enforce a list as return value.
               """
               rv = self.visit(node, *args, **kwargs)
               if not isinstance(rv, list):
                   rv = [rv]
               return rv
