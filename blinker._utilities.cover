    1: from weakref import ref
       
    1: from blinker._saferef import BoundMethodWeakref
       
       
    1: try:
    1:     callable
       except NameError:
           def callable(object):
               return hasattr(object, '__call__')
       
       
    1: try:
    1:     from collections import defaultdict
       except:
           class defaultdict(dict):
       
               def __init__(self, default_factory=None, *a, **kw):
                   if (default_factory is not None and
                       not hasattr(default_factory, '__call__')):
                       raise TypeError('first argument must be callable')
                   dict.__init__(self, *a, **kw)
                   self.default_factory = default_factory
       
               def __getitem__(self, key):
                   try:
                       return dict.__getitem__(self, key)
                   except KeyError:
                       return self.__missing__(key)
       
               def __missing__(self, key):
                   if self.default_factory is None:
                       raise KeyError(key)
                   self[key] = value = self.default_factory()
                   return value
       
               def __reduce__(self):
                   if self.default_factory is None:
                       args = tuple()
                   else:
                       args = self.default_factory,
                   return type(self), args, None, None, self.items()
       
               def copy(self):
                   return self.__copy__()
       
               def __copy__(self):
                   return type(self)(self.default_factory, self)
       
               def __deepcopy__(self, memo):
                   import copy
                   return type(self)(self.default_factory,
                                     copy.deepcopy(self.items()))
       
               def __repr__(self):
                   return 'defaultdict(%s, %s)' % (self.default_factory,
                                                   dict.__repr__(self))
       
       
    1: try:
    1:     from contextlib import contextmanager
       except ImportError:
           def contextmanager(fn):
               def oops(*args, **kw):
                   raise RuntimeError("Python 2.5 or above is required to use "
                                      "context managers.")
               oops.__name__ = fn.__name__
               return oops
       
    2: class _symbol(object):
       
    1:     def __init__(self, name):
               """Construct a new named symbol."""
    1:         self.__name__ = self.name = name
       
    1:     def __reduce__(self):
               return symbol, (self.name,)
       
    1:     def __repr__(self):
               return self.name
    1: _symbol.__name__ = 'symbol'
       
       
    2: class symbol(object):
           """A constant symbol.
       
           >>> symbol('foo') is symbol('foo')
           True
           >>> symbol('foo')
           foo
       
           A slight refinement of the MAGICCOOKIE=object() pattern.  The primary
           advantage of symbol() is its repr().  They are also singletons.
       
           Repeated calls of symbol('name') will all return the same instance.
       
    1:     """
    1:     symbols = {}
       
    1:     def __new__(cls, name):
    1:         try:
    1:             return cls.symbols[name]
    1:         except KeyError:
    1:             return cls.symbols.setdefault(name, _symbol(name))
       
       
    1: try:
    1:     text = (str, unicode)
    1: except NameError:
    1:     text = str
       
       
    1: def hashable_identity(obj):
           if hasattr(obj, '__func__'):
               return (id(obj.__func__), id(obj.__self__))
           elif hasattr(obj, 'im_func'):
               return (id(obj.im_func), id(obj.im_self))
           elif isinstance(obj, text):
               return obj
           else:
               return id(obj)
       
       
    1: WeakTypes = (ref, BoundMethodWeakref)
       
       
    2: class annotatable_weakref(ref):
    1:     """A weakref.ref that supports custom instance attributes."""
       
       
    1: def reference(object, callback=None, **annotations):
           """Return an annotated weak ref."""
           if callable(object):
               weak = callable_reference(object, callback)
           else:
               weak = annotatable_weakref(object, callback)
           for key, value in annotations.items():
               setattr(weak, key, value)
           return weak
       
       
    1: def callable_reference(object, callback=None):
           """Return an annotated weak ref, supporting bound instance methods."""
           if hasattr(object, 'im_self') and object.im_self is not None:
               return BoundMethodWeakref(target=object, on_delete=callback)
           elif hasattr(object, '__self__') and object.__self__ is not None:
               return BoundMethodWeakref(target=object, on_delete=callback)
           return annotatable_weakref(object, callback)
       
       
    2: class lazy_property(object):
    1:     """A @property that is only evaluated once."""
       
    1:     def __init__(self, deferred):
    2:         self._deferred = deferred
    2:         self.__doc__ = deferred.__doc__
       
    1:     def __get__(self, obj, cls):
               if obj is None:
                   return self
               value = self._deferred(obj)
               setattr(obj, self._deferred.__name__, value)
               return value
