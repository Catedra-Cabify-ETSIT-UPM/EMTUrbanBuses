       """
       Various richly-typed exceptions, that also help us deal with string formatting
       in python where it's easier.
       
       By putting the formatting in `__str__`, we also avoid paying the cost for
       users who silence the exceptions.
    1: """
    1: from numpy.core.overrides import set_module
       
    1: def _unpack_tuple(tup):
           if len(tup) == 1:
               return tup[0]
           else:
               return tup
       
       
    1: def _display_as_base(cls):
           """
           A decorator that makes an exception class look like its base.
       
           We use this to hide subclasses that are implementation details - the user
           should catch the base type, which is what the traceback will show them.
       
           Classes decorated with this decorator are subject to removal without a
           deprecation warning.
           """
    6:     assert issubclass(cls, Exception)
    6:     cls.__name__ = cls.__base__.__name__
    6:     cls.__qualname__ = cls.__base__.__qualname__
    6:     set_module(cls.__base__.__module__)(cls)
    6:     return cls
       
       
    2: class UFuncTypeError(TypeError):
    1:     """ Base class for all ufunc exceptions """
    1:     def __init__(self, ufunc):
               self.ufunc = ufunc
       
       
    2: @_display_as_base
    1: class _UFuncBinaryResolutionError(UFuncTypeError):
    1:     """ Thrown when a binary resolution fails """
    1:     def __init__(self, ufunc, dtypes):
               super().__init__(ufunc)
               self.dtypes = tuple(dtypes)
               assert len(self.dtypes) == 2
       
    1:     def __str__(self):
               return (
                   "ufunc {!r} cannot use operands with types {!r} and {!r}"
               ).format(
                   self.ufunc.__name__, *self.dtypes
               )
       
       
    2: @_display_as_base
    1: class _UFuncNoLoopError(UFuncTypeError):
    1:     """ Thrown when a ufunc loop cannot be found """
    1:     def __init__(self, ufunc, dtypes):
               super().__init__(ufunc)
               self.dtypes = tuple(dtypes)
       
    1:     def __str__(self):
               return (
                   "ufunc {!r} did not contain a loop with signature matching types "
                   "{!r} -> {!r}"
               ).format(
                   self.ufunc.__name__,
                   _unpack_tuple(self.dtypes[:self.ufunc.nin]),
                   _unpack_tuple(self.dtypes[self.ufunc.nin:])
               )
       
       
    2: @_display_as_base
    1: class _UFuncCastingError(UFuncTypeError):
    1:     def __init__(self, ufunc, casting, from_, to):
               super().__init__(ufunc)
               self.casting = casting
               self.from_ = from_
               self.to = to
       
       
    2: @_display_as_base
    1: class _UFuncInputCastingError(_UFuncCastingError):
    1:     """ Thrown when a ufunc input cannot be casted """
    1:     def __init__(self, ufunc, casting, from_, to, i):
               super().__init__(ufunc, casting, from_, to)
               self.in_i = i
       
    1:     def __str__(self):
               # only show the number if more than one input exists
               i_str = "{} ".format(self.in_i) if self.ufunc.nin != 1 else ""
               return (
                   "Cannot cast ufunc {!r} input {}from {!r} to {!r} with casting "
                   "rule {!r}"
               ).format(
                   self.ufunc.__name__, i_str, self.from_, self.to, self.casting
               )
       
       
    2: @_display_as_base
    1: class _UFuncOutputCastingError(_UFuncCastingError):
    1:     """ Thrown when a ufunc output cannot be casted """
    1:     def __init__(self, ufunc, casting, from_, to, i):
               super().__init__(ufunc, casting, from_, to)
               self.out_i = i
       
    1:     def __str__(self):
               # only show the number if more than one output exists
               i_str = "{} ".format(self.out_i) if self.ufunc.nout != 1 else ""
               return (
                   "Cannot cast ufunc {!r} output {}from {!r} to {!r} with casting "
                   "rule {!r}"
               ).format(
                   self.ufunc.__name__, i_str, self.from_, self.to, self.casting
               )
       
       
       # Exception used in shares_memory()
    2: @set_module('numpy')
    1: class TooHardError(RuntimeError):
    1:     pass
       
       
    2: @set_module('numpy')
    1: class AxisError(ValueError, IndexError):
    1:     """ Axis supplied was invalid. """
    1:     def __init__(self, axis, ndim=None, msg_prefix=None):
               # single-argument form just delegates to base class
               if ndim is None and msg_prefix is None:
                   msg = axis
       
               # do the string formatting here, to save work in the C code
               else:
                   msg = ("axis {} is out of bounds for array of dimension {}"
                          .format(axis, ndim))
                   if msg_prefix is not None:
                       msg = "{}: {}".format(msg_prefix, msg)
       
               super(AxisError, self).__init__(msg)
       
       
    2: @_display_as_base
    1: class _ArrayMemoryError(MemoryError):
    1:     """ Thrown when an array cannot be allocated"""
    1:     def __init__(self, shape, dtype):
               self.shape = shape
               self.dtype = dtype
       
    1:     def __str__(self):
               return "Unable to allocate array with shape {} and data type {}".format(self.shape, self.dtype)
       
