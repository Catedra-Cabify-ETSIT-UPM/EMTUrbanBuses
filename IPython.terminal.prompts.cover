    1: """Terminal input and output prompts."""
       
    1: from pygments.token import Token
    1: import sys
       
    1: from IPython.core.displayhook import DisplayHook
       
    1: from prompt_toolkit.formatted_text import fragment_list_width, PygmentsTokens
    1: from prompt_toolkit.shortcuts import print_formatted_text
       
       
    2: class Prompts(object):
    1:     def __init__(self, shell):
               self.shell = shell
       
    1:     def vi_mode(self):
               if (getattr(self.shell.pt_app, 'editing_mode', None) == 'VI'
                       and self.shell.prompt_includes_vi_mode):
                   return '['+str(self.shell.pt_app.app.vi_state.input_mode)[3:6]+'] '
               return ''
       
       
    1:     def in_prompt_tokens(self):
               return [
                   (Token.Prompt, self.vi_mode() ),
                   (Token.Prompt, 'In ['),
                   (Token.PromptNum, str(self.shell.execution_count)),
                   (Token.Prompt, ']: '),
               ]
       
    1:     def _width(self):
               return fragment_list_width(self.in_prompt_tokens())
       
    1:     def continuation_prompt_tokens(self, width=None):
               if width is None:
                   width = self._width()
               return [
                   (Token.Prompt, (' ' * (width - 5)) + '...: '),
               ]
       
    1:     def rewrite_prompt_tokens(self):
               width = self._width()
               return [
                   (Token.Prompt, ('-' * (width - 2)) + '> '),
               ]
       
    1:     def out_prompt_tokens(self):
               return [
                   (Token.OutPrompt, 'Out['),
                   (Token.OutPromptNum, str(self.shell.execution_count)),
                   (Token.OutPrompt, ']: '),
               ]
       
    2: class ClassicPrompts(Prompts):
    1:     def in_prompt_tokens(self):
               return [
                   (Token.Prompt, '>>> '),
               ]
       
    1:     def continuation_prompt_tokens(self, width=None):
               return [
                   (Token.Prompt, '... ')
               ]
       
    1:     def rewrite_prompt_tokens(self):
               return []
       
    1:     def out_prompt_tokens(self):
               return []
       
    2: class RichPromptDisplayHook(DisplayHook):
    1:     """Subclass of base display hook using coloured prompt"""
    1:     def write_output_prompt(self):
               sys.stdout.write(self.shell.separate_out)
               # If we're not displaying a prompt, it effectively ends with a newline,
               # because the output will be left-aligned.
               self.prompt_end_newline = True
       
               if self.do_full_cache:
                   tokens = self.shell.prompts.out_prompt_tokens()
                   prompt_txt = ''.join(s for t, s in tokens)
                   if prompt_txt and not prompt_txt.endswith('\n'):
                       # Ask for a newline before multiline output
                       self.prompt_end_newline = False
       
                   if self.shell.pt_app:
                       print_formatted_text(PygmentsTokens(tokens),
                           style=self.shell.pt_app.app.style, end='',
                       )
                   else:
                       sys.stdout.write(prompt_txt)
