       """Coordinate sequence utilities
    1: """
       
    1: import sys
    1: from array import array
    1: from ctypes import byref, c_double, c_uint
       
    1: from shapely.geos import lgeos
    1: from shapely.topology import Validating
       
    1: if sys.version_info[0] < 3:
           range = xrange
       
       
    2: class CoordinateSequence(object):
           """
           Iterative access to coordinate tuples from the parent geometry's coordinate
           sequence.
       
           Example:
       
             >>> from shapely.wkt import loads
             >>> g = loads('POINT (0.0 0.0)')
             >>> list(g.coords)
             [(0.0, 0.0)]
       
    1:     """
       
           # Attributes
           # ----------
           # _cseq : c_void_p
           #     Ctypes pointer to GEOS coordinate sequence
           # _ndim : int
           #     Number of dimensions (2 or 3, generally)
           # __p__ : object
           #     Parent (Shapely) geometry
    1:     _cseq = None
    1:     _ndim = None
    1:     __p__ = None
       
    1:     def __init__(self, parent):
               self.__p__ = parent
       
    1:     def _update(self):
               self._ndim = self.__p__._ndim
               self._cseq = lgeos.GEOSGeom_getCoordSeq(self.__p__._geom)
       
    1:     def __len__(self):
               self._update()
               cs_len = c_uint(0)
               lgeos.GEOSCoordSeq_getSize(self._cseq, byref(cs_len))
               return cs_len.value
       
    1:     def __iter__(self):
               self._update()
               dx = c_double()
               dy = c_double()
               dz = c_double()
               has_z = self._ndim == 3
               for i in range(self.__len__()):
                   lgeos.GEOSCoordSeq_getX(self._cseq, i, byref(dx))
                   lgeos.GEOSCoordSeq_getY(self._cseq, i, byref(dy))
                   if has_z:
                       lgeos.GEOSCoordSeq_getZ(self._cseq, i, byref(dz))
                       yield (dx.value, dy.value, dz.value)
                   else:
                       yield (dx.value, dy.value)
       
    1:     def __getitem__(self, key):
               self._update()
               dx = c_double()
               dy = c_double()
               dz = c_double()
               m = self.__len__()
               has_z = self._ndim == 3
               if isinstance(key, int):
                   if key + m < 0 or key >= m:
                       raise IndexError("index out of range")
                   if key < 0:
                       i = m + key
                   else:
                       i = key
                   lgeos.GEOSCoordSeq_getX(self._cseq, i, byref(dx))
                   lgeos.GEOSCoordSeq_getY(self._cseq, i, byref(dy))
                   if has_z:
                       lgeos.GEOSCoordSeq_getZ(self._cseq, i, byref(dz))
                       return (dx.value, dy.value, dz.value)
                   else:
                       return (dx.value, dy.value)
               elif isinstance(key, slice):
                   res = []
                   start, stop, stride = key.indices(m)
                   for i in range(start, stop, stride):
                       lgeos.GEOSCoordSeq_getX(self._cseq, i, byref(dx))
                       lgeos.GEOSCoordSeq_getY(self._cseq, i, byref(dy))
                       if has_z:
                           lgeos.GEOSCoordSeq_getZ(self._cseq, i, byref(dz))
                           res.append((dx.value, dy.value, dz.value))
                       else:
                           res.append((dx.value, dy.value))
                   return res
               else:
                   raise TypeError("key must be an index or slice")
       
    1:     @property
           def ctypes(self):
               self._update()
               has_z = self._ndim == 3
               n = self._ndim
               m = self.__len__()
               array_type = c_double * (m * n)
               data = array_type()
               temp = c_double()
               for i in range(m):
                   lgeos.GEOSCoordSeq_getX(self._cseq, i, byref(temp))
                   data[n*i] = temp.value
                   lgeos.GEOSCoordSeq_getY(self._cseq, i, byref(temp))
                   data[n*i+1] = temp.value
                   if has_z:
                       lgeos.GEOSCoordSeq_getZ(self._cseq, i, byref(temp))
                       data[n*i+2] = temp.value
               return data
       
    1:     def array_interface(self):
               """Provide the Numpy array protocol."""
               if sys.byteorder == 'little':
                   typestr = '<f8'
               elif sys.byteorder == 'big':
                   typestr = '>f8'
               else:
                   raise ValueError(
                       "Unsupported byteorder: neither little nor big-endian")
               ai = {
                   'version': 3,
                   'typestr': typestr,
                   'data': self.ctypes,
                   }
               ai.update({'shape': (len(self), self._ndim)})
               return ai
           
    1:     __array_interface__ = property(array_interface)
           
    1:     @property
           def xy(self):
               """X and Y arrays"""
               self._update()
               m = self.__len__()
               x = array('d')
               y = array('d')
               temp = c_double()
               for i in range(m):
                   lgeos.GEOSCoordSeq_getX(self._cseq, i, byref(temp))
                   x.append(temp.value)
                   lgeos.GEOSCoordSeq_getY(self._cseq, i, byref(temp))
                   y.append(temp.value)
               return x, y
       
       
    2: class BoundsOp(Validating):
       
    1:     def __init__(self, *args):
    1:         pass
       
    1:     def __call__(self, this):
               self._validate(this)
               env = this.envelope
               if env.geom_type == 'Point':
                   return env.bounds
               cs = lgeos.GEOSGeom_getCoordSeq(env.exterior._geom)
               cs_len = c_uint(0)
               lgeos.GEOSCoordSeq_getSize(cs, byref(cs_len))
               minx = 1.e+20
               maxx = -1e+20
               miny = 1.e+20
               maxy = -1e+20
               temp = c_double()
               for i in range(cs_len.value):
                   lgeos.GEOSCoordSeq_getX(cs, i, byref(temp))
                   x = temp.value
                   if x < minx: minx = x
                   if x > maxx: maxx = x
                   lgeos.GEOSCoordSeq_getY(cs, i, byref(temp))
                   y = temp.value
                   if y < miny: miny = y
                   if y > maxy: maxy = y
               return (minx, miny, maxx, maxy)
