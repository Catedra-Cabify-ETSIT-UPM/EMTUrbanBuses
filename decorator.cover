       # #########################     LICENSE     ############################ #
       
       # Copyright (c) 2005-2018, Michele Simionato
       # All rights reserved.
       
       # Redistribution and use in source and binary forms, with or without
       # modification, are permitted provided that the following conditions are
       # met:
       
       #   Redistributions of source code must retain the above copyright
       #   notice, this list of conditions and the following disclaimer.
       #   Redistributions in bytecode form must reproduce the above copyright
       #   notice, this list of conditions and the following disclaimer in
       #   the documentation and/or other materials provided with the
       #   distribution.
       
       # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
       # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
       # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
       # HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
       # INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
       # BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
       # OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
       # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
       # TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
       # USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
       # DAMAGE.
       
       """
       Decorator module, see http://pypi.python.org/pypi/decorator
       for the documentation.
    1: """
    1: from __future__ import print_function
       
    1: import re
    1: import sys
    1: import inspect
    1: import operator
    1: import itertools
    1: import collections
       
    1: __version__ = '4.4.0'
       
    1: if sys.version >= '3':
    1:     from inspect import getfullargspec
       
    1:     def get_init(cls):
               return cls.__init__
       else:
           FullArgSpec = collections.namedtuple(
               'FullArgSpec', 'args varargs varkw defaults '
               'kwonlyargs kwonlydefaults annotations')
       
           def getfullargspec(f):
               "A quick and dirty replacement for getfullargspec for Python 2.X"
               return FullArgSpec._make(inspect.getargspec(f) + ([], None, {}))
       
           def get_init(cls):
               return cls.__init__.__func__
       
    1: try:
    1:     iscoroutinefunction = inspect.iscoroutinefunction
       except AttributeError:
           # let's assume there are no coroutine functions in old Python
           def iscoroutinefunction(f):
               return False
    1: try:
    1:     from inspect import isgeneratorfunction
       except ImportError:
           # assume no generator function in old Python versions
           def isgeneratorfunction(caller):
               return False
       
       
    1: DEF = re.compile(r'\s*def\s*([_\w][_\w\d]*)\s*\(')
       
       
       # basic functionality
    2: class FunctionMaker(object):
           """
           An object with the ability to create functions with a given signature.
           It has attributes name, doc, module, signature, defaults, dict and
           methods update and make.
    1:     """
       
           # Atomic get-and-increment provided by the GIL
    1:     _compile_count = itertools.count()
       
           # make pylint happy
    1:     args = varargs = varkw = defaults = kwonlyargs = kwonlydefaults = ()
       
           def __init__(self, func=None, name=None, signature=None,
    1:                  defaults=None, doc=None, module=None, funcdict=None):
  116:         self.shortsignature = signature
  116:         if func:
                   # func can be a class or a callable, but not an instance method
  111:             self.name = func.__name__
  111:             if self.name == '<lambda>':  # small hack for lambda functions
                       self.name = '_lambda_'
  111:             self.doc = func.__doc__
  111:             self.module = func.__module__
  111:             if inspect.isfunction(func):
  111:                 argspec = getfullargspec(func)
  111:                 self.annotations = getattr(func, '__annotations__', {})
  777:                 for a in ('args', 'varargs', 'varkw', 'defaults', 'kwonlyargs',
                                 'kwonlydefaults'):
  666:                     setattr(self, a, getattr(argspec, a))
  372:                 for i, arg in enumerate(self.args):
  261:                     setattr(self, 'arg%d' % i, arg)
  111:                 allargs = list(self.args)
  111:                 allshortargs = list(self.args)
  111:                 if self.varargs:
                           allargs.append('*' + self.varargs)
                           allshortargs.append('*' + self.varargs)
  111:                 elif self.kwonlyargs:
                           allargs.append('*')  # single star syntax
  111:                 for a in self.kwonlyargs:
                           allargs.append('%s=None' % a)
                           allshortargs.append('%s=%s' % (a, a))
  111:                 if self.varkw:
    1:                     allargs.append('**' + self.varkw)
    1:                     allshortargs.append('**' + self.varkw)
  111:                 self.signature = ', '.join(allargs)
  111:                 self.shortsignature = ', '.join(allshortargs)
  111:                 self.dict = func.__dict__.copy()
               # func=None happens when decorating a caller
  116:         if name:
    5:             self.name = name
  116:         if signature is not None:
    5:             self.signature = signature
  116:         if defaults:
                   self.defaults = defaults
  116:         if doc:
    5:             self.doc = doc
  116:         if module:
    5:             self.module = module
  116:         if funcdict:
                   self.dict = funcdict
               # check existence required attributes
  116:         assert hasattr(self, 'name')
  116:         if not hasattr(self, 'signature'):
                   raise TypeError('You are decorating a non function: %s' % func)
       
    1:     def update(self, func, **kw):
               "Update the signature of func with the data in self"
  116:         func.__name__ = self.name
  116:         func.__doc__ = getattr(self, 'doc', None)
  116:         func.__dict__ = getattr(self, 'dict', {})
  116:         func.__defaults__ = self.defaults
  116:         func.__kwdefaults__ = self.kwonlydefaults or None
  116:         func.__annotations__ = getattr(self, 'annotations', None)
  116:         try:
  116:             frame = sys._getframe(3)
               except AttributeError:  # for IronPython and similar implementations
                   callermodule = '?'
               else:
  116:             callermodule = frame.f_globals.get('__name__', '?')
  116:         func.__module__ = getattr(self, 'module', callermodule)
  116:         func.__dict__.update(kw)
       
    1:     def make(self, src_templ, evaldict=None, addsource=False, **attrs):
               "Make a new function from a given template and update the signature"
  116:         src = src_templ % vars(self)  # expand name and signature
  116:         evaldict = evaldict or {}
  116:         mo = DEF.search(src)
  116:         if mo is None:
                   raise SyntaxError('not a valid function template\n%s' % src)
  116:         name = mo.group(1)  # extract the function name
  504:         names = set([name] + [arg.strip(' *') for arg in
  116:                               self.shortsignature.split(',')])
  504:         for n in names:
  388:             if n in ('_func_', '_call_'):
                       raise NameError('%s is overridden in\n%s' % (n, src))
       
  116:         if not src.endswith('\n'):  # add a newline for old Pythons
  116:             src += '\n'
       
               # Ensure each generated function has a unique filename for profilers
               # (such as cProfile) that depend on the tuple of (<filename>,
               # <definition line>, <function name>) being unique.
  116:         filename = '<%s:decorator-gen-%d>' % (
  116:             __file__, next(self._compile_count))
  116:         try:
  116:             code = compile(src, filename, 'single')
  116:             exec(code, evaldict)
               except Exception:
                   print('Error in generated code:', file=sys.stderr)
                   print(src, file=sys.stderr)
                   raise
  116:         func = evaldict[name]
  116:         if addsource:
  116:             attrs['__source__'] = src
  116:         self.update(func, **attrs)
  116:         return func
       
    1:     @classmethod
           def create(cls, obj, body, evaldict, defaults=None,
    1:                doc=None, module=None, addsource=True, **attrs):
               """
               Create a function from the strings name, signature and body.
               evaldict is the evaluation dictionary. If addsource is true an
               attribute __source__ is added to the result. The attributes attrs
               are added, if any.
               """
  116:         if isinstance(obj, str):  # "name(signature)"
    5:             name, rest = obj.strip().split('(', 1)
    5:             signature = rest[:-1]  # strip a right parens
    5:             func = None
               else:  # a function
  111:             name = None
  111:             signature = None
  111:             func = obj
  116:         self = cls(func, name, signature, defaults, doc, module)
  353:         ibody = '\n'.join('    ' + line for line in body.splitlines())
  116:         caller = evaldict.get('_call_')  # when called from `decorate`
  116:         if caller and iscoroutinefunction(caller):
                   body = ('async def %(name)s(%(signature)s):\n' + ibody).replace(
                       'return', 'return await')
               else:
  116:             body = 'def %(name)s(%(signature)s):\n' + ibody
  116:         return self.make(body, evaldict, addsource, **attrs)
       
       
    1: def decorate(func, caller, extras=()):
           """
           decorate(func, caller) decorates a function using a caller.
           If the caller is a generator function, the resulting function
           will be a generator function.
           """
  111:     evaldict = dict(_call_=caller, _func_=func)
  111:     es = ''
  111:     for i, extra in enumerate(extras):
               ex = '_e%d_' % i
               evaldict[ex] = extra
               es += ex + ', '
       
  111:     if '3.5' <= sys.version < '3.6':
               # with Python 3.5 isgeneratorfunction returns True for all coroutines
               # however we know that it is NOT possible to have a generator
               # coroutine in python 3.5: PEP525 was not there yet
               generatorcaller = isgeneratorfunction(
                   caller) and not iscoroutinefunction(caller)
           else:
  111:         generatorcaller = isgeneratorfunction(caller)
  111:     if generatorcaller:
               fun = FunctionMaker.create(
                   func, "for res in _call_(_func_, %s%%(shortsignature)s):\n"
                         "    yield res" % es, evaldict, __wrapped__=func)
           else:
  111:         fun = FunctionMaker.create(
  111:             func, "return _call_(_func_, %s%%(shortsignature)s)" % es,
  111:             evaldict, __wrapped__=func)
  111:     if hasattr(func, '__qualname__'):
  111:         fun.__qualname__ = func.__qualname__
  111:     return fun
       
       
    1: def decorator(caller, _func=None):
           """decorator(caller) converts a caller function into a decorator"""
   95:     if _func is not None:  # return a decorated function
               # this is obsolete behavior; you should use decorate instead
   90:         return decorate(_func, caller)
           # else return a decorator function
    5:     defaultargs, defaults = '', ()
    5:     if inspect.isclass(caller):
    1:         name = caller.__name__.lower()
    1:         doc = 'decorator(%s) converts functions/generators into ' \
    1:             'factories of %s objects' % (caller.__name__, caller.__name__)
    4:     elif inspect.isfunction(caller):
    4:         if caller.__name__ == '<lambda>':
                   name = '_lambda_'
               else:
    4:             name = caller.__name__
    4:         doc = caller.__doc__
    4:         nargs = caller.__code__.co_argcount
    4:         ndefs = len(caller.__defaults__ or ())
    4:         defaultargs = ', '.join(caller.__code__.co_varnames[nargs-ndefs:nargs])
    4:         if defaultargs:
                   defaultargs += ','
    4:         defaults = caller.__defaults__
           else:  # assume caller is an object with a __call__ method
               name = caller.__class__.__name__.lower()
               doc = caller.__call__.__doc__
    5:     evaldict = dict(_call=caller, _decorate_=decorate)
    5:     dec = FunctionMaker.create(
    5:         '%s(func, %s)' % (name, defaultargs),
    5:         'if func is None: return lambda func:  _decorate_(func, _call, (%s))\n'
    5:         'return _decorate_(func, _call, (%s))' % (defaultargs, defaultargs),
    5:         evaldict, doc=doc, module=caller.__module__, __wrapped__=caller)
    5:     if defaults:
               dec.__defaults__ = (None,) + defaults
    5:     return dec
       
       
       # ####################### contextmanager ####################### #
       
    1: try:  # Python >= 3.2
    1:     from contextlib import _GeneratorContextManager
       except ImportError:  # Python >= 2.5
           from contextlib import GeneratorContextManager as _GeneratorContextManager
       
       
    2: class ContextManager(_GeneratorContextManager):
    1:     def __call__(self, func):
               """Context manager decorator"""
               return FunctionMaker.create(
                   func, "with _self_: return _func_(%(shortsignature)s)",
                   dict(_self_=self, _func_=func), __wrapped__=func)
       
       
    1: init = getfullargspec(_GeneratorContextManager.__init__)
    1: n_args = len(init.args)
    1: if n_args == 2 and not init.varargs:  # (self, genobj) Python 2.7
           def __init__(self, g, *a, **k):
               return _GeneratorContextManager.__init__(self, g(*a, **k))
           ContextManager.__init__ = __init__
    1: elif n_args == 2 and init.varargs:  # (self, gen, *a, **k) Python 3.4
           pass
    1: elif n_args == 4:  # (self, gen, args, kwds) Python 3.5
    1:     def __init__(self, g, *a, **k):
               return _GeneratorContextManager.__init__(self, g, a, k)
    1:     ContextManager.__init__ = __init__
       
    1: _contextmanager = decorator(ContextManager)
       
       
    1: def contextmanager(func):
           # Enable Pylint config: contextmanager-decorators=decorator.contextmanager
           return _contextmanager(func)
       
       
       # ############################ dispatch_on ############################ #
       
    1: def append(a, vancestors):
           """
           Append ``a`` to the list of the virtual ancestors, unless it is already
           included.
           """
           add = True
           for j, va in enumerate(vancestors):
               if issubclass(va, a):
                   add = False
                   break
               if issubclass(a, va):
                   vancestors[j] = a
                   add = False
           if add:
               vancestors.append(a)
       
       
       # inspired from simplegeneric by P.J. Eby and functools.singledispatch
    1: def dispatch_on(*dispatch_args):
           """
           Factory of decorators turning a function into a generic function
           dispatching on the given arguments.
           """
           assert dispatch_args, 'No dispatch args passed'
           dispatch_str = '(%s,)' % ', '.join(dispatch_args)
       
           def check(arguments, wrong=operator.ne, msg=''):
               """Make sure one passes the expected number of arguments"""
               if wrong(len(arguments), len(dispatch_args)):
                   raise TypeError('Expected %d arguments, got %d%s' %
                                   (len(dispatch_args), len(arguments), msg))
       
           def gen_func_dec(func):
               """Decorator turning a function into a generic function"""
       
               # first check the dispatch arguments
               argset = set(getfullargspec(func).args)
               if not set(dispatch_args) <= argset:
                   raise NameError('Unknown dispatch arguments %s' % dispatch_str)
       
               typemap = {}
       
               def vancestors(*types):
                   """
                   Get a list of sets of virtual ancestors for the given types
                   """
                   check(types)
                   ras = [[] for _ in range(len(dispatch_args))]
                   for types_ in typemap:
                       for t, type_, ra in zip(types, types_, ras):
                           if issubclass(t, type_) and type_ not in t.mro():
                               append(type_, ra)
                   return [set(ra) for ra in ras]
       
               def ancestors(*types):
                   """
                   Get a list of virtual MROs, one for each type
                   """
                   check(types)
                   lists = []
                   for t, vas in zip(types, vancestors(*types)):
                       n_vas = len(vas)
                       if n_vas > 1:
                           raise RuntimeError(
                               'Ambiguous dispatch for %s: %s' % (t, vas))
                       elif n_vas == 1:
                           va, = vas
                           mro = type('t', (t, va), {}).mro()[1:]
                       else:
                           mro = t.mro()
                       lists.append(mro[:-1])  # discard t and object
                   return lists
       
               def register(*types):
                   """
                   Decorator to register an implementation for the given types
                   """
                   check(types)
       
                   def dec(f):
                       check(getfullargspec(f).args, operator.lt, ' in ' + f.__name__)
                       typemap[types] = f
                       return f
                   return dec
       
               def dispatch_info(*types):
                   """
                   An utility to introspect the dispatch algorithm
                   """
                   check(types)
                   lst = []
                   for anc in itertools.product(*ancestors(*types)):
                       lst.append(tuple(a.__name__ for a in anc))
                   return lst
       
               def _dispatch(dispatch_args, *args, **kw):
                   types = tuple(type(arg) for arg in dispatch_args)
                   try:  # fast path
                       f = typemap[types]
                   except KeyError:
                       pass
                   else:
                       return f(*args, **kw)
                   combinations = itertools.product(*ancestors(*types))
                   next(combinations)  # the first one has been already tried
                   for types_ in combinations:
                       f = typemap.get(types_)
                       if f is not None:
                           return f(*args, **kw)
       
                   # else call the default implementation
                   return func(*args, **kw)
       
               return FunctionMaker.create(
                   func, 'return _f_(%s, %%(shortsignature)s)' % dispatch_str,
                   dict(_f_=_dispatch), register=register, default=func,
                   typemap=typemap, vancestors=vancestors, ancestors=ancestors,
                   dispatch_info=dispatch_info, __wrapped__=func)
       
           gen_func_dec.__name__ = 'dispatch_on' + dispatch_str
           return gen_func_dec
