       """
       The rcsetup module contains the default values and the validation code for
       customization using matplotlib's rc settings.
       
       Each rc setting is assigned a default value and a function used to validate
       any attempted changes to that setting. The default values and validation
       functions are defined in the rcsetup module, and are used to construct the
       rcParams global object which stores the settings and is referenced throughout
       matplotlib.
       
       These default values should be consistent with the default matplotlibrc file
       that actually reflects the values given here. Any additions or deletions to the
       parameter set listed here should also be visited to the
       :file:`matplotlibrc.template` in matplotlib's root source directory.
    1: """
    1: from collections.abc import Iterable, Mapping
    1: from functools import reduce
    1: import operator
    1: import os
    1: import re
       
    1: from matplotlib import cbook
    1: from matplotlib.cbook import ls_mapper
    1: from matplotlib.fontconfig_pattern import parse_fontconfig_pattern
    1: from matplotlib.colors import is_color_like
       
       # Don't let the original cycler collide with our validating cycler
    1: from cycler import Cycler, cycler as ccycler
       
       
       # The capitalized forms are needed for ipython at present; this may
       # change for later versions.
    1: interactive_bk = ['GTK3Agg', 'GTK3Cairo',
    1:                   'MacOSX',
    1:                   'nbAgg',
    1:                   'Qt4Agg', 'Qt4Cairo', 'Qt5Agg', 'Qt5Cairo',
    1:                   'TkAgg', 'TkCairo',
    1:                   'WebAgg',
    1:                   'WX', 'WXAgg', 'WXCairo']
    1: non_interactive_bk = ['agg', 'cairo',
    1:                       'pdf', 'pgf', 'ps', 'svg', 'template']
    1: all_backends = interactive_bk + non_interactive_bk
       
       
    2: class ValidateInStrings(object):
    1:     def __init__(self, key, valid, ignorecase=False):
               'valid is a list of legal strings'
   26:         self.key = key
   26:         self.ignorecase = ignorecase
       
   26:         def func(s):
  174:             if ignorecase:
   87:                 return s.lower()
                   else:
   87:                 return s
  226:         self.valid = {func(k): k for k in valid}
       
    1:     def __call__(self, s):
   93:         if self.ignorecase:
   48:             s = s.lower()
   93:         if s in self.valid:
   93:             return self.valid[s]
               raise ValueError('Unrecognized %s string %r: valid strings are %s'
                                % (self.key, s, list(self.valid.values())))
       
       
    1: def _listify_validator(scalar_validator, allow_stringlist=False):
   12:     def f(s):
   81:         if isinstance(s, str):
                   try:
                       return [scalar_validator(v.strip()) for v in s.split(',')
                               if v.strip()]
                   except Exception:
                       if allow_stringlist:
                           # Sometimes, a list of colors might be a single string
                           # of single-letter colornames. So give that a shot.
                           return [scalar_validator(v.strip())
                                   for v in s if v.strip()]
                       else:
                           raise
               # We should allow any generic sequence type, including generators,
               # Numpy ndarrays, and pandas data structures.  However, unordered
               # sequences, such as sets, should be allowed but discouraged unless the
               # user desires pseudorandom behavior.
   81:         elif isinstance(s, Iterable) and not isinstance(s, Mapping):
                   # The condition on this list comprehension will preserve the
                   # behavior of filtering out any empty strings (behavior was
                   # from the original validate_stringlist()), while allowing
                   # any non-string/text scalar values such as numbers and arrays.
  438:             return [scalar_validator(v) for v in s
  276:                     if not isinstance(v, str) or v]
               else:
                   raise ValueError("{!r} must be of type: string or non-dictionary "
                                    "iterable".format(s))
   12:     try:
   12:         f.__name__ = "{}list".format(scalar_validator.__name__)
    4:     except AttributeError:  # class instance.
    4:         f.__name__ = "{}List".format(type(scalar_validator).__name__)
   12:     f.__doc__ = scalar_validator.__doc__
   12:     return f
       
       
    1: def validate_any(s):
    3:     return s
    1: validate_anylist = _listify_validator(validate_any)
       
       
    1: def validate_path_exists(s):
           """If s is a path, return s, else False"""
    3:     if s is None:
               return None
    3:     if os.path.exists(s):
    3:         return s
           else:
               raise RuntimeError('"%s" should be a path but it does not exist' % s)
       
       
    1: def validate_bool(b):
           """Convert b to a boolean or raise"""
  213:     if isinstance(b, str):
    3:         b = b.lower()
  213:     if b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True):
  129:         return True
   84:     elif b in ('f', 'n', 'no', 'off', 'false', '0', 0, False):
   81:         return False
           else:
    3:         raise ValueError('Could not convert "%s" to boolean' % b)
       
       
    1: def validate_bool_maybe_none(b):
           """Convert b to a boolean or raise."""
           if isinstance(b, str):
               b = b.lower()
           if b is None or b == 'none':
               return None
           if b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True):
               return True
           elif b in ('f', 'n', 'no', 'off', 'false', '0', 0, False):
               return False
           else:
               raise ValueError('Could not convert "%s" to boolean' % b)
       
       
    1: def validate_float(s):
           """Convert s to float or raise."""
  138:     try:
  138:         return float(s)
           except ValueError:
               raise ValueError('Could not convert "%s" to float' % s)
    1: validate_floatlist = _listify_validator(validate_float)
       
       
    1: def validate_float_or_None(s):
           """Convert s to float, None or raise."""
           # values directly from the rc file can only be strings,
           # so we need to recognize the string "None" and convert
           # it into the object. We will be case-sensitive here to
           # avoid confusion between string values of 'none', which
           # can be a valid string value for some other parameters.
    3:     if s is None or s == 'None':
               return None
    3:     try:
    3:         return float(s)
           except ValueError:
               raise ValueError('Could not convert "%s" to float or None' % s)
       
       
    1: def validate_string_or_None(s):
           """Convert s to string or raise."""
    3:     if s is None:
    3:         return None
           try:
               return validate_string(s)
           except ValueError:
               raise ValueError('Could not convert "%s" to string' % s)
       
       
    1: def _validate_tex_preamble(s):
    6:     if s is None or s == 'None':
               return ""
    6:     try:
    6:         if isinstance(s, str):
    6:             return s
               elif isinstance(s, Iterable):
                   return '\n'.join(s)
               else:
                   raise TypeError
           except TypeError:
               raise ValueError('Could not convert "%s" to string' % s)
       
       
    1: def validate_axisbelow(s):
    3:     try:
    3:         return validate_bool(s)
    3:     except ValueError:
    3:         if isinstance(s, str):
    3:             s = s.lower()
    3:             if s.startswith('line'):
    3:                 return 'line'
           raise ValueError('%s cannot be interpreted as'
                            ' True, False, or "line"' % s)
       
       
    1: def validate_dpi(s):
           """Confirm s is string 'figure' or convert s to float or raise."""
    3:     if s == 'figure':
    3:         return s
           try:
               return float(s)
           except ValueError:
               raise ValueError('"%s" is not string "figure" or'
                   ' could not convert "%s" to float' % (s, s))
       
       
    1: def validate_int(s):
           """Convert s to int or raise."""
   48:     try:
   48:         return int(s)
           except ValueError:
               raise ValueError('Could not convert "%s" to int' % s)
       
       
    1: def validate_int_or_None(s):
           """Return None if s is None or return ``int(s)``, otherwise raise."""
    3:     if s == 'None':
               s = None
    3:     if s is None:
    3:         return None
           try:
               return int(s)
           except ValueError:
               raise ValueError('Could not convert "%s" to int' % s)
       
       
    1: def validate_fonttype(s):
           """
           Confirm that this is a Postscript or PDF font type that we know how to
           convert to.
           """
    6:     fonttypes = {'type3':    3,
    6:                  'truetype': 42}
    6:     try:
    6:         fonttype = validate_int(s)
           except ValueError:
               try:
                   return fonttypes[s.lower()]
               except KeyError:
                   raise ValueError(
                       'Supported Postscript/PDF font types are %s' % list(fonttypes))
           else:
    6:         if fonttype not in fonttypes.values():
                   raise ValueError(
                       'Supported Postscript/PDF font types are %s' %
                       list(fonttypes.values()))
    6:         return fonttype
       
       
    1: _validate_standard_backends = ValidateInStrings(
    1:     'backend', all_backends, ignorecase=True)
    1: _auto_backend_sentinel = object()
       
       
    1: def validate_backend(s):
           backend = (
    3:         s if s is _auto_backend_sentinel or s.startswith("module://")
               else _validate_standard_backends(s))
    3:     return backend
       
       
    1: @cbook.deprecated("3.1")
       def validate_qt4(s):
           if s is None:
               return None
           return ValidateInStrings("backend.qt4", ['PyQt4', 'PySide', 'PyQt4v2'])(s)
       
       
    1: @cbook.deprecated("3.1")
       def validate_qt5(s):
           if s is None:
               return None
           return ValidateInStrings("backend.qt5", ['PyQt5', 'PySide2'])(s)
       
       
    1: def validate_toolbar(s):
    3:     validator = ValidateInStrings(
    3:                 'toolbar',
    3:                 ['None', 'toolbar2', 'toolmanager'],
    3:                 ignorecase=True)
    3:     return validator(s)
       
       
    1: _seq_err_msg = ('You must supply exactly {n} values, you provided {num} '
                       'values: {s}')
       
    1: _str_err_msg = ('You must supply exactly {n} comma-separated values, you '
                       'provided {num} comma-separated values: {s}')
       
       
    2: class validate_nseq_float(object):
    1:     def __init__(self, n=None, allow_none=False):
    8:         self.n = n
    8:         self.allow_none = allow_none
       
    1:     def __call__(self, s):
               """Return a list of *n* floats or raise."""
   15:         if isinstance(s, str):
                   s = [x.strip() for x in s.split(',')]
                   err_msg = _str_err_msg
               else:
   15:             err_msg = _seq_err_msg
       
   15:         if self.n is not None and len(s) != self.n:
                   raise ValueError(err_msg.format(n=self.n, num=len(s), s=s))
       
   12:         try:
   54:             return [float(val)
                           if not self.allow_none or val is not None
                           else val
   42:                     for val in s]
               except ValueError:
                   raise ValueError('Could not convert all entries to floats')
       
       
    2: class validate_nseq_int(object):
    1:     def __init__(self, n=None):
    1:         self.n = n
       
    1:     def __call__(self, s):
               """Return a list of *n* ints or raise."""
    3:         if isinstance(s, str):
                   s = [x.strip() for x in s.split(',')]
                   err_msg = _str_err_msg
               else:
    3:             err_msg = _seq_err_msg
       
    3:         if self.n is not None and len(s) != self.n:
                   raise ValueError(err_msg.format(n=self.n, num=len(s), s=s))
       
    3:         try:
   12:             return [int(val) for val in s]
               except ValueError:
                   raise ValueError('Could not convert all entries to ints')
       
       
    1: def validate_color_or_inherit(s):
           """Return a valid color arg."""
    6:     if s == 'inherit':
    3:         return s
    3:     return validate_color(s)
       
       
    1: def validate_color_or_auto(s):
    9:     if s == 'auto':
    6:         return s
    3:     return validate_color(s)
       
       
    1: def validate_color_for_prop_cycle(s):
           # Special-case the N-th color cycle syntax, this obviously can not
           # go in the color cycle.
   30:     if isinstance(s, bytes):
               match = re.match(b'^C[0-9]$', s)
               if match is not None:
                   raise ValueError('Can not put cycle reference ({cn!r}) in '
                                    'prop_cycler'.format(cn=s))
   30:     elif isinstance(s, str):
   30:         match = re.match('^C[0-9]$', s)
   30:         if match is not None:
                   raise ValueError('Can not put cycle reference ({cn!r}) in '
                                    'prop_cycler'.format(cn=s))
   30:     return validate_color(s)
       
       
    1: def validate_color(s):
           """Return a valid color arg."""
  108:     try:
  108:         if s.lower() == 'none':
    3:             return 'none'
           except AttributeError:
               pass
       
  105:     if isinstance(s, str):
  105:         if len(s) == 6 or len(s) == 8:
                   stmp = '#' + s
                   if is_color_like(stmp):
                       return stmp
       
  105:     if is_color_like(s):
  105:         return s
       
           # If it is still valid, it must be a tuple.
           colorarg = s
           msg = ''
           if s.find(',') >= 0:
               # get rid of grouping symbols
               stmp = ''.join([c for c in s if c.isdigit() or c == '.' or c == ','])
               vals = stmp.split(',')
               if len(vals) not in [3, 4]:
                   msg = '\nColor tuples must be of length 3 or 4'
               else:
                   try:
                       colorarg = [float(val) for val in vals]
                   except ValueError:
                       msg = '\nCould not convert all entries to floats'
       
           if not msg and is_color_like(colorarg):
               return colorarg
       
           raise ValueError('%s does not look like a color arg%s' % (s, msg))
       
       
    1: validate_colorlist = _listify_validator(validate_color, allow_stringlist=True)
    1: validate_colorlist.__doc__ = 'return a list of colorspecs'
       
       
    1: def validate_string(s):
   87:     if isinstance(s, str):
               # Always leave str as str and unicode as unicode
   87:         return s
           else:
               return str(s)
       
       
    1: validate_stringlist = _listify_validator(str)
    1: validate_stringlist.__doc__ = 'return a list'
       
    1: validate_orientation = ValidateInStrings(
    1:     'orientation', ['landscape', 'portrait'])
       
       
    1: def validate_aspect(s):
    3:     if s in ('auto', 'equal'):
    3:         return s
           try:
               return float(s)
           except ValueError:
               raise ValueError('not a valid aspect specification')
       
       
    1: def validate_fontsize_None(s):
    3:     if s is None or s == 'None':
    3:         return None
           else:
               return validate_fontsize(s)
       
       
    1: def validate_fontsize(s):
   18:     fontsizes = ['xx-small', 'x-small', 'small', 'medium', 'large',
   18:                  'x-large', 'xx-large', 'smaller', 'larger']
   18:     if isinstance(s, str):
   18:         s = s.lower()
   18:     if s in fontsizes:
   18:         return s
           try:
               return float(s)
           except ValueError:
               raise ValueError("%s is not a valid font size. Valid font sizes "
                                "are %s." % (s, ", ".join(fontsizes)))
       
       
    1: validate_fontsizelist = _listify_validator(validate_fontsize)
       
       
    1: def validate_font_properties(s):
   18:     parse_fontconfig_pattern(s)
   18:     return s
       
       
    1: validate_fontset = ValidateInStrings(
    1:     'fontset',
    1:     ['dejavusans', 'dejavuserif', 'cm', 'stix', 'stixsans', 'custom'])
       
       
    1: def validate_mathtext_default(s):
    3:     if s == "circled":
               cbook.warn_deprecated(
                   "3.1", message="Support for setting the mathtext.default rcParam "
                   "to 'circled' is deprecated since %(since)s and will be removed "
                   "%(removal)s.")
    3:     return ValidateInStrings(
    3:         'default',
    3:         "rm cal it tt sf bf default bb frak circled scr regular".split())(s)
       
       
    1: _validate_alignment = ValidateInStrings(
    1:     'alignment',
    1:     ['center', 'top', 'bottom', 'baseline',
    1:      'center_baseline'])
       
       
    1: _validate_verbose = ValidateInStrings(
    1:     'verbose',
    1:     ['silent', 'helpful', 'debug', 'debug-annoying'])
       
       
    1: @cbook.deprecated("3.1")
       def validate_verbose(s):
           return _validate_verbose(s)
       
       
    1: def validate_whiskers(s):
    3:     if s == 'range':
               return 'range'
           else:
    3:         try:
    3:             v = validate_nseq_float(2)(s)
                   return v
    3:         except (TypeError, ValueError):
    3:             try:
    3:                 v = float(s)
    3:                 return v
                   except ValueError:
                       raise ValueError("Not a valid whisker value ['range', float, "
                                        "(float, float)]")
       
       
    1: def update_savefig_format(value):
           # The old savefig.extension could also have a value of "auto", but
           # the new savefig.format does not.  We need to fix this here.
    3:     value = validate_string(value)
    3:     if value == 'auto':
               value = 'png'
    3:     return value
       
       
    1: validate_ps_papersize = ValidateInStrings(
    1:     'ps_papersize',
    1:     ['auto', 'letter', 'legal', 'ledger',
    1:     'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'a10',
    1:     'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'b10',
    1:     ], ignorecase=True)
       
       
    1: def validate_ps_distiller(s):
    4:     if isinstance(s, str):
               s = s.lower()
    4:     if s in ('none', None):
               return None
    4:     elif s in ('false', False):
    4:         return False
           elif s in ('ghostscript', 'xpdf'):
               return s
           else:
               raise ValueError('matplotlibrc ps.usedistiller must either be none, '
                                'ghostscript or xpdf')
       
       
    1: validate_joinstyle = ValidateInStrings('joinstyle',
    1:                                        ['miter', 'round', 'bevel'],
    1:                                        ignorecase=True)
    1: validate_joinstylelist = _listify_validator(validate_joinstyle)
       
    1: validate_capstyle = ValidateInStrings('capstyle',
    1:                                       ['butt', 'round', 'projecting'],
    1:                                       ignorecase=True)
    1: validate_capstylelist = _listify_validator(validate_capstyle)
       
    1: validate_fillstyle = ValidateInStrings('markers.fillstyle',
    1:                                        ['full', 'left', 'right', 'bottom',
    1:                                         'top', 'none'])
    1: validate_fillstylelist = _listify_validator(validate_fillstyle)
       
    1: _validate_negative_linestyle = ValidateInStrings('negative_linestyle',
    1:                                                  ['solid', 'dashed'],
    1:                                                  ignorecase=True)
       
       
    1: def validate_markevery(s):
           """
           Validate the markevery property of a Line2D object.
       
           Parameters
           ----------
           s : None, int, float, slice, length-2 tuple of ints,
               length-2 tuple of floats, list of ints
       
           Returns
           -------
           s : None, int, float, slice, length-2 tuple of ints,
               length-2 tuple of floats, list of ints
       
           """
           # Validate s against type slice
           if isinstance(s, slice):
               return s
           # Validate s against type tuple
           if isinstance(s, tuple):
               tupMaxLength = 2
               tupType = type(s[0])
               if len(s) != tupMaxLength:
                   raise TypeError("'markevery' tuple must have a length of "
                                   "%d" % (tupMaxLength))
               if tupType is int and not all(isinstance(e, int) for e in s):
                   raise TypeError("'markevery' tuple with first element of "
                                   "type int must have all elements of type "
                                   "int")
               if tupType is float and not all(isinstance(e, float) for e in s):
                   raise TypeError("'markevery' tuple with first element of "
                                   "type float must have all elements of type "
                                   "float")
               if tupType is not float and tupType is not int:
                   raise TypeError("'markevery' tuple contains an invalid type")
           # Validate s against type list
           elif isinstance(s, list):
               if not all(isinstance(e, int) for e in s):
                   raise TypeError("'markevery' list must have all elements of "
                                   "type int")
           # Validate s against type float int and None
           elif not isinstance(s, (float, int)):
               if s is not None:
                   raise TypeError("'markevery' is of an invalid type")
       
           return s
       
       
    1: validate_markeverylist = _listify_validator(validate_markevery)
       
    1: validate_legend_loc = ValidateInStrings(
    1:     'legend_loc',
    1:     ['best',
    1:      'upper right',
    1:      'upper left',
    1:      'lower left',
    1:      'lower right',
    1:      'right',
    1:      'center left',
    1:      'center right',
    1:      'lower center',
    1:      'upper center',
    1:      'center'], ignorecase=True)
       
       
    1: def validate_svg_fonttype(s):
    3:     if s in ["none", "path"]:
    3:         return s
           raise ValueError("Unrecognized svg.fonttype string '{}'; "
                            "valid strings are 'none', 'path'")
       
       
    1: def validate_hinting(s):
    3:     if s in (True, False):
               return s
    3:     if s.lower() in ('auto', 'native', 'either', 'none'):
    3:         return s.lower()
           raise ValueError("hinting should be 'auto', 'native', 'either' or 'none'")
       
       
    1: validate_pgf_texsystem = ValidateInStrings('pgf.texsystem',
    1:                                            ['xelatex', 'lualatex', 'pdflatex'])
       
    1: validate_movie_writer = ValidateInStrings('animation.writer',
    1:     ['ffmpeg', 'ffmpeg_file',
    1:      'avconv', 'avconv_file',
    1:      'imagemagick', 'imagemagick_file',
    1:      'html'])
       
    1: validate_movie_frame_fmt = ValidateInStrings('animation.frame_format',
    1:     ['png', 'jpeg', 'tiff', 'raw', 'rgba'])
       
    1: validate_axis_locator = ValidateInStrings('major', ['minor', 'both', 'major'])
       
    1: validate_movie_html_fmt = ValidateInStrings('animation.html',
    1:     ['html5', 'jshtml', 'none'])
       
       
    1: def validate_bbox(s):
    3:     if isinstance(s, str):
    2:         s = s.lower()
    2:         if s == 'tight':
                   return s
    2:         if s == 'standard':
    2:             return None
               raise ValueError("bbox should be 'tight' or 'standard'")
    1:     elif s is not None:
               # Backwards compatibility. None is equivalent to 'standard'.
               raise ValueError("bbox should be 'tight' or 'standard'")
    1:     return s
       
       
    1: def validate_sketch(s):
    3:     if isinstance(s, str):
               s = s.lower()
    3:     if s == 'none' or s is None:
    3:         return None
           if isinstance(s, str):
               result = tuple([float(v.strip()) for v in s.split(',')])
           elif isinstance(s, (list, tuple)):
               result = tuple([float(v) for v in s])
           if len(result) != 3:
               raise ValueError("path.sketch must be a tuple (scale, length, randomness)")
           return result
       
       
    2: class ValidateInterval(object):
           """
           Value must be in interval
    1:     """
    1:     def __init__(self, vmin, vmax, closedmin=True, closedmax=True):
   11:         self.vmin = vmin
   11:         self.vmax = vmax
   11:         self.cmin = closedmin
   11:         self.cmax = closedmax
       
    1:     def __call__(self, s):
   33:         try:
   33:             s = float(s)
               except ValueError:
                   raise RuntimeError('Value must be a float; found "%s"' % s)
       
   33:         if self.cmin and s < self.vmin:
                   raise RuntimeError('Value must be >= %f; found "%f"' %
                                      (self.vmin, s))
   33:         elif not self.cmin and s <= self.vmin:
                   raise RuntimeError('Value must be > %f; found "%f"' %
                                      (self.vmin, s))
       
   33:         if self.cmax and s > self.vmax:
                   raise RuntimeError('Value must be <= %f; found "%f"' %
                                      (self.vmax, s))
   33:         elif not self.cmax and s >= self.vmax:
                   raise RuntimeError('Value must be < %f; found "%f"' %
                                      (self.vmax, s))
   33:         return s
       
       
    1: validate_grid_axis = ValidateInStrings('axes.grid.axis', ['x', 'y', 'both'])
       
       
    1: def validate_hatch(s):
           """
           Validate a hatch pattern.
           A hatch pattern string can have any sequence of the following
           characters: ``\\ / | - + * . x o O``.
       
           """
           if not isinstance(s, str):
               raise ValueError("Hatch pattern must be a string")
           unknown = set(s) - {'\\', '/', '|', '-', '+', '*', '.', 'x', 'o', 'O'}
           if unknown:
               raise ValueError("Unknown hatch symbol(s): %s" % list(unknown))
           return s
       
       
    1: validate_hatchlist = _listify_validator(validate_hatch)
    1: validate_dashlist = _listify_validator(validate_nseq_float(allow_none=True))
       
       
       _prop_validators = {
    1:         'color': _listify_validator(validate_color_for_prop_cycle,
    1:                                     allow_stringlist=True),
    1:         'linewidth': validate_floatlist,
    1:         'linestyle': validate_stringlist,
    1:         'facecolor': validate_colorlist,
    1:         'edgecolor': validate_colorlist,
    1:         'joinstyle': validate_joinstylelist,
    1:         'capstyle': validate_capstylelist,
    1:         'fillstyle': validate_fillstylelist,
    1:         'markerfacecolor': validate_colorlist,
    1:         'markersize': validate_floatlist,
    1:         'markeredgewidth': validate_floatlist,
    1:         'markeredgecolor': validate_colorlist,
    1:         'markevery': validate_markeverylist,
    1:         'alpha': validate_floatlist,
    1:         'marker': validate_stringlist,
    1:         'hatch': validate_hatchlist,
    1:         'dashes': validate_dashlist,
           }
       _prop_aliases = {
    1:         'c': 'color',
    1:         'lw': 'linewidth',
    1:         'ls': 'linestyle',
    1:         'fc': 'facecolor',
    1:         'ec': 'edgecolor',
    1:         'mfc': 'markerfacecolor',
    1:         'mec': 'markeredgecolor',
    1:         'mew': 'markeredgewidth',
    1:         'ms': 'markersize',
           }
       
       
    1: def cycler(*args, **kwargs):
           """
           Creates a `~cycler.Cycler` object much like :func:`cycler.cycler`,
           but includes input validation.
       
           Call signatures::
       
             cycler(cycler)
             cycler(label=values[, label2=values2[, ...]])
             cycler(label, values)
       
           Form 1 copies a given `~cycler.Cycler` object.
       
           Form 2 creates a `~cycler.Cycler` which cycles over one or more
           properties simultaneously. If multiple properties are given, their
           value lists must have the same length.
       
           Form 3 creates a `~cycler.Cycler` for a single property. This form
           exists for compatibility with the original cycler. Its use is
           discouraged in favor of the kwarg form, i.e. ``cycler(label=values)``.
       
           Parameters
           ----------
           cycler : Cycler
               Copy constructor for Cycler.
       
           label : str
               The property key. Must be a valid `.Artist` property.
               For example, 'color' or 'linestyle'. Aliases are allowed,
               such as 'c' for 'color' and 'lw' for 'linewidth'.
       
           values : iterable
               Finite-length iterable of the property values. These values
               are validated and will raise a ValueError if invalid.
       
           Returns
           -------
           cycler : Cycler
               A new :class:`~cycler.Cycler` for the given properties.
       
           Examples
           --------
           Creating a cycler for a single property:
       
           >>> c = cycler(color=['red', 'green', 'blue'])
       
           Creating a cycler for simultaneously cycling over multiple properties
           (e.g. red circle, green plus, blue cross):
       
           >>> c = cycler(color=['red', 'green', 'blue'],
           ...            marker=['o', '+', 'x'])
       
           """
           if args and kwargs:
               raise TypeError("cycler() can only accept positional OR keyword "
                               "arguments -- not both.")
           elif not args and not kwargs:
               raise TypeError("cycler() must have positional OR keyword arguments")
       
           if len(args) == 1:
               if not isinstance(args[0], Cycler):
                   raise TypeError("If only one positional argument given, it must "
                                   " be a Cycler instance.")
               return validate_cycler(args[0])
           elif len(args) == 2:
               pairs = [(args[0], args[1])]
           elif len(args) > 2:
               raise TypeError("No more than 2 positional arguments allowed")
           else:
               pairs = kwargs.items()
       
           validated = []
           for prop, vals in pairs:
               norm_prop = _prop_aliases.get(prop, prop)
               validator = _prop_validators.get(norm_prop, None)
               if validator is None:
                   raise TypeError("Unknown artist property: %s" % prop)
               vals = validator(vals)
               # We will normalize the property names as well to reduce
               # the amount of alias handling code elsewhere.
               validated.append((norm_prop, vals))
       
           return reduce(operator.add, (ccycler(k, v) for k, v in validated))
       
       
    1: def validate_cycler(s):
           """Return a Cycler object from a string repr or the object itself."""
    3:     if isinstance(s, str):
               try:
                   # TODO: We might want to rethink this...
                   # While I think I have it quite locked down,
                   # it is execution of arbitrary code without
                   # sanitation.
                   # Combine this with the possibility that rcparams
                   # might come from the internet (future plans), this
                   # could be downright dangerous.
                   # I locked it down by only having the 'cycler()' function
                   # available.
                   # UPDATE: Partly plugging a security hole.
                   # I really should have read this:
                   # http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
                   # We should replace this eval with a combo of PyParsing and
                   # ast.literal_eval()
                   if '.__' in s.replace(' ', ''):
                       raise ValueError("'%s' seems to have dunder methods. Raising"
                                        " an exception for your safety")
                   s = eval(s, {'cycler': cycler, '__builtins__': {}})
               except BaseException as e:
                   raise ValueError("'%s' is not a valid cycler construction: %s" %
                                    (s, e))
           # Should make sure what comes from the above eval()
           # is a Cycler object.
    3:     if isinstance(s, Cycler):
    3:         cycler_inst = s
           else:
               raise ValueError("object was not a string or Cycler instance: %s" % s)
       
    3:     unknowns = cycler_inst.keys - (set(_prop_validators) | set(_prop_aliases))
    3:     if unknowns:
               raise ValueError("Unknown artist properties: %s" % unknowns)
       
           # Not a full validation, but it'll at least normalize property names
           # A fuller validation would require v0.10 of cycler.
    3:     checker = set()
    6:     for prop in cycler_inst.keys:
    3:         norm_prop = _prop_aliases.get(prop, prop)
    3:         if norm_prop != prop and norm_prop in cycler_inst.keys:
                   raise ValueError("Cannot specify both '{0}' and alias '{1}'"
                                    " in the same prop_cycle".format(norm_prop, prop))
    3:         if norm_prop in checker:
                   raise ValueError("Another property was already aliased to '{0}'."
                                    " Collision normalizing '{1}'.".format(norm_prop,
                                                                           prop))
    3:         checker.update([norm_prop])
       
           # This is just an extra-careful check, just in case there is some
           # edge-case I haven't thought of.
    3:     assert len(checker) == len(cycler_inst.keys)
       
           # Now, it should be safe to mutate this cycler
    6:     for prop in cycler_inst.keys:
    3:         norm_prop = _prop_aliases.get(prop, prop)
    3:         cycler_inst.change_key(prop, norm_prop)
       
    6:     for key, vals in cycler_inst.by_key().items():
    3:         _prop_validators[key](vals)
       
    3:     return cycler_inst
       
       
    1: def validate_hist_bins(s):
    3:     valid_strs = ["auto", "sturges", "fd", "doane", "scott", "rice", "sqrt"]
    3:     if isinstance(s, str) and s in valid_strs:
               return s
    3:     try:
    3:         return int(s)
           except (TypeError, ValueError):
               pass
           try:
               return validate_floatlist(s)
           except ValueError:
               pass
           raise ValueError("'hist.bins' must be one of {}, an int or"
                            " a sequence of floats".format(valid_strs))
       
       
    1: def validate_animation_writer_path(p):
           # Make sure it's a string and then figure out if the animations
           # are already loaded and reset the writers (which will validate
           # the path on next call)
    9:     if not isinstance(p, str):
               raise ValueError("path must be a (unicode) string")
    9:     from sys import modules
           # set dirty, so that the next call to the registry will re-evaluate
           # the state.
           # only set dirty if already loaded. If not loaded, the load will
           # trigger the checks.
    9:     if "matplotlib.animation" in modules:
               modules["matplotlib.animation"].writers.set_dirty()
    9:     return p
       
       
    1: def validate_webagg_address(s):
    3:     if s is not None:
    3:         import socket
    3:         try:
    3:             socket.inet_aton(s)
               except socket.error as e:
                   raise ValueError("'webagg.address' is not a valid IP address")
    3:         return s
           raise ValueError("'webagg.address' is not a valid IP address")
       
       
       # A validator dedicated to the named line styles, based on the items in
       # ls_mapper, and a list of possible strings read from Line2D.set_linestyle
    1: _validate_named_linestyle = ValidateInStrings(
    1:     'linestyle',
    1:     [*ls_mapper.keys(), *ls_mapper.values(), 'None', 'none', ' ', ''],
    1:     ignorecase=True)
       
       
    1: def _validate_linestyle(ls):
           """
           A validator for all possible line styles, the named ones *and*
           the on-off ink sequences.
           """
           # Look first for a valid named line style, like '--' or 'solid' Also
           # includes bytes(-arrays) here (they all fail _validate_named_linestyle);
           # otherwise, if *ls* is of even-length, it will be passed to the instance
           # of validate_nseq_float, which will return an absurd on-off ink
           # sequence...
   27:     if isinstance(ls, (str, bytes, bytearray)):
   27:         return _validate_named_linestyle(ls)
       
           # Look for an on-off ink sequence (in points) *of even length*.
           # Offset is set to None.
           try:
               if len(ls) % 2 != 0:
                   raise ValueError("the linestyle sequence {!r} is not of even "
                                    "length.".format(ls))
       
               return (None, validate_nseq_float()(ls))
       
           except (ValueError, TypeError):
               # TypeError can be raised inside the instance of validate_nseq_float,
               # by wrong types passed to float(), like NoneType.
               raise ValueError("linestyle {!r} is not a valid on-off ink "
                                "sequence.".format(ls))
       
       
       # a map from key -> value, converter
       defaultParams = {
    1:     'backend':           [_auto_backend_sentinel, validate_backend],
    1:     'backend_fallback':  [True, validate_bool],
    1:     'webagg.port':       [8988, validate_int],
    1:     'webagg.address':    ['127.0.0.1', validate_webagg_address],
    1:     'webagg.open_in_browser': [True, validate_bool],
    1:     'webagg.port_retries': [50, validate_int],
    1:     'toolbar':           ['toolbar2', validate_toolbar],
    1:     'datapath':          [None, validate_path_exists],  # handled by
                                                               # _get_data_path_cached
    1:     'interactive':       [False, validate_bool],
    1:     'timezone':          ['UTC', validate_string],
       
           # the verbosity setting
    1:     'verbose.level': ['silent', _validate_verbose],
    1:     'verbose.fileo': ['sys.stdout', validate_string],
       
           # line props
    1:     'lines.linewidth':       [1.5, validate_float],  # line width in points
    1:     'lines.linestyle':       ['-', _validate_linestyle],  # solid line
    1:     'lines.color':           ['C0', validate_color],  # first color in color cycle
    1:     'lines.marker':          ['None', validate_string],  # marker name
    1:     'lines.markerfacecolor': ['auto', validate_color_or_auto],  # default color
    1:     'lines.markeredgecolor': ['auto', validate_color_or_auto],  # default color
    1:     'lines.markeredgewidth': [1.0, validate_float],
    1:     'lines.markersize':      [6, validate_float],    # markersize, in points
    1:     'lines.antialiased':     [True, validate_bool],  # antialiased (no jaggies)
    1:     'lines.dash_joinstyle':  ['round', validate_joinstyle],
    1:     'lines.solid_joinstyle': ['round', validate_joinstyle],
    1:     'lines.dash_capstyle':   ['butt', validate_capstyle],
    1:     'lines.solid_capstyle':  ['projecting', validate_capstyle],
    1:     'lines.dashed_pattern':  [[3.7, 1.6], validate_nseq_float(allow_none=True)],
    1:     'lines.dashdot_pattern': [[6.4, 1.6, 1, 1.6],
    1:                               validate_nseq_float(allow_none=True)],
    1:     'lines.dotted_pattern':  [[1, 1.65], validate_nseq_float(allow_none=True)],
    1:     'lines.scale_dashes':  [True, validate_bool],
       
           # marker props
    1:     'markers.fillstyle': ['full', validate_fillstyle],
       
           ## patch props
    1:     'patch.linewidth':   [1.0, validate_float],     # line width in points
    1:     'patch.edgecolor':   ['black', validate_color],
    1:     'patch.force_edgecolor': [False, validate_bool],
    1:     'patch.facecolor':   ['C0', validate_color],    # first color in cycle
    1:     'patch.antialiased': [True, validate_bool],     # antialiased (no jaggies)
       
           ## hatch props
    1:     'hatch.color': ['black', validate_color],
    1:     'hatch.linewidth': [1.0, validate_float],
       
           ## Histogram properties
    1:     'hist.bins': [10, validate_hist_bins],
       
           ## Boxplot properties
    1:     'boxplot.notch': [False, validate_bool],
    1:     'boxplot.vertical': [True, validate_bool],
    1:     'boxplot.whiskers': [1.5, validate_whiskers],
    1:     'boxplot.bootstrap': [None, validate_int_or_None],
    1:     'boxplot.patchartist': [False, validate_bool],
    1:     'boxplot.showmeans': [False, validate_bool],
    1:     'boxplot.showcaps': [True, validate_bool],
    1:     'boxplot.showbox': [True, validate_bool],
    1:     'boxplot.showfliers': [True, validate_bool],
    1:     'boxplot.meanline': [False, validate_bool],
       
    1:     'boxplot.flierprops.color': ['black', validate_color],
    1:     'boxplot.flierprops.marker': ['o', validate_string],
    1:     'boxplot.flierprops.markerfacecolor': ['none', validate_color_or_auto],
    1:     'boxplot.flierprops.markeredgecolor': ['black', validate_color],
    1:     'boxplot.flierprops.markeredgewidth': [1.0, validate_float],
    1:     'boxplot.flierprops.markersize': [6, validate_float],
    1:     'boxplot.flierprops.linestyle': ['none', _validate_linestyle],
    1:     'boxplot.flierprops.linewidth': [1.0, validate_float],
       
    1:     'boxplot.boxprops.color': ['black', validate_color],
    1:     'boxplot.boxprops.linewidth': [1.0, validate_float],
    1:     'boxplot.boxprops.linestyle': ['-', _validate_linestyle],
       
    1:     'boxplot.whiskerprops.color': ['black', validate_color],
    1:     'boxplot.whiskerprops.linewidth': [1.0, validate_float],
    1:     'boxplot.whiskerprops.linestyle': ['-', _validate_linestyle],
       
    1:     'boxplot.capprops.color': ['black', validate_color],
    1:     'boxplot.capprops.linewidth': [1.0, validate_float],
    1:     'boxplot.capprops.linestyle': ['-', _validate_linestyle],
       
    1:     'boxplot.medianprops.color': ['C1', validate_color],
    1:     'boxplot.medianprops.linewidth': [1.0, validate_float],
    1:     'boxplot.medianprops.linestyle': ['-', _validate_linestyle],
       
    1:     'boxplot.meanprops.color': ['C2', validate_color],
    1:     'boxplot.meanprops.marker': ['^', validate_string],
    1:     'boxplot.meanprops.markerfacecolor': ['C2', validate_color],
    1:     'boxplot.meanprops.markeredgecolor': ['C2', validate_color],
    1:     'boxplot.meanprops.markersize': [6, validate_float],
    1:     'boxplot.meanprops.linestyle': ['--', _validate_linestyle],
    1:     'boxplot.meanprops.linewidth': [1.0, validate_float],
       
           ## font props
    1:     'font.family':     [['sans-serif'], validate_stringlist],  # used by text object
    1:     'font.style':      ['normal', validate_string],
    1:     'font.variant':    ['normal', validate_string],
    1:     'font.stretch':    ['normal', validate_string],
    1:     'font.weight':     ['normal', validate_string],
    1:     'font.size':       [10, validate_float],      # Base font size in points
    1:     'font.serif':      [['DejaVu Serif', 'Bitstream Vera Serif',
    1:                          'Computer Modern Roman',
    1:                          'New Century Schoolbook', 'Century Schoolbook L',
    1:                          'Utopia', 'ITC Bookman', 'Bookman',
    1:                          'Nimbus Roman No9 L', 'Times New Roman',
    1:                          'Times', 'Palatino', 'Charter', 'serif'],
    1:                         validate_stringlist],
    1:     'font.sans-serif': [['DejaVu Sans', 'Bitstream Vera Sans',
    1:                          'Computer Modern Sans Serif',
    1:                          'Lucida Grande', 'Verdana', 'Geneva', 'Lucid',
    1:                          'Arial', 'Helvetica', 'Avant Garde', 'sans-serif'],
    1:                         validate_stringlist],
    1:     'font.cursive':    [['Apple Chancery', 'Textile', 'Zapf Chancery',
    1:                          'Sand', 'Script MT', 'Felipa', 'cursive'],
    1:                         validate_stringlist],
    1:     'font.fantasy':    [['Comic Sans MS', 'Chicago', 'Charcoal', 'Impact',
    1:                          'Western', 'Humor Sans', 'xkcd', 'fantasy'],
    1:                         validate_stringlist],
    1:     'font.monospace':  [['DejaVu Sans Mono', 'Bitstream Vera Sans Mono',
    1:                          'Computer Modern Typewriter',
    1:                          'Andale Mono', 'Nimbus Mono L', 'Courier New',
    1:                          'Courier', 'Fixed', 'Terminal', 'monospace'],
    1:                         validate_stringlist],
       
           # text props
    1:     'text.color':          ['black', validate_color],
    1:     'text.usetex':         [False, validate_bool],
    1:     'text.latex.unicode':  [True, validate_bool],
    1:     'text.latex.preamble': ['', _validate_tex_preamble],
    1:     'text.latex.preview':  [False, validate_bool],
    1:     'text.hinting':        ['auto', validate_hinting],
    1:     'text.hinting_factor': [8, validate_int],
    1:     'text.antialiased':    [True, validate_bool],
       
    1:     'mathtext.cal':            ['cursive', validate_font_properties],
    1:     'mathtext.rm':             ['sans', validate_font_properties],
    1:     'mathtext.tt':             ['monospace', validate_font_properties],
    1:     'mathtext.it':             ['sans:italic', validate_font_properties],
    1:     'mathtext.bf':             ['sans:bold', validate_font_properties],
    1:     'mathtext.sf':             ['sans', validate_font_properties],
    1:     'mathtext.fontset':        ['dejavusans', validate_fontset],
    1:     'mathtext.default':        ['it', validate_mathtext_default],
    1:     'mathtext.fallback_to_cm': [True, validate_bool],
       
    1:     'image.aspect':        ['equal', validate_aspect],  # equal, auto, a number
    1:     'image.interpolation': ['nearest', validate_string],
    1:     'image.cmap':          ['viridis', validate_string],  # gray, jet, etc.
    1:     'image.lut':           [256, validate_int],  # lookup table
    1:     'image.origin':        ['upper',
    1:                             ValidateInStrings('image.origin', ['upper', 'lower'])],
    1:     'image.resample':      [True, validate_bool],
           # Specify whether vector graphics backends will combine all images on a
           # set of axes into a single composite image
    1:     'image.composite_image': [True, validate_bool],
       
           # contour props
    1:     'contour.negative_linestyle': ['dashed', _validate_linestyle],
    1:     'contour.corner_mask':        [True, validate_bool],
       
           # errorbar props
    1:     'errorbar.capsize':      [0, validate_float],
       
           # axes props
    1:     'axes.axisbelow':        ['line', validate_axisbelow],
    1:     'axes.facecolor':        ['white', validate_color],  # background color
    1:     'axes.edgecolor':        ['black', validate_color],  # edge color
    1:     'axes.linewidth':        [0.8, validate_float],  # edge linewidth
       
    1:     'axes.spines.left':      [True, validate_bool],  # Set visibility of axes
    1:     'axes.spines.right':     [True, validate_bool],  # 'spines', the lines
    1:     'axes.spines.bottom':    [True, validate_bool],  # around the chart
    1:     'axes.spines.top':       [True, validate_bool],  # denoting data boundary
       
    1:     'axes.titlesize':        ['large', validate_fontsize],  # fontsize of the
                                                                   # axes title
    1:     'axes.titleweight':      ['normal', validate_string],  # font weight of axes title
    1:     'axes.titlepad':         [6.0, validate_float],  # pad from axes top to title in points
    1:     'axes.grid':             [False, validate_bool],   # display grid or not
    1:     'axes.grid.which':       ['major', validate_axis_locator],  # set whether the gid are by
                                                                       # default draw on 'major'
                                                                       # 'minor' or 'both' kind of
                                                                       # axis locator
    1:     'axes.grid.axis':        ['both', validate_grid_axis],  # grid type:
                                                                   # 'x', 'y', or 'both'
    1:     'axes.labelsize':        ['medium', validate_fontsize],  # fontsize of the
                                                                    # x any y labels
    1:     'axes.labelpad':         [4.0, validate_float],  # space between label and axis
    1:     'axes.labelweight':      ['normal', validate_string],  # fontsize of the x any y labels
    1:     'axes.labelcolor':       ['black', validate_color],    # color of axis label
    1:     'axes.formatter.limits': [[-7, 7], validate_nseq_int(2)],
                                      # use scientific notation if log10
                                      # of the axis range is smaller than the
                                      # first or larger than the second
    1:     'axes.formatter.use_locale': [False, validate_bool],
                                      # Use the current locale to format ticks
    1:     'axes.formatter.use_mathtext': [False, validate_bool],
    1:     'axes.formatter.min_exponent': [0, validate_int],  # minimum exponent to format in scientific notation
    1:     'axes.formatter.useoffset': [True, validate_bool],
    1:     'axes.formatter.offset_threshold': [4, validate_int],
    1:     'axes.unicode_minus': [True, validate_bool],
           # This entry can be either a cycler object or a
           # string repr of a cycler-object, which gets eval()'ed
           # to create the object.
           'axes.prop_cycle': [
    1:         ccycler('color',
    1:                 ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',
    1:                  '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
    1:                  '#bcbd22', '#17becf']),
    1:         validate_cycler],
           # If 'data', axes limits are set close to the data.
           # If 'round_numbers' axes limits are set to the nearest round numbers.
           'axes.autolimit_mode': [
    1:         'data',
    1:         ValidateInStrings('autolimit_mode', ['data', 'round_numbers'])],
    1:     'axes.xmargin': [0.05, ValidateInterval(0, 1,
    1:                                             closedmin=True,
    1:                                             closedmax=True)],  # margin added to xaxis
    1:     'axes.ymargin': [0.05, ValidateInterval(0, 1,
    1:                                             closedmin=True,
    1:                                             closedmax=True)],  # margin added to yaxis
       
    1:     'polaraxes.grid': [True, validate_bool],  # display polar grid or
                                                            # not
    1:     'axes3d.grid': [True, validate_bool],  # display 3d grid
       
           # scatter props
    1:     'scatter.marker': ['o', validate_string],
    1:     'scatter.edgecolors': ['face', validate_string],
       
           # TODO validate that these are valid datetime format strings
    1:     'date.autoformatter.year': ['%Y', validate_string],
    1:     'date.autoformatter.month': ['%Y-%m', validate_string],
    1:     'date.autoformatter.day': ['%Y-%m-%d', validate_string],
    1:     'date.autoformatter.hour': ['%m-%d %H', validate_string],
    1:     'date.autoformatter.minute': ['%d %H:%M', validate_string],
    1:     'date.autoformatter.second': ['%H:%M:%S', validate_string],
    1:     'date.autoformatter.microsecond': ['%M:%S.%f', validate_string],
       
           #legend properties
    1:     'legend.fancybox': [True, validate_bool],
    1:     'legend.loc': ['best', validate_legend_loc],
           # the number of points in the legend line
    1:     'legend.numpoints': [1, validate_int],
           # the number of points in the legend line for scatter
    1:     'legend.scatterpoints': [1, validate_int],
    1:     'legend.fontsize': ['medium', validate_fontsize],
    1:     'legend.title_fontsize': [None, validate_fontsize_None],
            # the relative size of legend markers vs. original
    1:     'legend.markerscale': [1.0, validate_float],
    1:     'legend.shadow': [False, validate_bool],
            # whether or not to draw a frame around legend
    1:     'legend.frameon': [True, validate_bool],
            # alpha value of the legend frame
    1:     'legend.framealpha': [0.8, validate_float_or_None],
       
           ## the following dimensions are in fraction of the font size
    1:     'legend.borderpad': [0.4, validate_float],  # units are fontsize
           # the vertical space between the legend entries
    1:     'legend.labelspacing': [0.5, validate_float],
           # the length of the legend lines
    1:     'legend.handlelength': [2., validate_float],
           # the length of the legend lines
    1:     'legend.handleheight': [0.7, validate_float],
           # the space between the legend line and legend text
    1:     'legend.handletextpad': [.8, validate_float],
           # the border between the axes and legend edge
    1:     'legend.borderaxespad': [0.5, validate_float],
           # the border between the axes and legend edge
    1:     'legend.columnspacing': [2., validate_float],
    1:     'legend.facecolor': ['inherit', validate_color_or_inherit],
    1:     'legend.edgecolor': ['0.8', validate_color_or_inherit],
       
           # tick properties
    1:     'xtick.top':         [False, validate_bool],   # draw ticks on the top side
    1:     'xtick.bottom':      [True, validate_bool],   # draw ticks on the bottom side
    1:     'xtick.labeltop':    [False, validate_bool],  # draw label on the top
    1:     'xtick.labelbottom': [True, validate_bool],  # draw label on the bottom
    1:     'xtick.major.size':  [3.5, validate_float],    # major xtick size in points
    1:     'xtick.minor.size':  [2, validate_float],    # minor xtick size in points
    1:     'xtick.major.width': [0.8, validate_float],  # major xtick width in points
    1:     'xtick.minor.width': [0.6, validate_float],  # minor xtick width in points
    1:     'xtick.major.pad':   [3.5, validate_float],    # distance to label in points
    1:     'xtick.minor.pad':   [3.4, validate_float],    # distance to label in points
    1:     'xtick.color':       ['black', validate_color],  # color of the xtick labels
    1:     'xtick.minor.visible':   [False, validate_bool],    # visibility of the x axis minor ticks
    1:     'xtick.minor.top':   [True, validate_bool],  # draw x axis top minor ticks
    1:     'xtick.minor.bottom':    [True, validate_bool],    # draw x axis bottom minor ticks
    1:     'xtick.major.top':   [True, validate_bool],  # draw x axis top major ticks
    1:     'xtick.major.bottom':    [True, validate_bool],    # draw x axis bottom major ticks
       
           # fontsize of the xtick labels
    1:     'xtick.labelsize':   ['medium', validate_fontsize],
    1:     'xtick.direction':   ['out', validate_string],            # direction of xticks
    1:     'xtick.alignment': ["center", _validate_alignment],
       
    1:     'ytick.left':        [True, validate_bool],  # draw ticks on the left side
    1:     'ytick.right':       [False, validate_bool],  # draw ticks on the right side
    1:     'ytick.labelleft':   [True, validate_bool],  # draw tick labels on the left side
    1:     'ytick.labelright':  [False, validate_bool],  # draw tick labels on the right side
    1:     'ytick.major.size':  [3.5, validate_float],     # major ytick size in points
    1:     'ytick.minor.size':  [2, validate_float],     # minor ytick size in points
    1:     'ytick.major.width': [0.8, validate_float],   # major ytick width in points
    1:     'ytick.minor.width': [0.6, validate_float],   # minor ytick width in points
    1:     'ytick.major.pad':   [3.5, validate_float],     # distance to label in points
    1:     'ytick.minor.pad':   [3.4, validate_float],     # distance to label in points
    1:     'ytick.color':       ['black', validate_color],   # color of the ytick labels
    1:     'ytick.minor.visible':   [False, validate_bool],    # visibility of the y axis minor ticks
    1:     'ytick.minor.left':   [True, validate_bool],  # draw y axis left minor ticks
    1:     'ytick.minor.right':    [True, validate_bool],    # draw y axis right minor ticks
    1:     'ytick.major.left':   [True, validate_bool],  # draw y axis left major ticks
    1:     'ytick.major.right':    [True, validate_bool],    # draw y axis right major ticks
       
           # fontsize of the ytick labels
    1:     'ytick.labelsize':   ['medium', validate_fontsize],
    1:     'ytick.direction':   ['out', validate_string],            # direction of yticks
    1:     'ytick.alignment': ["center_baseline", _validate_alignment],
       
    1:     'grid.color':        ['#b0b0b0', validate_color],  # grid color
    1:     'grid.linestyle':    ['-', _validate_linestyle],  # solid
    1:     'grid.linewidth':    [0.8, validate_float],     # in points
    1:     'grid.alpha':        [1.0, validate_float],
       
           ## figure props
           # figure title
    1:     'figure.titlesize':   ['large', validate_fontsize],
    1:     'figure.titleweight': ['normal', validate_string],
       
           # figure size in inches: width by height
    1:     'figure.figsize':    [[6.4, 4.8], validate_nseq_float(2)],
    1:     'figure.dpi':        [100, validate_float],  # DPI
    1:     'figure.facecolor':  ['white', validate_color],
    1:     'figure.edgecolor':  ['white', validate_color],
    1:     'figure.frameon':    [True, validate_bool],
    1:     'figure.autolayout': [False, validate_bool],
    1:     'figure.max_open_warning': [20, validate_int],
       
    1:     'figure.subplot.left': [0.125, ValidateInterval(0, 1, closedmin=True,
    1:                                                        closedmax=True)],
    1:     'figure.subplot.right': [0.9, ValidateInterval(0, 1, closedmin=True,
    1:                                                      closedmax=True)],
    1:     'figure.subplot.bottom': [0.11, ValidateInterval(0, 1, closedmin=True,
    1:                                                      closedmax=True)],
    1:     'figure.subplot.top': [0.88, ValidateInterval(0, 1, closedmin=True,
    1:                                                      closedmax=True)],
    1:     'figure.subplot.wspace': [0.2, ValidateInterval(0, 1, closedmin=True,
    1:                                                      closedmax=False)],
    1:     'figure.subplot.hspace': [0.2, ValidateInterval(0, 1, closedmin=True,
    1:                                                      closedmax=False)],
       
           # do constrained_layout.
    1:     'figure.constrained_layout.use': [False, validate_bool],
           # wspace and hspace are fraction of adjacent subplots to use
           # for space.  Much smaller than above because we don't need
           # room for the text.
    1:     'figure.constrained_layout.hspace': [0.02, ValidateInterval(
    1:             0, 1, closedmin=True, closedmax=False)],
    1:     'figure.constrained_layout.wspace': [0.02, ValidateInterval(
    1:             0, 1, closedmin=True, closedmax=False)],
           # This is a buffer around the axes in inches.  This is 3pts.
    1:     'figure.constrained_layout.h_pad': [0.04167, validate_float],
    1:     'figure.constrained_layout.w_pad': [0.04167, validate_float],
       
           ## Saving figure's properties
    1:     'savefig.dpi':         ['figure', validate_dpi],  # DPI
    1:     'savefig.facecolor':   ['white', validate_color],
    1:     'savefig.edgecolor':   ['white', validate_color],
    1:     'savefig.frameon':     [True, validate_bool],
    1:     'savefig.orientation': ['portrait', validate_orientation],
    1:     'savefig.jpeg_quality': [95, validate_int],
           # value checked by backend at runtime
    1:     'savefig.format':     ['png', update_savefig_format],
           # options are 'tight', or 'standard'. 'standard' validates to None.
    1:     'savefig.bbox':       ['standard', validate_bbox],
    1:     'savefig.pad_inches': [0.1, validate_float],
           # default directory in savefig dialog box
    1:     'savefig.directory': ['~', validate_string],
    1:     'savefig.transparent': [False, validate_bool],
       
           # Maintain shell focus for TkAgg
    1:     'tk.window_focus':  [False, validate_bool],
       
           # Set the papersize/type
    1:     'ps.papersize':     ['letter', validate_ps_papersize],
    1:     'ps.useafm':        [False, validate_bool],
           # use ghostscript or xpdf to distill ps output
    1:     'ps.usedistiller':  [False, validate_ps_distiller],
    1:     'ps.distiller.res': [6000, validate_int],     # dpi
    1:     'ps.fonttype':      [3, validate_fonttype],  # 3 (Type3) or 42 (Truetype)
           # compression level from 0 to 9; 0 to disable
    1:     'pdf.compression':  [6, validate_int],
           # ignore any color-setting commands from the frontend
    1:     'pdf.inheritcolor': [False, validate_bool],
           # use only the 14 PDF core fonts embedded in every PDF viewing application
    1:     'pdf.use14corefonts': [False, validate_bool],
    1:     'pdf.fonttype':     [3, validate_fonttype],  # 3 (Type3) or 42 (Truetype)
       
    1:     'pgf.debug':     [False, validate_bool],  # output debug information
           # choose latex application for creating pdf files (xelatex/lualatex)
    1:     'pgf.texsystem': ['xelatex', validate_pgf_texsystem],
           # use matplotlib rc settings for font configuration
    1:     'pgf.rcfonts':   [True, validate_bool],
           # provide a custom preamble for the latex process
    1:     'pgf.preamble':  ['', _validate_tex_preamble],
       
           # write raster image data directly into the svg file
    1:     'svg.image_inline':     [True, validate_bool],
           # True to save all characters as paths in the SVG
    1:     'svg.fonttype':         ['path', validate_svg_fonttype],
    1:     'svg.hashsalt':         [None, validate_string_or_None],
       
           # set this when you want to generate hardcopy docstring
    1:     'docstring.hardcopy': [False, validate_bool],
       
    1:     'path.simplify': [True, validate_bool],
    1:     'path.simplify_threshold': [1.0 / 9.0, ValidateInterval(0.0, 1.0)],
    1:     'path.snap': [True, validate_bool],
    1:     'path.sketch': [None, validate_sketch],
    1:     'path.effects': [[], validate_any],
    1:     'agg.path.chunksize': [0, validate_int],       # 0 to disable chunking;
       
           # key-mappings (multi-character mappings should be a list/tuple)
    1:     'keymap.fullscreen':   [['f', 'ctrl+f'], validate_stringlist],
    1:     'keymap.home':         [['h', 'r', 'home'], validate_stringlist],
    1:     'keymap.back':         [['left', 'c', 'backspace', 'MouseButton.BACK'],
    1:                             validate_stringlist],
    1:     'keymap.forward':      [['right', 'v', 'MouseButton.FORWARD'],
    1:                             validate_stringlist],
    1:     'keymap.pan':          [['p'], validate_stringlist],
    1:     'keymap.zoom':         [['o'], validate_stringlist],
    1:     'keymap.save':         [['s', 'ctrl+s'], validate_stringlist],
    1:     'keymap.quit':         [['ctrl+w', 'cmd+w', 'q'], validate_stringlist],
    1:     'keymap.quit_all':     [['W', 'cmd+W', 'Q'], validate_stringlist],
    1:     'keymap.grid':         [['g'], validate_stringlist],
    1:     'keymap.grid_minor':   [['G'], validate_stringlist],
    1:     'keymap.yscale':       [['l'], validate_stringlist],
    1:     'keymap.xscale':       [['k', 'L'], validate_stringlist],
    1:     'keymap.all_axes':     [['a'], validate_stringlist],
    1:     'keymap.help':         [['f1'], validate_stringlist],
    1:     'keymap.copy':         [['ctrl+c', 'cmd+c'], validate_stringlist],
       
           # sample data
    1:     'examples.directory': ['', validate_string],
       
           # Animation settings
    1:     'animation.html':         ['none', validate_movie_html_fmt],
           # Limit, in MB, of size of base64 encoded animation in HTML
           # (i.e. IPython notebook)
    1:     'animation.embed_limit':  [20, validate_float],
    1:     'animation.writer':       ['ffmpeg', validate_movie_writer],
    1:     'animation.codec':        ['h264', validate_string],
    1:     'animation.bitrate':      [-1, validate_int],
           # Controls image format when frames are written to disk
    1:     'animation.frame_format': ['png', validate_movie_frame_fmt],
           # Additional arguments for HTML writer
    1:     'animation.html_args':    [[], validate_stringlist],
           # Path to ffmpeg binary. If just binary name, subprocess uses $PATH.
    1:     'animation.ffmpeg_path':  ['ffmpeg', validate_animation_writer_path],
           # Additional arguments for ffmpeg movie writer (using pipes)
    1:     'animation.ffmpeg_args':   [[], validate_stringlist],
           # Path to AVConv binary. If just binary name, subprocess uses $PATH.
    1:     'animation.avconv_path':   ['avconv', validate_animation_writer_path],
           # Additional arguments for avconv movie writer (using pipes)
    1:     'animation.avconv_args':   [[], validate_stringlist],
            # Path to convert binary. If just binary name, subprocess uses $PATH.
    1:     'animation.convert_path':  ['convert', validate_animation_writer_path],
            # Additional arguments for convert movie writer (using pipes)
    1:     'animation.convert_args':  [[], validate_stringlist],
       
           # Classic (pre 2.0) compatibility mode
           # This is used for things that are hard to make backward compatible
           # with a sane rcParam alone.  This does *not* turn on classic mode
           # altogether.  For that use `matplotlib.style.use('classic')`.
    1:     '_internal.classic_mode': [False, validate_bool]
       }
