    1: import dash_core_components as dcc
    1: import dash_html_components as html
    1: import dash_table
    1: from dash.dependencies import Input, Output
       
    1: import requests
    1: from requests.adapters import HTTPAdapter
    1: from requests.packages.urllib3.util.retry import Retry
       
    1: import pandas as pd
    1: import geopandas as gpd
    1: import json
       
    1: import plotly.graph_objects as go
    1: from shapely.geometry import shape
    1: from shapely.geometry import Point, LineString
    1: from shapely import wkt
    1: import math
    1: import fiona
       
    1: import datetime 
    1: from datetime import timedelta
       
    1: from app import app
       
       # WE LOAD THE DATA
    1: stops = gpd.read_file('M6Data/stops.json')
    1: route_lines = gpd.read_file('M6Data/route_lines.json')
    1: with open('M6Data/line_stops_dict.json', 'r') as f:
    1:     line_stops_dict = json.load(f)
       
       #Token for the mapbox api
    1: mapbox_access_token = 'pk.eyJ1IjoiYWxlanAxOTk4IiwiYSI6ImNrNnFwMmM0dDE2OHYzZXFwazZiZTdmbGcifQ.k5qPtvMgar7i9cbQx1fP0w'
    1: style_day = 'mapbox://styles/alejp1998/ck6z9mohb25ni1iod4sqvqa0d'
    1: style_night = 'mapbox://styles/alejp1998/ck6z9mohb25ni1iod4sqvqa0d'
           
       #Load the buses dataframe and parse the dates
    1: buses_data = pd.read_csv('../../flash/EMTBuses/buses_data.csv',dtype={'line': 'str','destination': 'str','stop': 'int32','bus': 'int32','real_coords': 'int32','pos_in_burst':'int32','deviation': 'int32','estimateArrive': 'int32','DistanceBus': 'int32','request_time': 'int32','lat':'float','lon':'float'})
    1: buses_data['datetime'] = pd.to_datetime(buses_data['datetime'], format='%Y-%m-%d %H:%M:%S.%f')
       
       #Values for components
    1: start_date = buses_data.iloc[0]['datetime']
    1: minutes_range = (datetime.datetime.now() - start_date).total_seconds() / 60.0
    1: lines_retrieved = ['1','82','F','G','U','132','N2','N6']
    1: buses_retrieved = buses_data['bus'].unique().tolist()
    1: stops_retrieved = buses_data['stop'].unique().tolist()
       
    1: layout = html.Div(className = '', children = [
       
    1:     html.Div(className = 'box', children = [
    1:         html.H1('DATA RETRIEVED MONITORING',className = 'title is-3'),
    1:         html.Span('Time Interval: ', className = 'tag is-light is-medium'),
    1:         dcc.RangeSlider(
    1:             id='time-range-slider',
   21:             marks = {
                       i*minutes_range/20: {
                           'label' : (start_date + timedelta(minutes=i*minutes_range/20)).strftime("%d-%m-%Y (%H:%M)"), 
                           'style' : {'font-size': '8px'}} 
   20:                 for i in range(1, 20)
                   },
    1:             min=0,
    1:             max=minutes_range,
    1:             step=1,
    1:             value=[minutes_range-120, minutes_range]
               ),
    1:         html.Div(className='columns',children = [
    1:             html.Div(className='column',children = [
    1:                 html.Span('Select lines: ', className = 'tag is-light is-medium'),
    1:                 dcc.Dropdown(
    1:                     id="lines-select",
   11:                     options=[{"label": i, "value": i} for i in lines_retrieved + ['All']],
    1:                     value='All',
    1:                     searchable=True,
    1:                     multi=True
                       )
                   ]),
    1:             html.Div(className='column',children = [
    1:                 html.Span('Select stops: ', className = 'tag is-light is-medium'),
    1:                 dcc.Dropdown(
    1:                     id="stops-select",
  338:                     options=[{"label": i, "value": i} for i in stops_retrieved + ['All']],
    1:                     value='All',
    1:                     searchable=True,
    1:                     multi=True
                       )
                   ]),
    1:             html.Div(className='column',children = [
    1:                 html.Span('Select buses: ', className = 'tag is-light is-medium'),
    1:                 dcc.Dropdown(
    1:                     id="buses-select",
  146:                     options=[{"label": i, "value": i} for i in buses_retrieved + ['All']],
    1:                     value='All',
    1:                     searchable=True,
    1:                     multi=True
                       )
                   ])   
               ]),
    1:         html.Div(className='columns',children = [
    1:             html.Div(className='column is-narrow',children = [
    1:                 dcc.RadioItems(
    1:                     id='distance-range-radio',
                           options=[
    1:                         {'label': 'Show All', 'value': 'All'},
    1:                         {'label': 'Use range', 'value': 'Range'},
                           ],
    1:                     value='All',
    1:                     labelStyle={'display': 'block'}
                       )  
                   ]),
    1:             html.Div(className='column',children = [
    1:                 html.Span('DistanceBus Range (km): ', className = 'tag is-light is-medium'),
    1:                 dcc.RangeSlider(
    1:                     id='distance-range-slider',
   23:                     marks = {
                               i*200 : {
                                   'label' : '{}'.format(i*2/10), 
                                   'style' : {'font-size': '10px'}
   22:                         } for i in range(0, 21)
                           },
    1:                     min=0,
    1:                     max=4000,
    1:                     step=1,
    1:                     value=[0, 4000]
                       )
                   ]),
    1:             html.Div(className='column is-narrow',children = [
    1:                 dcc.RadioItems(
    1:                     id='eta-range-radio',
                           options=[
    1:                         {'label': 'Show All', 'value': 'All'},
    1:                         {'label': 'Use range', 'value': 'Range'},
                           ],
    1:                     value='All',
    1:                     labelStyle={'display': 'block'}
                       )  
                   ]),
    1:             html.Div(className='column',children = [
    1:                 html.Span('ETA Range (min): ', className = 'tag is-light is-medium'),
    1:                 dcc.RangeSlider(
    1:                     id='eta-range-slider',
   23:                     marks = {
                               i*180 : {
                                   'label' : '{}'.format(i*3), 
                                   'style' : {'font-size': '10px'}
   22:                         } for i in range(0, 21)
                           },
    1:                     min=0,
    1:                     max=3600,
    1:                     step=1,
    1:                     value=[0, 3600]
                       )
                   ]) 
               ]),
    1:         html.Div(className='box',id='selected-data'),
    1:         html.Div(className='box',id='figs-selected-data'),
    1:         html.Div(className='box', children = [
    1:             html.Div(className='box',id='time-reduced-pos-control'),
    1:             html.Div(className='box',id='figs-buses-trayectory')
               ])
           ])
           
       ])
       
       # FUNCTIONS 
    1: def point_by_distance_on_line (line, destination, distance, stop_id) :
           """
           Returns the coordinates of the bus location
       
               Parameters
               ----------
               line : string
                   The line that the bus belongs to
               destination : float
                   The destination of the bus
               distance : float
                   The distance of the bus to the stop in kilometers
               stop_id : string
                   The id of the bus stop
           """
           
           #We get the selected lines from the dataframe
           lines_selected = route_lines.loc[route_lines['line_id'].isin(['1','82','91','92','99','132','502','506'])]
           
           #Get the line rows
           if line == '1' :
               line1 = lines_selected.loc[(route_lines['line_id']=='1')&(route_lines['direction']=='1')]
               line2 = lines_selected.loc[(route_lines['line_id']=='1')&(route_lines['direction']=='2')]
           elif line == '82' :
               line1 = lines_selected.loc[(route_lines['line_id']=='82')&(route_lines['direction']=='1')]
               line2 = lines_selected.loc[(route_lines['line_id']=='82')&(route_lines['direction']=='2')]
           elif line == 'F' :
               line1 = lines_selected.loc[(route_lines['line_id']=='91')&(route_lines['direction']=='1')]
               line2 = lines_selected.loc[(route_lines['line_id']=='91')&(route_lines['direction']=='2')]
           elif line == 'G' :     
               line1 = lines_selected.loc[(route_lines['line_id']=='92')&(route_lines['direction']=='1')]
               line2 = lines_selected.loc[(route_lines['line_id']=='92')&(route_lines['direction']=='2')]
           elif line == 'U' :
               line1 = lines_selected.loc[(route_lines['line_id']=='99')&(route_lines['direction']=='1')]
               line2 = lines_selected.loc[(route_lines['line_id']=='99')&(route_lines['direction']=='2')]
           elif line == '132' :    
               line1 = lines_selected.loc[(route_lines['line_id']=='132')&(route_lines['direction']=='1')]
               line2 = lines_selected.loc[(route_lines['line_id']=='132')&(route_lines['direction']=='2')]
           elif line == 'N2' :   
               line1 = lines_selected.loc[(route_lines['line_id']=='502')&(route_lines['direction']=='1')]
               line2 = lines_selected.loc[(route_lines['line_id']=='502')&(route_lines['direction']=='2')]
           elif line == 'N6' :    
               line1 = lines_selected.loc[(route_lines['line_id']=='506')&(route_lines['direction']=='1')]
               line2 = lines_selected.loc[(route_lines['line_id']=='506')&(route_lines['direction']=='2')]
           
           dests_1 = ['HOSPITAL LA PAZ','CIUDAD UNIVERSITARIA','PARANINFO','PITIS','PROSPERIDAD','VALDEBEBAS','LAS ROSAS']
           if destination in dests_1 :
               line = line1['geometry']
               line_length = line1['dist']
           else :
               line = line2['geometry']
               line_length = line2['dist']
           #We get the stop coords
           origin_point = stops.loc[stops['stop_code'] == stop_id].iloc[0]['geometry']
           
           #First we calculate the normalized distance of the bus from the start of the line
           #by substracting the distance of the bus to the stop to the distance of the stop to the start of the line
           #which is returned by the project method of the shapely module
           normalized_distance = line.project(origin_point,normalized=True) - distance/line_length
           
           #Then we get the the coordinates of the point that is at the normalized distance obtained 
           #before from the start of the line with the interpolate method
           interpolated_point = line.interpolate(normalized_distance,normalized=True)
           
           #And we return the coordinates of the point
           return interpolated_point.x,interpolated_point.y
       
       # CALLBACKS
       
       # CALLBACK 1 - Retrieved data
    1: @app.callback([
    1:         Output(component_id = 'selected-data',component_property = 'children'),
    1:         Output(component_id = 'time-reduced-pos-control',component_property = 'children')
           ],
           [
    1:         Input('time-range-slider', 'value'),
    1:         Input('lines-select', 'value'),
    1:         Input('stops-select', 'value'),
    1:         Input('buses-select', 'value'),
    1:         Input('distance-range-radio', 'value'),
    1:         Input('distance-range-slider', 'value'),
    1:         Input('eta-range-radio', 'value'),
    1:         Input('eta-range-slider', 'value')
           ])
       
       def update_table(time_range,lines_selected,stops_selected,buses_selected,distance_radio,distance_range,eta_radio,eta_range):
                   
               try :
                   showAllLines = False
                   showAllStops = False
                   showAllBuses = False
                   showAllDistances = False
                   showAllEtas = False
       
                   #We add the minutes and get the start and end of the time interval
                   start_interval = start_date + timedelta(minutes=time_range[0])
                   end_interval = start_date + timedelta(minutes=time_range[1])
       
                   if type(lines_selected) is list:
                       if 'All' in lines_selected :
                           showAllLines = True
                   else :
                       if lines_selected == 'All' :
                           showAllLines = True
                           
                   if type(stops_selected) is list:
                       if 'All' in stops_selected :
                           showAllStops = True
                   else :
                       if stops_selected == 'All' :
                           showAllStops = True
       
                   if type(buses_selected) is list:
                       if 'All' in buses_selected :
                           showAllBuses = True
                   else :
                       if buses_selected == 'All' :
                           showAllBuses = True
                           
                   if distance_radio == 'All' :
                       showAllDistances = True
                   
                   if eta_radio == 'All' :
                       showAllEtas = True
       
                   #Get the rows that are inside the time interval
                   mask = (buses_data['datetime'] > start_interval) & (buses_data['datetime'] < end_interval)
                   buses_data_reduced = buses_data.loc[mask]
       
                   #Get the rows with the lines selected
                   if not showAllLines :
                       if type(lines_selected) is list:
                           buses_data_reduced = buses_data_reduced.loc[buses_data_reduced['line'].isin(lines_selected)]
                       else :
                           buses_data_reduced = buses_data_reduced.loc[buses_data_reduced['line']==lines_selected]
                   
                   #Get the rows with the stops selected
                   if not showAllStops :
                       if type(stops_selected) is list:
                           buses_data_reduced = buses_data_reduced.loc[buses_data_reduced['stop'].isin(stops_selected)]
                       else :
                           buses_data_reduced = buses_data_reduced.loc[buses_data_reduced['stop']==int(stops_selected)]
                           
                   #Get the rows with the buses selected
                   if not showAllBuses :
                       if type(buses_selected) is list:
                           buses_data_reduced = buses_data_reduced.loc[buses_data_reduced['bus'].isin(buses_selected)]
                       else :
                           buses_data_reduced = buses_data_reduced.loc[buses_data_reduced['bus']==int(buses_selected)]
                   
                   #Get the rows with the distances selected
                   if not showAllDistances :
                           buses_data_reduced = buses_data_reduced.loc[buses_data_reduced['DistanceBus'].between(distance_range[0],distance_range[1])]
                   
                   #Get the rows with the distances selected
                   if not showAllEtas :
                           buses_data_reduced = buses_data_reduced.loc[buses_data_reduced['estimateArrive'].between(eta_range[0],eta_range[1])]
                           
                   #If no rows suit in the selection
                   if (buses_data_reduced.shape[0] == 0) | (buses_data_reduced.shape[0] == 0) :
                       return [['No rows found for the selection'],['']]
                   
                   time_range_minutes = (end_interval-start_interval).total_seconds()/60
                   
                   #And finally we return the graph element
                   return [
                       [html.Div(className='',children=[
                           html.Div(className='',children=[
                               html.H2(
                                   'Showing data from: {} to: {}'.format(start_interval.strftime("%d-%m-%Y (%H:%M)"),end_interval.strftime("%d-%m-%Y (%H:%M)")),
                                   className = 'subtitle is-4'
                               ),
                               dash_table.DataTable(
                                   id='table',
                                   columns=[{"name": i, "id": i} for i in buses_data_reduced.columns],
                                   data=buses_data_reduced.to_dict('records'),
                                   page_size= 15,
                                   style_table={'overflowX': 'scroll'},
                                   style_cell={
                                       'minWidth': '0px', 'maxWidth': '180px',
                                       'overflow': 'hidden',
                                       'textOverflow': 'ellipsis',
                                   },
                                   editable=True,
                                   filter_action="native",
                                   sort_action="native",
                                   sort_mode="multi",
                                   row_deletable=True
                               )
                           ])
                       ])],
                       [html.Div(className='',children=[
                           html.H2(
                               'Slider for trayectory from: {} to: {}. Interval duration : {}(mins)'.format(start_interval.strftime("%d-%m-%Y (%H:%M)"),end_interval.strftime("%d-%m-%Y (%H:%M)"),time_range_minutes),
                               className = 'subtitle is-5'
                           ),
                           dcc.Slider(
                               id = 'time-reduced-slider',
                               min=0,
                               max=time_range_minutes,
                               marks={i*time_range_minutes/20: '{}'.format(time_range_minutes*i/20) for i in range(21) },
                               step=0.5,
                               value=2
                           )
                       ])]
                   ]
               except :
                   return [['No rows found for the selection'],['']]
               
       # CALLBACK 2 - Representations of selected data
    1: @app.callback(
    1:         Output('figs-selected-data', 'children'),
           [
    1:         Input('table', 'derived_virtual_data')
           ])
       def update_graphs(rows):
           
           if rows == None :
               return 'Selected data is too large to represent. Select a smaller slice'
           
           if len(rows) < 500 :
               buses_data_reduced = pd.DataFrame(rows)
               buses_data_reduced['datetime'] = pd.to_datetime(buses_data_reduced['datetime'], format='%Y-%m-%dT%H:%M:%S.%f')
               buses_data_reduced['line'] = buses_data_reduced['line'].astype(str)
               
               #ETAs Figures
               first_stop = buses_data_reduced['stop'].unique().tolist()[0]
               fs_df = buses_data_reduced.loc[buses_data_reduced['stop'] == first_stop]
               fs_buses = fs_df['bus'].unique().tolist()
               
               fig1 = go.Figure() #Distances of bus to stop
               fig2 = go.Figure() #ETAs
               fig3 = go.Figure() #Error in ETAs
               for bus in fs_buses :
                   fs_bus_df = fs_df.loc[fs_df['bus']==bus]
                   line = fs_bus_df.iloc[0]['line']
                   bus_times = fs_bus_df['datetime'].tolist()
                   last_time = bus_times[-1]
                   bus_dists = [dist/1000 for dist in fs_bus_df['DistanceBus'].tolist()]
                   bus_etas = [eta/60 for eta in fs_bus_df['estimateArrive'].tolist()]
                   bus_etas_error = []
                   if bus_etas[-1] <= 1 : 
                       for i in range(len(bus_etas)) :
                           error = (bus_times[i] + timedelta(minutes=bus_etas[i])) - last_time
                           error_mins = error.total_seconds()/60
                           bus_etas_error.append(error_mins)
                       
                   # Create and style traces
                   fig1.add_trace(go.Scatter(x=bus_times, y=bus_dists, name='{}-{}'.format(line,bus),
                                            line=dict(width=4)))
                   fig2.add_trace(go.Scatter(x=bus_times, y=bus_etas, name='{}-{}'.format(line,bus),
                                            line=dict(width=4)))
                   fig3.add_trace(go.Scatter(x=bus_times, y=bus_etas_error, name='{}-{}'.format(line,bus),
                                            line=dict(width=4)))
               # Edit the layout
               fig1.update_layout(title='Distance remaining for the buses heading stop {}'.format(first_stop),
                                  xaxis_title='Time',
                                  yaxis_title='DISTANCE (km)')
               # Edit the layout
               fig2.update_layout(title='ETAs for the buses heading stop {}'.format(first_stop),
                                  xaxis_title='Time',
                                  yaxis_title='ETA (minutes)')
               # Edit the layout
               fig3.update_layout(title='Error in ETAs for the buses heading stop {}. Positive or negative if it arrives later or sooner than expected, respectively'.format(first_stop),
                                  xaxis_title='Time',
                                  yaxis_title='ETA ERROR (minutes)')
               
               return [
                   dcc.Graph(
                       id='fig1',
                       figure=fig1
                   ),
                   dcc.Graph(
                       id='fig2',
                       figure=fig2
                   ),
                   dcc.Graph(
                       id='fig3',
                       figure=fig3
                   )
               ]
           else :
               return 'Selected data is too large to represent. Select a smaller slice'
           
       # CALLBACK 3 - BUSES TRAYECTORY OVER TIME
    1: @app.callback(
    1:         Output('figs-buses-trayectory', 'children'),
           [
    1:         Input('table', 'derived_virtual_data'),
    1:         Input('time-range-slider', 'value'),
    1:         Input('time-reduced-slider', 'value')
           ])
       def update_positions(rows,time_range,time_value):
           
           if rows == None :
               return 'Selected data is too large to represent. Select a smaller slice'
           
           if len(rows) < 200 :
               minutes = time_range[0] + time_value
               time_threshold = start_date + timedelta(minutes=minutes)
               
               buses_data_reduced = pd.DataFrame(rows)
               buses_data_reduced['datetime'] = pd.to_datetime(buses_data_reduced['datetime'], format='%Y-%m-%dT%H:%M:%S.%f')
               #Get the rows that are inside the time interval
               mask = (buses_data_reduced['datetime'] < time_threshold)
               buses_data_reduced = buses_data_reduced.loc[mask]
               buses_in_df = buses_data_reduced['bus'].unique().tolist()
               center_x = buses_data_reduced['lon'].mean()
               center_y = buses_data_reduced['lat'].mean()
               
               #We create the figure object
               fig_buses_trayectory = go.Figure()
               
               for bus in buses_in_df :
                   bus_df = buses_data_reduced.loc[buses_data_reduced['bus']==bus]
                   bus_bools = bus_df['real_coords'].tolist()
                   bus_lats = bus_df['lat'].tolist()
                   bus_lons = bus_df['lon'].tolist()
                   line = bus_df.iloc[0]['line']
                   destination = bus_df.iloc[0]['destination']
                   #We construct real and calculated coord lists
                   lats_real = []
                   lons_real = []
                   lats_calc = [] 
                   lons_calc = []
                   
                   last_real_lat,last_real_lon = None,None
                   last_calc_lat,last_calc_lon = None,None
                   for i in range(len(bus_bools)) :
                       if bus_bools[i] == 1 :
                           lats_real.append(bus_lats[i])
                           lons_real.append(bus_lons[i])
                           last_real_lat = bus_lats[i]
                           last_real_lon = bus_lons[i]
                   for index,row in bus_df.iterrows() :
                       if row['estimateArrive'] < 10000 : 
                           calc_point = Point(point_by_distance_on_line(row['line'], row['destination'], row['DistanceBus']/1000, row['stop']))
                           lats_calc.append(calc_point.y)
                           lons_calc.append(calc_point.x)
                           last_calc_lat = calc_point.y
                           last_calc_lon = calc_point.x
                   
                   #Trace for real coords
                   fig_buses_trayectory.add_trace(go.Scattermapbox(
                       lat=lats_real,
                       lon=lons_real,
                       mode='lines',
                       line=dict(width=2),
                       name='{}-{}-{}'.format(line,bus,destination),
                       text='{}-{}-{}'.format(line,bus,destination),
                       hoverinfo='text'
                   ))
                   #Bus point for calc coords
                   if not last_real_lat == None :
                       fig_buses_trayectory.add_trace(go.Scattermapbox(
                           lat=[last_real_lat],
                           lon=[last_real_lon],
                           mode='markers',
                           marker=go.scattermapbox.Marker(
                               size=7,
                               color='#A9A9A9',
                               opacity=1
                           ),
                           name='{}-{}-{}'.format(line,bus,destination),
                           text='{}-{}-{}'.format(line,bus,destination),
                           hoverinfo='text'
                       ))
                   #Trace for calc coords
                   fig_buses_trayectory.add_trace(go.Scattermapbox(
                       lat=lats_calc,
                       lon=lons_calc,
                       mode='lines',
                       line=dict(width=2),
                       name='{}-{}-{}'.format(line,bus,destination),
                       text='{}-{}-{}'.format(line,bus,destination),
                       hoverinfo='text'
                   ))
                   #Bus point for calc coords
                   if not last_calc_lat == None :
                       fig_buses_trayectory.add_trace(go.Scattermapbox(
                           lat=[last_calc_lat],
                           lon=[last_calc_lon],
                           mode='markers',
                           marker=go.scattermapbox.Marker(
                               size=7,
                               color='black',
                               opacity=1
                           ),
                           name='{}-{}-{}'.format(line,bus,destination),
                           text='{}-{}-{}'.format(line,bus,destination),
                           hoverinfo='text'
                       ))
               #Set figure layout
               fig_buses_trayectory.update_layout(
                   title='Trayectory of buses until selected time',
                   height=500,
                   margin=dict(r=0, l=0, t=0, b=0),
                   hovermode='closest',
                   showlegend=True,
                   mapbox=dict(
                       accesstoken=mapbox_access_token,
                       bearing=0,
                       center=dict(
                           lat=center_y,
                           lon=center_x
                       ),
                       pitch=0,
                       zoom=11.5,
                       style=style_day
                   )
               )
                   
               return [
                   html.H2(
                       'Trayectory of buses until selected time',
                       className = 'subtitle is-4'
                   ),
                   dcc.Graph(
                       id='fig-buses-trayectory',
                       figure=fig_buses_trayectory
                   )
               ]
           else :
               return 'Selected data is too large to represent. Select a smaller slice'
