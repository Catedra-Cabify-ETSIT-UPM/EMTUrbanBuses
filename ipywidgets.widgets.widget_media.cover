       # Copyright (c) Jupyter Development Team.
       # Distributed under the terms of the Modified BSD License.
       
    1: import mimetypes
       
    1: from .widget_core import CoreWidget
    1: from .domwidget import DOMWidget
    1: from .valuewidget import ValueWidget
    1: from .widget import register
    1: from traitlets import Unicode, CUnicode, Bytes, Bool
    1: from .trait_types import bytes_serialization
    1: from .util import text_type
       
       
    2: @register
    1: class _Media(DOMWidget, ValueWidget, CoreWidget):
           """Base class for Image, Audio and Video widgets.
       
           The `value` of this widget accepts a byte string.  The byte string is the
           raw data that you want the browser to display.
       
           If you pass `"url"` to the `"format"` trait, `value` will be interpreted
           as a URL as bytes encoded in UTF-8.
    1:     """
       
           # Define the custom state properties to sync with the front-end
    1:     value = Bytes(help="The media data as a byte string.").tag(sync=True, **bytes_serialization)
       
    1:     @classmethod
           def _from_file(cls, tag, filename, **kwargs):
               """
               Create an :class:`Media` from a local file.
       
               Parameters
               ----------
               filename: str
                   The location of a file to read into the value from disk.
       
               **kwargs:
                   The keyword arguments for `Media`
       
               Returns an `Media` with the value set from the filename.
               """
               value = cls._load_file_value(filename)
       
               if 'format' not in kwargs:
                   format = cls._guess_format(tag, filename)
                   if format is not None:
                       kwargs['format'] = format
       
               return cls(value=value, **kwargs)
       
    1:     @classmethod
           def from_url(cls, url, **kwargs):
               """
               Create an :class:`Media` from a URL.
       
               :code:`Media.from_url(url)` is equivalent to:
       
               .. code-block: python
       
                   med = Media(value=url, format='url')
       
               But both unicode and bytes arguments are allowed for ``url``.
       
               Parameters
               ----------
               url: [str, bytes]
                   The location of a URL to load.
               """
               if isinstance(url, text_type):
                   # If unicode (str in Python 3), it needs to be encoded to bytes
                   url = url.encode('utf-8')
       
               return cls(value=url, format='url')
       
    1:     def set_value_from_file(self, filename):
               """
               Convenience method for reading a file into `value`.
       
               Parameters
               ----------
               filename: str
                   The location of a file to read into value from disk.
               """
               value = self._load_file_value(filename)
       
               self.value = value
       
    1:     @classmethod
           def _load_file_value(cls, filename):
               if getattr(filename, 'read', None) is not None:
                   return filename.read()
               else:
                   with open(filename, 'rb') as f:
                       return f.read()
       
    1:     @classmethod
           def _guess_format(cls, tag, filename):
               # file objects may have a .name parameter
               name = getattr(filename, 'name', None)
               name = name or filename
       
               try:
                   mtype, _ = mimetypes.guess_type(name)
                   if not mtype.startswith('{}/'.format(tag)):
                       return None
       
                   return mtype[len('{}/'.format(tag)):]
               except Exception:
                   return None
       
    1:     def _get_repr(self, cls):
               # Truncate the value in the repr, since it will
               # typically be very, very large.
               class_name = self.__class__.__name__
       
               # Return value first like a ValueWidget
               signature = []
               sig_value = repr(self.value)
               prefix, rest = sig_value.split("'", 1)
               content = rest[:-1]
               if len(content) > 100:
                   sig_value = "{}'{}...'".format(prefix, content[0:100])
               signature.append('%s=%s' % ('value', sig_value))
       
               for key in super(cls, self)._repr_keys():
                   if key == 'value':
                       continue
                   value = str(getattr(self, key))
                   signature.append('%s=%r' % (key, value))
               signature = ', '.join(signature)
               return '%s(%s)' % (class_name, signature)
       
       
    2: @register
    1: class Image(_Media):
           """Displays an image as a widget.
       
           The `value` of this widget accepts a byte string.  The byte string is the
           raw image data that you want the browser to display.  You can explicitly
           define the format of the byte string using the `format` trait (which
           defaults to "png").
       
           If you pass `"url"` to the `"format"` trait, `value` will be interpreted
           as a URL as bytes encoded in UTF-8.
    1:     """
    1:     _view_name = Unicode('ImageView').tag(sync=True)
    1:     _model_name = Unicode('ImageModel').tag(sync=True)
       
           # Define the custom state properties to sync with the front-end
    1:     format = Unicode('png', help="The format of the image.").tag(sync=True)
    1:     width = CUnicode(help="Width of the image in pixels. Use layout.width "
    1:                           "for styling the widget.").tag(sync=True)
    1:     height = CUnicode(help="Height of the image in pixels. Use layout.height "
    1:                            "for styling the widget.").tag(sync=True)
       
    1:     def __init__(self, *args, **kwargs):
               super(Image, self).__init__(*args, **kwargs)
       
    1:     @classmethod
           def from_file(cls, filename, **kwargs):
               return cls._from_file('image', filename, **kwargs)
       
    1:     def __repr__(self):
               return self._get_repr(Image)
       
       
    2: @register
    1: class Video(_Media):
           """Displays a video as a widget.
       
           The `value` of this widget accepts a byte string.  The byte string is the
           raw video data that you want the browser to display.  You can explicitly
           define the format of the byte string using the `format` trait (which
           defaults to "mp4").
       
           If you pass `"url"` to the `"format"` trait, `value` will be interpreted
           as a URL as bytes encoded in UTF-8.
    1:     """
    1:     _view_name = Unicode('VideoView').tag(sync=True)
    1:     _model_name = Unicode('VideoModel').tag(sync=True)
       
           # Define the custom state properties to sync with the front-end
    1:     format = Unicode('mp4', help="The format of the video.").tag(sync=True)
    1:     width = CUnicode(help="Width of the video in pixels.").tag(sync=True)
    1:     height = CUnicode(help="Height of the video in pixels.").tag(sync=True)
    1:     autoplay = Bool(True, help="When true, the video starts when it's displayed").tag(sync=True)
    1:     loop = Bool(True, help="When true, the video will start from the beginning after finishing").tag(sync=True)
    1:     controls = Bool(True, help="Specifies that video controls should be displayed (such as a play/pause button etc)").tag(sync=True)
       
    1:     @classmethod
           def from_file(cls, filename, **kwargs):
               return cls._from_file('video', filename, **kwargs)
       
    1:     def __repr__(self):
               return self._get_repr(Video)
       
       
    2: @register
    1: class Audio(_Media):
           """Displays a audio as a widget.
       
           The `value` of this widget accepts a byte string.  The byte string is the
           raw audio data that you want the browser to display.  You can explicitly
           define the format of the byte string using the `format` trait (which
           defaults to "mp3").
       
           If you pass `"url"` to the `"format"` trait, `value` will be interpreted
           as a URL as bytes encoded in UTF-8.
    1:     """
    1:     _view_name = Unicode('AudioView').tag(sync=True)
    1:     _model_name = Unicode('AudioModel').tag(sync=True)
       
           # Define the custom state properties to sync with the front-end
    1:     format = Unicode('mp3', help="The format of the audio.").tag(sync=True)
    1:     autoplay = Bool(True, help="When true, the audio starts when it's displayed").tag(sync=True)
    1:     loop = Bool(True, help="When true, the audio will start from the beginning after finishing").tag(sync=True)
    1:     controls = Bool(True, help="Specifies that audio controls should be displayed (such as a play/pause button etc)").tag(sync=True)
       
    1:     @classmethod
           def from_file(cls, filename, **kwargs):
               return cls._from_file('audio', filename, **kwargs)
       
    1:     def __repr__(self):
               return self._get_repr(Audio)
