    1: """Dataset paths, identifiers, and filenames"""
       
    1: import re
    1: import sys
       
    1: import attr
       
    1: from fiona.compat import urlparse
       
       # Supported URI schemes and their mapping to GDAL's VSI suffix.
       # TODO: extend for other cloud plaforms.
       SCHEMES = {
    1:     'ftp': 'curl',
    1:     'gzip': 'gzip',
    1:     'http': 'curl',
    1:     'https': 'curl',
    1:     's3': 's3',
    1:     'tar': 'tar',
    1:     'zip': 'zip',
    1:     'file': 'file',
    1:     'gs': 'gs',
       }
       
   11: CURLSCHEMES = set([k for k, v in SCHEMES.items() if v == 'curl'])
       
       # TODO: extend for other cloud plaforms.
   11: REMOTESCHEMES = set([k for k, v in SCHEMES.items() if v in ('curl', 's3', 'gs')])
       
       
    2: class Path(object):
    1:     """Base class for dataset paths"""
       
       
    2: @attr.s(slots=True)
    1: class ParsedPath(Path):
           """Result of parsing a dataset URI/Path
       
           Attributes
           ----------
           path : str
               Parsed path. Includes the hostname and query string in the case
               of a URI.
           archive : str
               Parsed archive path.
           scheme : str
               URI scheme such as "https" or "zip+s3".
    1:     """
    1:     path = attr.ib()
    1:     archive = attr.ib()
    1:     scheme = attr.ib()
       
    1:     @classmethod
           def from_uri(cls, uri):
               parts = urlparse(uri)
               path = parts.path
               scheme = parts.scheme or None
       
               if parts.query:
                   path += "?" + parts.query
       
               if parts.scheme and parts.netloc:
                   path = parts.netloc + path
       
               parts = path.split('!')
               path = parts.pop() if parts else None
               archive = parts.pop() if parts else None
               return ParsedPath(path, archive, scheme)
       
    1:     @property
           def name(self):
               """The parsed path's original URI"""
               if not self.scheme:
                   return self.path
               elif self.archive:
                   return "{}://{}!{}".format(self.scheme, self.archive, self.path)
               else:
                   return "{}://{}".format(self.scheme, self.path)
       
    1:     @property
           def is_remote(self):
               """Test if the path is a remote, network URI"""
               return self.scheme and self.scheme.split('+')[-1] in REMOTESCHEMES
       
    1:     @property
           def is_local(self):
               """Test if the path is a local URI"""
               return not self.scheme or (self.scheme and self.scheme.split('+')[-1] not in REMOTESCHEMES)
       
       
    2: @attr.s(slots=True)
    1: class UnparsedPath(Path):
           """Encapsulates legacy GDAL filenames
       
           Attributes
           ----------
           path : str
               The legacy GDAL filename.
    1:     """
    1:     path = attr.ib()
       
    1:     @property
           def name(self):
               """The unparsed path's original path"""
               return self.path
       
       
    1: def parse_path(path):
           """Parse a dataset's identifier or path into its parts
       
           Parameters
           ----------
           path : str or path-like object
               The path to be parsed.
       
           Returns
           -------
           ParsedPath or UnparsedPath
       
           Notes
           -----
           When legacy GDAL filenames are encountered, they will be returned
           in a UnparsedPath.
           """
   12:     if isinstance(path, Path):
    6:         return path
       
           # Windows drive letters (e.g. "C:\") confuse `urlparse` as they look like
           # URL schemes
    6:     elif sys.platform == "win32" and re.match("^[a-zA-Z]\\:", path):
               return UnparsedPath(path)
       
    6:     elif path.startswith('/vsi'):
               return UnparsedPath(path)
       
    6:     elif re.match("^[a-z0-9\\+]*://", path):
               parts = urlparse(path)
       
               # if the scheme is not one of Rasterio's supported schemes, we
               # return an UnparsedPath.
               if parts.scheme and not all(p in SCHEMES for p in parts.scheme.split('+')):
                   return UnparsedPath(path)
       
               else:
                   return ParsedPath.from_uri(path)
       
           else:
    6:         return UnparsedPath(path)
       
       
    1: def vsi_path(path):
           """Convert a parsed path to a GDAL VSI path
       
           Parameters
           ----------
           path : Path
               A ParsedPath or UnparsedPath object.
       
           Returns
           -------
           str
           """
    6:     if isinstance(path, UnparsedPath):
    6:         return path.path
       
           elif isinstance(path, ParsedPath):
       
               if not path.scheme:
                   return path.path
       
               else:
                   if path.scheme.split('+')[-1] in CURLSCHEMES:
                       suffix = '{}://'.format(path.scheme.split('+')[-1])
                   else:
                       suffix = ''
       
                   prefix = '/'.join('vsi{0}'.format(SCHEMES[p]) for p in path.scheme.split('+') if p != 'file')
       
                   if prefix:
                       if path.archive:
                           result = '/{}/{}{}/{}'.format(prefix, suffix, path.archive, path.path.lstrip('/'))
                       else:
                           result = '/{}/{}{}'.format(prefix, suffix, path.path)
                   else:
                       result = path.path
                   return result
       
           else:
               raise ValueError("path must be a ParsedPath or UnparsedPath object")
