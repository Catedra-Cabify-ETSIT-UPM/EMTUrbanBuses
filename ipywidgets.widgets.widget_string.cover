       # Copyright (c) Jupyter Development Team.
       # Distributed under the terms of the Modified BSD License.
       
       """String class.
       
       Represents a unicode string using a widget.
    1: """
       
    1: from .widget_description import DescriptionWidget
    1: from .valuewidget import ValueWidget
    1: from .widget import CallbackDispatcher, register
    1: from .widget_core import CoreWidget
    1: from .trait_types import TypedTuple
    1: from traitlets import Unicode, Bool, Int
    1: from warnings import warn
       
       
    2: class _String(DescriptionWidget, ValueWidget, CoreWidget):
    1:     """Base class used to create widgets that represent a string."""
       
    1:     value = Unicode(help="String value").tag(sync=True)
       
           # We set a zero-width space as a default placeholder to make sure the baseline matches
           # the text, not the bottom margin. See the last paragraph of
           # https://www.w3.org/TR/CSS2/visudet.html#leading
    1:     placeholder = Unicode(u'\u200b', help="Placeholder text to display when nothing has been typed").tag(sync=True)
       
       
    1:     def __init__(self, value=None, **kwargs):
               if value is not None:
                   kwargs['value'] = value
               super(_String, self).__init__(**kwargs)
       
    1:     _model_name = Unicode('StringModel').tag(sync=True)
       
       
    2: @register
    1: class HTML(_String):
    1:     """Renders the string `value` as HTML."""
    1:     _view_name = Unicode('HTMLView').tag(sync=True)
    1:     _model_name = Unicode('HTMLModel').tag(sync=True)
       
    2: @register
    1: class HTMLMath(_String):
    1:     """Renders the string `value` as HTML, and render mathematics."""
    1:     _view_name = Unicode('HTMLMathView').tag(sync=True)
    1:     _model_name = Unicode('HTMLMathModel').tag(sync=True)
       
       
    2: @register
    1: class Label(_String):
           """Label widget.
       
           It also renders math inside the string `value` as Latex (requires $ $ or
           $$ $$ and similar latex tags).
    1:     """
    1:     _view_name = Unicode('LabelView').tag(sync=True)
    1:     _model_name = Unicode('LabelModel').tag(sync=True)
       
       
    2: @register
    1: class Textarea(_String):
    1:     """Multiline text area widget."""
    1:     _view_name = Unicode('TextareaView').tag(sync=True)
    1:     _model_name = Unicode('TextareaModel').tag(sync=True)
    1:     rows = Int(None, allow_none=True, help="The number of rows to display.").tag(sync=True)
    1:     disabled = Bool(False, help="Enable or disable user changes").tag(sync=True)
    1:     continuous_update = Bool(True, help="Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.").tag(sync=True)
       
    2: @register
    1: class Text(_String):
    1:     """Single line textbox widget."""
    1:     _view_name = Unicode('TextView').tag(sync=True)
    1:     _model_name = Unicode('TextModel').tag(sync=True)
    1:     disabled = Bool(False, help="Enable or disable user changes").tag(sync=True)
    1:     continuous_update = Bool(True, help="Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.").tag(sync=True)
       
    1:     def __init__(self, *args, **kwargs):
               super(Text, self).__init__(*args, **kwargs)
               self._submission_callbacks = CallbackDispatcher()
               self.on_msg(self._handle_string_msg)
       
    1:     def _handle_string_msg(self, _, content, buffers):
               """Handle a msg from the front-end.
       
               Parameters
               ----------
               content: dict
                   Content of the msg.
               """
               if content.get('event', '') == 'submit':
                   self._submission_callbacks(self)
       
    1:     def on_submit(self, callback, remove=False):
               """(Un)Register a callback to handle text submission.
       
               Triggered when the user clicks enter.
       
               Parameters
               ----------
               callback: callable
                   Will be called with exactly one argument: the Widget instance
               remove: bool (optional)
                   Whether to unregister the callback
               """
               import warnings
               warnings.warn("on_submit is deprecated. Instead, set the .continuous_update attribute to False and observe the value changing with: mywidget.observe(callback, 'value').", DeprecationWarning)
               self._submission_callbacks.register_callback(callback, remove=remove)
       
       
    2: @register
    1: class Password(Text):
    1:     """Single line textbox widget."""
    1:     _view_name = Unicode('PasswordView').tag(sync=True)
    1:     _model_name = Unicode('PasswordModel').tag(sync=True)
    1:     disabled = Bool(False, help="Enable or disable user changes").tag(sync=True)
       
    1:     def _repr_keys(self):
               # Don't include password value in repr!
               super_keys = super(Password, self)._repr_keys()
               for key in super_keys:
                   if key != 'value':
                       yield key
       
       
    2: @register
    1: class Combobox(Text):
           """Single line textbox widget with a dropdown and autocompletion.
    1:     """
    1:     _model_name = Unicode('ComboboxModel').tag(sync=True)
    1:     _view_name = Unicode('ComboboxView').tag(sync=True)
       
    1:     options = TypedTuple(
    1:         trait=Unicode(),
    1:         help="Dropdown options for the combobox"
    1:     ).tag(sync=True)
       
    1:     ensure_option = Bool(
    1:         False,
    1:         help='If set, ensure value is in options. Implies continuous_update=False.'
    1:     ).tag(sync=True)
