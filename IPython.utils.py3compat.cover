       # coding: utf-8
       """Compatibility tricks for Python 3. Mainly to do with unicode.
       
       This file is deprecated and will be removed in a future version.
    1: """
    1: import functools
    1: import os
    1: import sys
    1: import re
    1: import shutil
    1: import types
    1: import platform
       
    1: from .encoding import DEFAULT_ENCODING
       
    1: def no_code(x, encoding=None):
           return x
       
    1: def decode(s, encoding=None):
           encoding = encoding or DEFAULT_ENCODING
           return s.decode(encoding, "replace")
       
    1: def encode(u, encoding=None):
           encoding = encoding or DEFAULT_ENCODING
           return u.encode(encoding, "replace")
       
       
    1: def cast_unicode(s, encoding=None):
    1:     if isinstance(s, bytes):
               return decode(s, encoding)
    1:     return s
       
    1: def cast_bytes(s, encoding=None):
           if not isinstance(s, bytes):
               return encode(s, encoding)
           return s
       
    1: def buffer_to_bytes(buf):
           """Cast a buffer object to bytes"""
           if not isinstance(buf, bytes):
               buf = bytes(buf)
           return buf
       
    1: def _modify_str_or_docstring(str_change_func):
    1:     @functools.wraps(str_change_func)
           def wrapper(func_or_str):
               if isinstance(func_or_str, string_types):
                   func = None
                   doc = func_or_str
               else:
                   func = func_or_str
                   doc = func.__doc__
       
               # PYTHONOPTIMIZE=2 strips docstrings, so they can disappear unexpectedly
               if doc is not None:
                   doc = str_change_func(doc)
       
               if func:
                   func.__doc__ = doc
                   return func
               return doc
    1:     return wrapper
       
    1: def safe_unicode(e):
           """unicode(e) with various fallbacks. Used for exceptions, which may not be
           safe to call unicode() on.
           """
           try:
               return unicode_type(e)
           except UnicodeError:
               pass
       
           try:
               return str_to_unicode(str(e))
           except UnicodeError:
               pass
       
           try:
               return str_to_unicode(repr(e))
           except UnicodeError:
               pass
       
           return u'Unrecoverably corrupt evalue'
       
       # shutil.which from Python 3.4
    1: def _shutil_which(cmd, mode=os.F_OK | os.X_OK, path=None):
           """Given a command, mode, and a PATH string, return the path which
           conforms to the given mode on the PATH, or None if there is no such
           file.
       
           `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
           of os.environ.get("PATH"), or can be overridden with a custom search
           path.
       
           This is a backport of shutil.which from Python 3.4
           """
           # Check that a given file can be accessed with the correct mode.
           # Additionally check that `file` is not a directory, as on Windows
           # directories pass the os.access check.
           def _access_check(fn, mode):
               return (os.path.exists(fn) and os.access(fn, mode)
                       and not os.path.isdir(fn))
       
           # If we're given a path with a directory part, look it up directly rather
           # than referring to PATH directories. This includes checking relative to the
           # current directory, e.g. ./script
           if os.path.dirname(cmd):
               if _access_check(cmd, mode):
                   return cmd
               return None
       
           if path is None:
               path = os.environ.get("PATH", os.defpath)
           if not path:
               return None
           path = path.split(os.pathsep)
       
           if sys.platform == "win32":
               # The current directory takes precedence on Windows.
               if not os.curdir in path:
                   path.insert(0, os.curdir)
       
               # PATHEXT is necessary to check on Windows.
               pathext = os.environ.get("PATHEXT", "").split(os.pathsep)
               # See if the given file matches any of the expected path extensions.
               # This will allow us to short circuit when given "python.exe".
               # If it does match, only test that one, otherwise we have to try
               # others.
               if any(cmd.lower().endswith(ext.lower()) for ext in pathext):
                   files = [cmd]
               else:
                   files = [cmd + ext for ext in pathext]
           else:
               # On other platforms you don't have things like PATHEXT to tell you
               # what file suffixes are executable, so just pass on cmd as-is.
               files = [cmd]
       
           seen = set()
           for dir in path:
               normdir = os.path.normcase(dir)
               if not normdir in seen:
                   seen.add(normdir)
                   for thefile in files:
                       name = os.path.join(dir, thefile)
                       if _access_check(name, mode):
                           return name
           return None
       
    1: PY3 = True
       
       # keep reference to builtin_mod because the kernel overrides that value
       # to forward requests to a frontend.
    1: def input(prompt=''):
           return builtin_mod.input(prompt)
       
    1: builtin_mod_name = "builtins"
    1: import builtins as builtin_mod
       
    1: str_to_unicode = no_code
    1: unicode_to_str = no_code
    1: str_to_bytes = encode
    1: bytes_to_str = decode
    1: cast_bytes_py2 = no_code
    1: cast_unicode_py2 = no_code
    1: buffer_to_bytes_py2 = no_code
       
    1: string_types = (str,)
    1: unicode_type = str
       
    1: which = shutil.which
       
    1: def isidentifier(s, dotted=False):
           if dotted:
               return all(isidentifier(a) for a in s.split("."))
           return s.isidentifier()
       
    1: xrange = range
    1: def iteritems(d): return iter(d.items())
    1: def itervalues(d): return iter(d.values())
    1: getcwd = os.getcwd
       
    1: MethodType = types.MethodType
       
    1: def execfile(fname, glob, loc=None, compiler=None):
           loc = loc if (loc is not None) else glob
           with open(fname, 'rb') as f:
               compiler = compiler or compile
               exec(compiler(f.read(), fname, 'exec'), glob, loc)
       
       # Refactor print statements in doctests.
    1: _print_statement_re = re.compile(r"\bprint (?P<expr>.*)$", re.MULTILINE)
    1: def _print_statement_sub(match):
           expr = match.groups('expr')
           return "print(%s)" % expr
       
       # Abstract u'abc' syntax:
    1: @_modify_str_or_docstring
       def u_format(s):
           """"{u}'abc'" --> "'abc'" (Python 3)
       
           Accepts a string or a function, so it can be used as a decorator."""
           return s.format(u='')
       
    1: def get_closure(f):
           """Get a function's closure attribute"""
           return f.__closure__
       
       
    1: PY2 = not PY3
    1: PYPY = platform.python_implementation() == "PyPy"
       
       
    1: def annotate(**kwargs):
           """Python 3 compatible function annotation for Python 2."""
           if not kwargs:
               raise ValueError('annotations must be provided as keyword arguments')
           def dec(f):
               if hasattr(f, '__annotations__'):
                   for k, v in kwargs.items():
                       f.__annotations__[k] = v
               else:
                   f.__annotations__ = kwargs
               return f
           return dec
       
       
       # Parts below taken from six:
       # Copyright (c) 2010-2013 Benjamin Peterson
       #
       # Permission is hereby granted, free of charge, to any person obtaining a copy
       # of this software and associated documentation files (the "Software"), to deal
       # in the Software without restriction, including without limitation the rights
       # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       # copies of the Software, and to permit persons to whom the Software is
       # furnished to do so, subject to the following conditions:
       #
       # The above copyright notice and this permission notice shall be included in all
       # copies or substantial portions of the Software.
       #
       # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       # SOFTWARE.
       
    1: def with_metaclass(meta, *bases):
           """Create a base class with a metaclass."""
           return meta("_NewBase", bases, {})
