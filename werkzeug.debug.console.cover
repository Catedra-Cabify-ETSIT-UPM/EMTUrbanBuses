       # -*- coding: utf-8 -*-
       """
           werkzeug.debug.console
           ~~~~~~~~~~~~~~~~~~~~~~
       
           Interactive console support.
       
           :copyright: 2007 Pallets
           :license: BSD-3-Clause
    1: """
    1: import code
    1: import sys
    1: from types import CodeType
       
    1: from ..local import Local
    1: from ..utils import escape
    1: from .repr import debug_repr
    1: from .repr import dump
    1: from .repr import helper
       
       
    1: _local = Local()
       
       
    2: class HTMLStringO(object):
    1:     """A StringO version that HTML escapes on write."""
       
    1:     def __init__(self):
               self._buffer = []
       
    1:     def isatty(self):
               return False
       
    1:     def close(self):
               pass
       
    1:     def flush(self):
               pass
       
    1:     def seek(self, n, mode=0):
               pass
       
    1:     def readline(self):
               if len(self._buffer) == 0:
                   return ""
               ret = self._buffer[0]
               del self._buffer[0]
               return ret
       
    1:     def reset(self):
               val = "".join(self._buffer)
               del self._buffer[:]
               return val
       
    1:     def _write(self, x):
               if isinstance(x, bytes):
                   x = x.decode("utf-8", "replace")
               self._buffer.append(x)
       
    1:     def write(self, x):
               self._write(escape(x))
       
    1:     def writelines(self, x):
               self._write(escape("".join(x)))
       
       
    2: class ThreadedStream(object):
    1:     """Thread-local wrapper for sys.stdout for the interactive console."""
       
    1:     @staticmethod
           def push():
               if not isinstance(sys.stdout, ThreadedStream):
                   sys.stdout = ThreadedStream()
               _local.stream = HTMLStringO()
       
    1:     @staticmethod
           def fetch():
               try:
                   stream = _local.stream
               except AttributeError:
                   return ""
               return stream.reset()
       
    1:     @staticmethod
           def displayhook(obj):
               try:
                   stream = _local.stream
               except AttributeError:
                   return _displayhook(obj)
               # stream._write bypasses escaping as debug_repr is
               # already generating HTML for us.
               if obj is not None:
                   _local._current_ipy.locals["_"] = obj
                   stream._write(debug_repr(obj))
       
    1:     def __setattr__(self, name, value):
               raise AttributeError("read only attribute %s" % name)
       
    1:     def __dir__(self):
               return dir(sys.__stdout__)
       
    1:     def __getattribute__(self, name):
               if name == "__members__":
                   return dir(sys.__stdout__)
               try:
                   stream = _local.stream
               except AttributeError:
                   stream = sys.__stdout__
               return getattr(stream, name)
       
    1:     def __repr__(self):
               return repr(sys.__stdout__)
       
       
       # add the threaded stream as display hook
    1: _displayhook = sys.displayhook
    1: sys.displayhook = ThreadedStream.displayhook
       
       
    2: class _ConsoleLoader(object):
    1:     def __init__(self):
               self._storage = {}
       
    1:     def register(self, code, source):
               self._storage[id(code)] = source
               # register code objects of wrapped functions too.
               for var in code.co_consts:
                   if isinstance(var, CodeType):
                       self._storage[id(var)] = source
       
    1:     def get_source_by_code(self, code):
               try:
                   return self._storage[id(code)]
               except KeyError:
                   pass
       
       
    1: def _wrap_compiler(console):
           compile = console.compile
       
           def func(source, filename, symbol):
               code = compile(source, filename, symbol)
               console.loader.register(code, source)
               return code
       
           console.compile = func
       
       
    2: class _InteractiveConsole(code.InteractiveInterpreter):
    1:     def __init__(self, globals, locals):
               locals = dict(globals)
               locals.update(locals)
               locals["dump"] = dump
               locals["help"] = helper
               locals["__loader__"] = self.loader = _ConsoleLoader()
               code.InteractiveInterpreter.__init__(self, locals)
               self.more = False
               self.buffer = []
               _wrap_compiler(self)
       
    1:     def runsource(self, source):
               source = source.rstrip() + "\n"
               ThreadedStream.push()
               prompt = "... " if self.more else ">>> "
               try:
                   source_to_eval = "".join(self.buffer + [source])
                   if code.InteractiveInterpreter.runsource(
                       self, source_to_eval, "<debugger>", "single"
                   ):
                       self.more = True
                       self.buffer.append(source)
                   else:
                       self.more = False
                       del self.buffer[:]
               finally:
                   output = ThreadedStream.fetch()
               return prompt + escape(source) + output
       
    1:     def runcode(self, code):
               try:
                   exec(code, self.locals)
               except Exception:
                   self.showtraceback()
       
    1:     def showtraceback(self):
               from .tbtools import get_current_traceback
       
               tb = get_current_traceback(skip=1)
               sys.stdout._write(tb.render_summary())
       
    1:     def showsyntaxerror(self, filename=None):
               from .tbtools import get_current_traceback
       
               tb = get_current_traceback(skip=4)
               sys.stdout._write(tb.render_summary())
       
    1:     def write(self, data):
               sys.stdout.write(data)
       
       
    2: class Console(object):
    1:     """An interactive console."""
       
    1:     def __init__(self, globals=None, locals=None):
               if locals is None:
                   locals = {}
               if globals is None:
                   globals = {}
               self._ipy = _InteractiveConsole(globals, locals)
       
    1:     def eval(self, code):
               _local._current_ipy = self._ipy
               old_sys_stdout = sys.stdout
               try:
                   return self._ipy.runsource(code)
               finally:
                   sys.stdout = old_sys_stdout
