       """Implementation of the intermediary layer between Shapely and GEOS
       
       This is layer number 2 from the list below.
       
       1) geometric objects: the Python OO API.
       2) implementation map: an abstraction that permits different backends.
       3) backend: callable objects that take Shapely geometric objects as arguments
          and, with GEOS as a backend, translate them to C data structures.
       4) GEOS library: algorithms implemented in C++.
       
       Shapely 1.2 includes a GEOS backend and it is the default.
    1: """
       
    1: from functools import wraps
       
    1: from shapely.algorithms import cga
    1: from shapely.coords import BoundsOp
    1: from shapely.geos import lgeos
    1: from shapely.linref import ProjectOp, InterpolateOp
    1: from shapely.predicates import BinaryPredicate, UnaryPredicate
    1: from shapely.topology import BinaryRealProperty, BinaryTopologicalOp
    1: from shapely.topology import UnaryRealProperty, UnaryTopologicalOp
       
       
    2: class ImplementationError(
    1:         AttributeError, KeyError, NotImplementedError):
           """To be raised when the registered implementation does not
    1:     support the requested method."""
       
       
    1: def delegated(func):
           """A delegated method raises AttributeError in the absence of backend
           support."""
   13:     @wraps(func)
           def wrapper(*args, **kwargs):
               try:
                   return func(*args, **kwargs)
               except KeyError:
                   raise ImplementationError(
                       "Method '%s' not provided by registered "
                       "implementation '%s'" % (func.__name__, args[0].impl))
   13:     return wrapper
       
       # Map geometry methods to their GEOS delegates
       
       
    2: class BaseImpl(object):
    1:     """Base class for registrable implementations."""
       
    1:     def __init__(self, values):
    1:         self.map = dict(values)
       
    1:     def update(self, values):
    4:         self.map.update(values)
       
    1:     def __getitem__(self, key):
               try:
                   return self.map[key]
               except KeyError:
                   raise ImplementationError(
                       "Method '%s' not provided by registered "
                       "implementation '%s'" % (key, self.map))
       
    1:     def __contains__(self, key):
               return key in self.map
       
       
    2: class GEOSImpl(BaseImpl):
    1:     """GEOS implementation"""
       
    1:     def __repr__(self):
               return '<GEOSImpl object: GEOS C API version %s>' % (
                   lgeos.geos_capi_version,)
       
       
       IMPL300 = {
    1:     'area': (UnaryRealProperty, 'area'),
    1:     'distance': (BinaryRealProperty, 'distance'),
    1:     'length': (UnaryRealProperty, 'length'),
           #
    1:     'boundary': (UnaryTopologicalOp, 'boundary'),
    1:     'bounds': (BoundsOp, None),
    1:     'centroid': (UnaryTopologicalOp, 'centroid'),
    1:     'representative_point': (UnaryTopologicalOp, 'representative_point'),
    1:     'envelope': (UnaryTopologicalOp, 'envelope'),
    1:     'convex_hull': (UnaryTopologicalOp, 'convex_hull'),
    1:     'buffer': (UnaryTopologicalOp, 'buffer'),
           #
    1:     'difference': (BinaryTopologicalOp, 'difference'),
    1:     'intersection': (BinaryTopologicalOp, 'intersection'),
    1:     'symmetric_difference': (BinaryTopologicalOp, 'symmetric_difference'),
    1:     'union': (BinaryTopologicalOp, 'union'),
           #
    1:     'has_z': (UnaryPredicate, 'has_z'),
    1:     'is_empty': (UnaryPredicate, 'is_empty'),
    1:     'is_ring': (UnaryPredicate, 'is_ring'),
    1:     'is_simple': (UnaryPredicate, 'is_simple'),
    1:     'is_valid': (UnaryPredicate, 'is_valid'),
           #
    1:     'relate': (BinaryPredicate, 'relate'),
    1:     'contains': (BinaryPredicate, 'contains'),
    1:     'crosses': (BinaryPredicate, 'crosses'),
    1:     'disjoint': (BinaryPredicate, 'disjoint'),
    1:     'equals': (BinaryPredicate, 'equals'),
    1:     'intersects': (BinaryPredicate, 'intersects'),
    1:     'overlaps': (BinaryPredicate, 'overlaps'),
    1:     'touches': (BinaryPredicate, 'touches'),
    1:     'within': (BinaryPredicate, 'within'),
    1:     'covers': (BinaryPredicate, 'covers'),
    1:     'equals_exact': (BinaryPredicate, 'equals_exact'),
    1:     'relate_pattern': (BinaryPredicate, 'relate_pattern'),
       
           # First pure Python implementation
    1:     'is_ccw': (cga.is_ccw_impl, 'is_ccw'),
           }
       
       IMPL310 = {
    1:     'simplify': (UnaryTopologicalOp, 'simplify'),
           'topology_preserve_simplify':
    1:         (UnaryTopologicalOp, 'topology_preserve_simplify'),
    1:     'prepared_disjoint': (BinaryPredicate, 'prepared_disjoint'),
    1:     'prepared_touches': (BinaryPredicate, 'prepared_touches'),
    1:     'prepared_crosses': (BinaryPredicate, 'prepared_crosses'),
    1:     'prepared_within': (BinaryPredicate, 'prepared_within'),
    1:     'prepared_overlaps': (BinaryPredicate, 'prepared_overlaps'),
    1:     'prepared_intersects': (BinaryPredicate, 'prepared_intersects'),
    1:     'prepared_contains': (BinaryPredicate, 'prepared_contains'),
           'prepared_contains_properly':
    1:         (BinaryPredicate, 'prepared_contains_properly'),
    1:     'prepared_covers': (BinaryPredicate, 'prepared_covers'),
           }
       
    1: IMPL311 = {
           }
       
       IMPL320 = {
    1:     'parallel_offset': (UnaryTopologicalOp, 'parallel_offset'),
    1:     'project_normalized': (ProjectOp, 'project_normalized'),
    1:     'project': (ProjectOp, 'project'),
    1:     'interpolate_normalized': (InterpolateOp, 'interpolate_normalized'),
    1:     'interpolate': (InterpolateOp, 'interpolate'),
    1:     'buffer_with_style': (UnaryTopologicalOp, 'buffer_with_style'),
    1:     'hausdorff_distance': (BinaryRealProperty, 'hausdorff_distance'),
           }
       
       IMPL330 = {
    1:     'is_closed': (UnaryPredicate, 'is_closed'),
    1:     'buffer_with_params': (UnaryTopologicalOp, 'buffer_with_params'),
       }
       
       
    1: def impl_items(defs):
   62:     return [(k, v[0](v[1])) for k, v in list(defs.items())]
       
    1: imp = GEOSImpl(dict(impl_items(IMPL300)))
    1: if lgeos.geos_version >= (3, 1, 0):
    1:     imp.update(impl_items(IMPL310))
    1: if lgeos.geos_version >= (3, 1, 1):
    1:     imp.update(impl_items(IMPL311))
    1: if lgeos.geos_version >= (3, 2, 0):
    1:     imp.update(impl_items(IMPL320))
    1: if lgeos.geos_version >= (3, 3, 0):
    1:     imp.update(impl_items(IMPL330))
       
    1: DefaultImplementation = imp
