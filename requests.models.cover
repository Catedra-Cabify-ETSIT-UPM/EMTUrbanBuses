       # -*- coding: utf-8 -*-
       
       """
       requests.models
       ~~~~~~~~~~~~~~~
       
       This module contains the primary objects that power Requests.
    1: """
       
    1: import datetime
    1: import sys
       
       # Import encoding now, to avoid implicit import later.
       # Implicit import within threads may cause LookupError when standard library is in a ZIP,
       # such as in Embedded Python. See https://github.com/requests/requests/issues/3578.
    1: import encodings.idna
       
    1: from urllib3.fields import RequestField
    1: from urllib3.filepost import encode_multipart_formdata
    1: from urllib3.util import parse_url
    1: from urllib3.exceptions import (
           DecodeError, ReadTimeoutError, ProtocolError, LocationParseError)
       
    1: from io import UnsupportedOperation
    1: from .hooks import default_hooks
    1: from .structures import CaseInsensitiveDict
       
    1: from .auth import HTTPBasicAuth
    1: from .cookies import cookiejar_from_dict, get_cookie_header, _copy_cookie_jar
    1: from .exceptions import (
           HTTPError, MissingSchema, InvalidURL, ChunkedEncodingError,
           ContentDecodingError, ConnectionError, StreamConsumedError)
    1: from ._internal_utils import to_native_string, unicode_is_ascii
    1: from .utils import (
           guess_filename, get_auth_from_url, requote_uri,
           stream_decode_response_unicode, to_key_val_list, parse_header_links,
           iter_slices, guess_json_utf, super_len, check_header_validity)
    1: from .compat import (
           Callable, Mapping,
           cookielib, urlunparse, urlsplit, urlencode, str, bytes,
           is_py2, chardet, builtin_str, basestring)
    1: from .compat import json as complexjson
    1: from .status_codes import codes
       
       #: The set of HTTP status codes that indicate an automatically
       #: processable redirect.
       REDIRECT_STATI = (
    1:     codes.moved,               # 301
    1:     codes.found,               # 302
    1:     codes.other,               # 303
    1:     codes.temporary_redirect,  # 307
    1:     codes.permanent_redirect,  # 308
       )
       
    1: DEFAULT_REDIRECT_LIMIT = 30
    1: CONTENT_CHUNK_SIZE = 10 * 1024
    1: ITER_CHUNK_SIZE = 512
       
       
    2: class RequestEncodingMixin(object):
    1:     @property
           def path_url(self):
               """Build the path URL to use."""
       
    1:         url = []
       
    1:         p = urlsplit(self.url)
       
    1:         path = p.path
    1:         if not path:
                   path = '/'
       
    1:         url.append(path)
       
    1:         query = p.query
    1:         if query:
                   url.append('?')
                   url.append(query)
       
    1:         return ''.join(url)
       
    1:     @staticmethod
           def _encode_params(data):
               """Encode parameters in a piece of data.
       
               Will successfully encode parameters when passed as a dict or a list of
               2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
               if parameters are supplied as a dict.
               """
       
    1:         if isinstance(data, (str, bytes)):
                   return data
    1:         elif hasattr(data, 'read'):
                   return data
    1:         elif hasattr(data, '__iter__'):
    1:             result = []
    1:             for k, vs in to_key_val_list(data):
                       if isinstance(vs, basestring) or not hasattr(vs, '__iter__'):
                           vs = [vs]
                       for v in vs:
                           if v is not None:
                               result.append(
                                   (k.encode('utf-8') if isinstance(k, str) else k,
                                    v.encode('utf-8') if isinstance(v, str) else v))
    1:             return urlencode(result, doseq=True)
               else:
                   return data
       
    1:     @staticmethod
           def _encode_files(files, data):
               """Build the body for a multipart/form-data request.
       
               Will successfully encode files when passed as a dict or a list of
               tuples. Order is retained if data is a list of tuples but arbitrary
               if parameters are supplied as a dict.
               The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)
               or 4-tuples (filename, fileobj, contentype, custom_headers).
               """
               if (not files):
                   raise ValueError("Files must be provided.")
               elif isinstance(data, basestring):
                   raise ValueError("Data must not be a string.")
       
               new_fields = []
               fields = to_key_val_list(data or {})
               files = to_key_val_list(files or {})
       
               for field, val in fields:
                   if isinstance(val, basestring) or not hasattr(val, '__iter__'):
                       val = [val]
                   for v in val:
                       if v is not None:
                           # Don't call str() on bytestrings: in Py3 it all goes wrong.
                           if not isinstance(v, bytes):
                               v = str(v)
       
                           new_fields.append(
                               (field.decode('utf-8') if isinstance(field, bytes) else field,
                                v.encode('utf-8') if isinstance(v, str) else v))
       
               for (k, v) in files:
                   # support for explicit filename
                   ft = None
                   fh = None
                   if isinstance(v, (tuple, list)):
                       if len(v) == 2:
                           fn, fp = v
                       elif len(v) == 3:
                           fn, fp, ft = v
                       else:
                           fn, fp, ft, fh = v
                   else:
                       fn = guess_filename(v) or k
                       fp = v
       
                   if isinstance(fp, (str, bytes, bytearray)):
                       fdata = fp
                   elif hasattr(fp, 'read'):
                       fdata = fp.read()
                   elif fp is None:
                       continue
                   else:
                       fdata = fp
       
                   rf = RequestField(name=k, data=fdata, filename=fn, headers=fh)
                   rf.make_multipart(content_type=ft)
                   new_fields.append(rf)
       
               body, content_type = encode_multipart_formdata(new_fields)
       
               return body, content_type
       
       
    2: class RequestHooksMixin(object):
    1:     def register_hook(self, event, hook):
               """Properly register a hook."""
       
    1:         if event not in self.hooks:
                   raise ValueError('Unsupported event specified, with event name "%s"' % (event))
       
    1:         if isinstance(hook, Callable):
                   self.hooks[event].append(hook)
    1:         elif hasattr(hook, '__iter__'):
    2:             self.hooks[event].extend(h for h in hook if isinstance(h, Callable))
       
    1:     def deregister_hook(self, event, hook):
               """Deregister a previously registered hook.
               Returns True if the hook existed, False if not.
               """
       
               try:
                   self.hooks[event].remove(hook)
                   return True
               except ValueError:
                   return False
       
       
    2: class Request(RequestHooksMixin):
           """A user-created :class:`Request <Request>` object.
       
           Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.
       
           :param method: HTTP method to use.
           :param url: URL to send.
           :param headers: dictionary of headers to send.
           :param files: dictionary of {filename: fileobject} files to multipart upload.
           :param data: the body to attach to the request. If a dictionary or
               list of tuples ``[(key, value)]`` is provided, form-encoding will
               take place.
           :param json: json for the body to attach to the request (if files or data is not specified).
           :param params: URL parameters to append to the URL. If a dictionary or
               list of tuples ``[(key, value)]`` is provided, form-encoding will
               take place.
           :param auth: Auth handler or (user, pass) tuple.
           :param cookies: dictionary or CookieJar of cookies to attach to this request.
           :param hooks: dictionary of callback hooks, for internal usage.
       
           Usage::
       
             >>> import requests
             >>> req = requests.Request('GET', 'https://httpbin.org/get')
             >>> req.prepare()
             <PreparedRequest [GET]>
    1:     """
       
           def __init__(self,
                   method=None, url=None, headers=None, files=None, data=None,
    1:             params=None, auth=None, cookies=None, hooks=None, json=None):
       
               # Default empty dicts for dict params.
    1:         data = [] if data is None else data
    1:         files = [] if files is None else files
    1:         headers = {} if headers is None else headers
    1:         params = {} if params is None else params
    1:         hooks = {} if hooks is None else hooks
       
    1:         self.hooks = default_hooks()
    1:         for (k, v) in list(hooks.items()):
                   self.register_hook(event=k, hook=v)
       
    1:         self.method = method
    1:         self.url = url
    1:         self.headers = headers
    1:         self.files = files
    1:         self.data = data
    1:         self.json = json
    1:         self.params = params
    1:         self.auth = auth
    1:         self.cookies = cookies
       
    1:     def __repr__(self):
               return '<Request [%s]>' % (self.method)
       
    1:     def prepare(self):
               """Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it."""
               p = PreparedRequest()
               p.prepare(
                   method=self.method,
                   url=self.url,
                   headers=self.headers,
                   files=self.files,
                   data=self.data,
                   json=self.json,
                   params=self.params,
                   auth=self.auth,
                   cookies=self.cookies,
                   hooks=self.hooks,
               )
               return p
       
       
    2: class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
           """The fully mutable :class:`PreparedRequest <PreparedRequest>` object,
           containing the exact bytes that will be sent to the server.
       
           Generated from either a :class:`Request <Request>` object or manually.
       
           Usage::
       
             >>> import requests
             >>> req = requests.Request('GET', 'https://httpbin.org/get')
             >>> r = req.prepare()
             <PreparedRequest [GET]>
       
             >>> s = requests.Session()
             >>> s.send(r)
             <Response [200]>
    1:     """
       
    1:     def __init__(self):
               #: HTTP verb to send to the server.
    1:         self.method = None
               #: HTTP URL to send the request to.
    1:         self.url = None
               #: dictionary of HTTP headers.
    1:         self.headers = None
               # The `CookieJar` used to create the Cookie header will be stored here
               # after prepare_cookies is called
    1:         self._cookies = None
               #: request body to send to the server.
    1:         self.body = None
               #: dictionary of callback hooks, for internal usage.
    1:         self.hooks = default_hooks()
               #: integer denoting starting position of a readable file-like body.
    1:         self._body_position = None
       
           def prepare(self,
                   method=None, url=None, headers=None, files=None, data=None,
    1:             params=None, auth=None, cookies=None, hooks=None, json=None):
               """Prepares the entire request with the given parameters."""
       
    1:         self.prepare_method(method)
    1:         self.prepare_url(url, params)
    1:         self.prepare_headers(headers)
    1:         self.prepare_cookies(cookies)
    1:         self.prepare_body(data, files, json)
    1:         self.prepare_auth(auth, url)
       
               # Note that prepare_auth must be last to enable authentication schemes
               # such as OAuth to work on a fully prepared request.
       
               # This MUST go after prepare_auth. Authenticators could add a hook
    1:         self.prepare_hooks(hooks)
       
    1:     def __repr__(self):
               return '<PreparedRequest [%s]>' % (self.method)
       
    1:     def copy(self):
               p = PreparedRequest()
               p.method = self.method
               p.url = self.url
               p.headers = self.headers.copy() if self.headers is not None else None
               p._cookies = _copy_cookie_jar(self._cookies)
               p.body = self.body
               p.hooks = self.hooks
               p._body_position = self._body_position
               return p
       
    1:     def prepare_method(self, method):
               """Prepares the given HTTP method."""
    1:         self.method = method
    1:         if self.method is not None:
    1:             self.method = to_native_string(self.method.upper())
       
    1:     @staticmethod
           def _get_idna_encoded_host(host):
               import idna
       
               try:
                   host = idna.encode(host, uts46=True).decode('utf-8')
               except idna.IDNAError:
                   raise UnicodeError
               return host
       
    1:     def prepare_url(self, url, params):
               """Prepares the given HTTP URL."""
               #: Accept objects that have string representations.
               #: We're unable to blindly call unicode/str functions
               #: as this will include the bytestring indicator (b'')
               #: on python 3.x.
               #: https://github.com/requests/requests/pull/2238
    1:         if isinstance(url, bytes):
                   url = url.decode('utf8')
               else:
    1:             url = unicode(url) if is_py2 else str(url)
       
               # Remove leading whitespaces from url
    1:         url = url.lstrip()
       
               # Don't do any URL preparation for non-HTTP schemes like `mailto`,
               # `data` etc to work around exceptions from `url_parse`, which
               # handles RFC 3986 only.
    1:         if ':' in url and not url.lower().startswith('http'):
                   self.url = url
                   return
       
               # Support for unicode domain names and paths.
    1:         try:
    1:             scheme, auth, host, port, path, query, fragment = parse_url(url)
               except LocationParseError as e:
                   raise InvalidURL(*e.args)
       
    1:         if not scheme:
                   error = ("Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?")
                   error = error.format(to_native_string(url, 'utf8'))
       
                   raise MissingSchema(error)
       
    1:         if not host:
                   raise InvalidURL("Invalid URL %r: No host supplied" % url)
       
               # In general, we want to try IDNA encoding the hostname if the string contains
               # non-ASCII characters. This allows users to automatically get the correct IDNA
               # behaviour. For strings containing only ASCII characters, we need to also verify
               # it doesn't start with a wildcard (*), before allowing the unencoded hostname.
    1:         if not unicode_is_ascii(host):
                   try:
                       host = self._get_idna_encoded_host(host)
                   except UnicodeError:
                       raise InvalidURL('URL has an invalid label.')
    1:         elif host.startswith(u'*'):
                   raise InvalidURL('URL has an invalid label.')
       
               # Carefully reconstruct the network location
    1:         netloc = auth or ''
    1:         if netloc:
                   netloc += '@'
    1:         netloc += host
    1:         if port:
                   netloc += ':' + str(port)
       
               # Bare domains aren't valid URLs.
    1:         if not path:
                   path = '/'
       
    1:         if is_py2:
                   if isinstance(scheme, str):
                       scheme = scheme.encode('utf-8')
                   if isinstance(netloc, str):
                       netloc = netloc.encode('utf-8')
                   if isinstance(path, str):
                       path = path.encode('utf-8')
                   if isinstance(query, str):
                       query = query.encode('utf-8')
                   if isinstance(fragment, str):
                       fragment = fragment.encode('utf-8')
       
    1:         if isinstance(params, (str, bytes)):
                   params = to_native_string(params)
       
    1:         enc_params = self._encode_params(params)
    1:         if enc_params:
                   if query:
                       query = '%s&%s' % (query, enc_params)
                   else:
                       query = enc_params
       
    1:         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))
    1:         self.url = url
       
    1:     def prepare_headers(self, headers):
               """Prepares the given HTTP headers."""
       
    1:         self.headers = CaseInsensitiveDict()
    1:         if headers:
    7:             for header in headers.items():
                       # Raise exception on invalid header value.
    6:                 check_header_validity(header)
    6:                 name, value = header
    6:                 self.headers[to_native_string(name)] = value
       
    1:     def prepare_body(self, data, files, json=None):
               """Prepares the given HTTP body data."""
       
               # Check if file, fo, generator, iterator.
               # If not, run through normal process.
       
               # Nottin' on you.
    1:         body = None
    1:         content_type = None
       
    1:         if not data and json is not None:
                   # urllib3 requires a bytes-like body. Python 2's json.dumps
                   # provides this natively, but Python 3 gives a Unicode string.
                   content_type = 'application/json'
                   body = complexjson.dumps(json)
                   if not isinstance(body, bytes):
                       body = body.encode('utf-8')
       
    1:         is_stream = all([
    1:             hasattr(data, '__iter__'),
    1:             not isinstance(data, (basestring, list, tuple, Mapping))
               ])
       
    1:         try:
    1:             length = super_len(data)
               except (TypeError, AttributeError, UnsupportedOperation):
                   length = None
       
    1:         if is_stream:
                   body = data
       
                   if getattr(body, 'tell', None) is not None:
                       # Record the current file position before reading.
                       # This will allow us to rewind a file in the event
                       # of a redirect.
                       try:
                           self._body_position = body.tell()
                       except (IOError, OSError):
                           # This differentiates from None, allowing us to catch
                           # a failed `tell()` later when trying to rewind the body
                           self._body_position = object()
       
                   if files:
                       raise NotImplementedError('Streamed bodies and files are mutually exclusive.')
       
                   if length:
                       self.headers['Content-Length'] = builtin_str(length)
                   else:
                       self.headers['Transfer-Encoding'] = 'chunked'
               else:
                   # Multi-part file uploads.
    1:             if files:
                       (body, content_type) = self._encode_files(files, data)
                   else:
    1:                 if data:
                           body = self._encode_params(data)
                           if isinstance(data, basestring) or hasattr(data, 'read'):
                               content_type = None
                           else:
                               content_type = 'application/x-www-form-urlencoded'
       
    1:             self.prepare_content_length(body)
       
                   # Add content-type if it wasn't explicitly provided.
    1:             if content_type and ('content-type' not in self.headers):
                       self.headers['Content-Type'] = content_type
       
    1:         self.body = body
       
    1:     def prepare_content_length(self, body):
               """Prepare Content-Length header based on request method and body"""
    1:         if body is not None:
                   length = super_len(body)
                   if length:
                       # If length exists, set it. Otherwise, we fallback
                       # to Transfer-Encoding: chunked.
                       self.headers['Content-Length'] = builtin_str(length)
    1:         elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:
                   # Set Content-Length to 0 for methods that can have a body
                   # but don't provide one. (i.e. not GET or HEAD)
                   self.headers['Content-Length'] = '0'
       
    1:     def prepare_auth(self, auth, url=''):
               """Prepares the given HTTP auth data."""
       
               # If no Auth is explicitly provided, extract it from the URL first.
    1:         if auth is None:
    1:             url_auth = get_auth_from_url(self.url)
    1:             auth = url_auth if any(url_auth) else None
       
    1:         if auth:
                   if isinstance(auth, tuple) and len(auth) == 2:
                       # special-case basic HTTP auth
                       auth = HTTPBasicAuth(*auth)
       
                   # Allow auth to make its changes.
                   r = auth(self)
       
                   # Update self to reflect the auth changes.
                   self.__dict__.update(r.__dict__)
       
                   # Recompute Content-Length
                   self.prepare_content_length(self.body)
       
    1:     def prepare_cookies(self, cookies):
               """Prepares the given HTTP cookie data.
       
               This function eventually generates a ``Cookie`` header from the
               given cookies using cookielib. Due to cookielib's design, the header
               will not be regenerated if it already exists, meaning this function
               can only be called once for the life of the
               :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls
               to ``prepare_cookies`` will have no actual effect, unless the "Cookie"
               header is removed beforehand.
               """
    1:         if isinstance(cookies, cookielib.CookieJar):
    1:             self._cookies = cookies
               else:
                   self._cookies = cookiejar_from_dict(cookies)
       
    1:         cookie_header = get_cookie_header(self._cookies, self)
    1:         if cookie_header is not None:
                   self.headers['Cookie'] = cookie_header
       
    1:     def prepare_hooks(self, hooks):
               """Prepares the given hooks."""
               # hooks can be passed as None to the prepare method and to this
               # method. To prevent iterating over None, simply use an empty list
               # if hooks is False-y
    1:         hooks = hooks or []
    2:         for event in hooks:
    1:             self.register_hook(event, hooks[event])
       
       
    2: class Response(object):
           """The :class:`Response <Response>` object, which contains a
           server's response to an HTTP request.
    1:     """
       
           __attrs__ = [
    1:         '_content', 'status_code', 'headers', 'url', 'history',
    1:         'encoding', 'reason', 'cookies', 'elapsed', 'request'
           ]
       
    1:     def __init__(self):
    1:         self._content = False
    1:         self._content_consumed = False
    1:         self._next = None
       
               #: Integer Code of responded HTTP Status, e.g. 404 or 200.
    1:         self.status_code = None
       
               #: Case-insensitive Dictionary of Response Headers.
               #: For example, ``headers['content-encoding']`` will return the
               #: value of a ``'Content-Encoding'`` response header.
    1:         self.headers = CaseInsensitiveDict()
       
               #: File-like object representation of response (for advanced usage).
               #: Use of ``raw`` requires that ``stream=True`` be set on the request.
               # This requirement does not apply for use internally to Requests.
    1:         self.raw = None
       
               #: Final URL location of Response.
    1:         self.url = None
       
               #: Encoding to decode with when accessing r.text.
    1:         self.encoding = None
       
               #: A list of :class:`Response <Response>` objects from
               #: the history of the Request. Any redirect responses will end
               #: up here. The list is sorted from the oldest to the most recent request.
    1:         self.history = []
       
               #: Textual reason of responded HTTP Status, e.g. "Not Found" or "OK".
    1:         self.reason = None
       
               #: A CookieJar of Cookies the server sent back.
    1:         self.cookies = cookiejar_from_dict({})
       
               #: The amount of time elapsed between sending the request
               #: and the arrival of the response (as a timedelta).
               #: This property specifically measures the time taken between sending
               #: the first byte of the request and finishing parsing the headers. It
               #: is therefore unaffected by consuming the response content or the
               #: value of the ``stream`` keyword argument.
    1:         self.elapsed = datetime.timedelta(0)
       
               #: The :class:`PreparedRequest <PreparedRequest>` object to which this
               #: is a response.
    1:         self.request = None
       
    1:     def __enter__(self):
               return self
       
    1:     def __exit__(self, *args):
               self.close()
       
    1:     def __getstate__(self):
               # Consume everything; accessing the content attribute makes
               # sure the content has been fully read.
               if not self._content_consumed:
                   self.content
       
               return {attr: getattr(self, attr, None) for attr in self.__attrs__}
       
    1:     def __setstate__(self, state):
               for name, value in state.items():
                   setattr(self, name, value)
       
               # pickled objects do not have .raw
               setattr(self, '_content_consumed', True)
               setattr(self, 'raw', None)
       
    1:     def __repr__(self):
               return '<Response [%s]>' % (self.status_code)
       
    1:     def __bool__(self):
               """Returns True if :attr:`status_code` is less than 400.
       
               This attribute checks if the status code of the response is between
               400 and 600 to see if there was a client error or a server error. If
               the status code, is between 200 and 400, this will return True. This
               is **not** a check to see if the response code is ``200 OK``.
               """
               return self.ok
       
    1:     def __nonzero__(self):
               """Returns True if :attr:`status_code` is less than 400.
       
               This attribute checks if the status code of the response is between
               400 and 600 to see if there was a client error or a server error. If
               the status code, is between 200 and 400, this will return True. This
               is **not** a check to see if the response code is ``200 OK``.
               """
               return self.ok
       
    1:     def __iter__(self):
               """Allows you to use a response as an iterator."""
               return self.iter_content(128)
       
    1:     @property
           def ok(self):
               """Returns True if :attr:`status_code` is less than 400, False if not.
       
               This attribute checks if the status code of the response is between
               400 and 600 to see if there was a client error or a server error. If
               the status code is between 200 and 400, this will return True. This
               is **not** a check to see if the response code is ``200 OK``.
               """
               try:
                   self.raise_for_status()
               except HTTPError:
                   return False
               return True
       
    1:     @property
           def is_redirect(self):
               """True if this Response is a well-formed HTTP redirect that could have
               been processed automatically (by :meth:`Session.resolve_redirects`).
               """
    1:         return ('location' in self.headers and self.status_code in REDIRECT_STATI)
       
    1:     @property
           def is_permanent_redirect(self):
               """True if this Response one of the permanent versions of redirect."""
               return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))
       
    1:     @property
           def next(self):
               """Returns a PreparedRequest for the next request in a redirect chain, if there is one."""
               return self._next
       
    1:     @property
           def apparent_encoding(self):
               """The apparent encoding, provided by the chardet library."""
               return chardet.detect(self.content)['encoding']
       
    1:     def iter_content(self, chunk_size=1, decode_unicode=False):
               """Iterates over the response data.  When stream=True is set on the
               request, this avoids reading the content at once into memory for
               large responses.  The chunk size is the number of bytes it should
               read into memory.  This is not necessarily the length of each item
               returned as decoding can take place.
       
               chunk_size must be of type int or None. A value of None will
               function differently depending on the value of `stream`.
               stream=True will read data as it arrives in whatever size the
               chunks are received. If stream=False, data is returned as
               a single chunk.
       
               If decode_unicode is True, content will be decoded using the best
               available encoding based on the response.
               """
       
    1:         def generate():
                   # Special case for urllib3.
    1:             if hasattr(self.raw, 'stream'):
    1:                 try:
    2:                     for chunk in self.raw.stream(chunk_size, decode_content=True):
    1:                         yield chunk
                       except ProtocolError as e:
                           raise ChunkedEncodingError(e)
                       except DecodeError as e:
                           raise ContentDecodingError(e)
                       except ReadTimeoutError as e:
                           raise ConnectionError(e)
                   else:
                       # Standard file-like object.
                       while True:
                           chunk = self.raw.read(chunk_size)
                           if not chunk:
                               break
                           yield chunk
       
    1:             self._content_consumed = True
       
    1:         if self._content_consumed and isinstance(self._content, bool):
                   raise StreamConsumedError()
    1:         elif chunk_size is not None and not isinstance(chunk_size, int):
                   raise TypeError("chunk_size must be an int, it is instead a %s." % type(chunk_size))
               # simulate reading small chunks of the content
    1:         reused_chunks = iter_slices(self._content, chunk_size)
       
    1:         stream_chunks = generate()
       
    1:         chunks = reused_chunks if self._content_consumed else stream_chunks
       
    1:         if decode_unicode:
                   chunks = stream_decode_response_unicode(chunks, self)
       
    1:         return chunks
       
    1:     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):
               """Iterates over the response data, one line at a time.  When
               stream=True is set on the request, this avoids reading the
               content at once into memory for large responses.
       
               .. note:: This method is not reentrant safe.
               """
       
               pending = None
       
               for chunk in self.iter_content(chunk_size=chunk_size, decode_unicode=decode_unicode):
       
                   if pending is not None:
                       chunk = pending + chunk
       
                   if delimiter:
                       lines = chunk.split(delimiter)
                   else:
                       lines = chunk.splitlines()
       
                   if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:
                       pending = lines.pop()
                   else:
                       pending = None
       
                   for line in lines:
                       yield line
       
               if pending is not None:
                   yield pending
       
    1:     @property
           def content(self):
               """Content of the response, in bytes."""
       
    5:         if self._content is False:
                   # Read the contents.
    1:             if self._content_consumed:
                       raise RuntimeError(
                           'The content for this response was already consumed')
       
    1:             if self.status_code == 0 or self.raw is None:
                       self._content = None
                   else:
    1:                 self._content = b''.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b''
       
    5:         self._content_consumed = True
               # don't need to release the connection; that's been handled by urllib3
               # since we exhausted the data.
    5:         return self._content
       
    1:     @property
           def text(self):
               """Content of the response, in unicode.
       
               If Response.encoding is None, encoding will be guessed using
               ``chardet``.
       
               The encoding of the response content is determined based solely on HTTP
               headers, following RFC 2616 to the letter. If you can take advantage of
               non-HTTP knowledge to make a better guess at the encoding, you should
               set ``r.encoding`` appropriately before accessing this property.
               """
       
               # Try charset from content-type
               content = None
               encoding = self.encoding
       
               if not self.content:
                   return str('')
       
               # Fallback to auto-detected encoding.
               if self.encoding is None:
                   encoding = self.apparent_encoding
       
               # Decode unicode from given encoding.
               try:
                   content = str(self.content, encoding, errors='replace')
               except (LookupError, TypeError):
                   # A LookupError is raised if the encoding was not found which could
                   # indicate a misspelling or similar mistake.
                   #
                   # A TypeError can be raised if encoding is None
                   #
                   # So we try blindly encoding.
                   content = str(self.content, errors='replace')
       
               return content
       
    1:     def json(self, **kwargs):
               r"""Returns the json-encoded content of a response, if any.
       
               :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
               :raises ValueError: If the response body does not contain valid json.
               """
       
    1:         if not self.encoding and self.content and len(self.content) > 3:
                   # No encoding set. JSON RFC 4627 section 3 states we should expect
                   # UTF-8, -16 or -32. Detect which one to use; If the detection or
                   # decoding fails, fall back to `self.text` (using chardet to make
                   # a best guess).
    1:             encoding = guess_json_utf(self.content)
    1:             if encoding is not None:
    1:                 try:
    1:                     return complexjson.loads(
    1:                         self.content.decode(encoding), **kwargs
                           )
                       except UnicodeDecodeError:
                           # Wrong UTF codec detected; usually because it's not UTF-8
                           # but some other 8-bit codec.  This is an RFC violation,
                           # and the server didn't bother to tell us what codec *was*
                           # used.
                           pass
               return complexjson.loads(self.text, **kwargs)
       
    1:     @property
           def links(self):
               """Returns the parsed header links of the response, if any."""
       
               header = self.headers.get('link')
       
               # l = MultiDict()
               l = {}
       
               if header:
                   links = parse_header_links(header)
       
                   for link in links:
                       key = link.get('rel') or link.get('url')
                       l[key] = link
       
               return l
       
    1:     def raise_for_status(self):
               """Raises stored :class:`HTTPError`, if one occurred."""
       
               http_error_msg = ''
               if isinstance(self.reason, bytes):
                   # We attempt to decode utf-8 first because some servers
                   # choose to localize their reason strings. If the string
                   # isn't utf-8, we fall back to iso-8859-1 for all other
                   # encodings. (See PR #3538)
                   try:
                       reason = self.reason.decode('utf-8')
                   except UnicodeDecodeError:
                       reason = self.reason.decode('iso-8859-1')
               else:
                   reason = self.reason
       
               if 400 <= self.status_code < 500:
                   http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
       
               elif 500 <= self.status_code < 600:
                   http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
       
               if http_error_msg:
                   raise HTTPError(http_error_msg, response=self)
       
    1:     def close(self):
               """Releases the connection back to the pool. Once this method has been
               called the underlying ``raw`` object must not be accessed again.
       
               *Note: Should not normally need to be called explicitly.*
               """
               if not self._content_consumed:
                   self.raw.close()
       
               release_conn = getattr(self.raw, 'release_conn', None)
               if release_conn is not None:
                   release_conn()
