       """
       Filters are objects that you can use to filter names in different scopes. They
       are needed for name resolution.
    1: """
    1: from abc import abstractmethod
    1: import weakref
       
    1: from parso.tree import search_ancestor
       
    1: from jedi._compatibility import use_metaclass
    1: from jedi.evaluate import flow_analysis
    1: from jedi.evaluate.base_context import ContextSet, Context, ContextWrapper, \
           LazyContextWrapper
    1: from jedi.parser_utils import get_cached_parent_scope
    1: from jedi.evaluate.utils import to_list
    1: from jedi.evaluate.names import TreeNameDefinition, ParamName, AbstractNameDefinition
       
    1: _definition_name_cache = weakref.WeakKeyDictionary()
       
       
    2: class AbstractFilter(object):
    1:     _until_position = None
       
    1:     def _filter(self, names):
               if self._until_position is not None:
                   return [n for n in names if n.start_pos < self._until_position]
               return names
       
    1:     @abstractmethod
           def get(self, name):
               raise NotImplementedError
       
    1:     @abstractmethod
           def values(self):
               raise NotImplementedError
       
       
    2: class FilterWrapper(object):
    1:     name_wrapper_class = None
       
    1:     def __init__(self, wrapped_filter):
               self._wrapped_filter = wrapped_filter
       
    1:     def wrap_names(self, names):
               return [self.name_wrapper_class(name) for name in names]
       
    1:     def get(self, name):
               return self.wrap_names(self._wrapped_filter.get(name))
       
    1:     def values(self):
               return self.wrap_names(self._wrapped_filter.values())
       
       
    1: def _get_definition_names(used_names, name_key):
           try:
               for_module = _definition_name_cache[used_names]
           except KeyError:
               for_module = _definition_name_cache[used_names] = {}
       
           try:
               return for_module[name_key]
           except KeyError:
               names = used_names.get(name_key, ())
               result = for_module[name_key] = tuple(name for name in names if name.is_definition())
               return result
       
       
    2: class AbstractUsedNamesFilter(AbstractFilter):
    1:     name_class = TreeNameDefinition
       
    1:     def __init__(self, context, parser_scope):
               self._parser_scope = parser_scope
               self._module_node = self._parser_scope.get_root_node()
               self._used_names = self._module_node.get_used_names()
               self.context = context
       
    1:     def get(self, name, **filter_kwargs):
               return self._convert_names(self._filter(
                   _get_definition_names(self._used_names, name),
                   **filter_kwargs
               ))
       
    1:     def _convert_names(self, names):
               return [self.name_class(self.context, name) for name in names]
       
    1:     def values(self, **filter_kwargs):
               return self._convert_names(
                   name
                   for name_key in self._used_names
                   for name in self._filter(
                       _get_definition_names(self._used_names, name_key),
                       **filter_kwargs
                   )
               )
       
    1:     def __repr__(self):
               return '<%s: %s>' % (self.__class__.__name__, self.context)
       
       
    2: class ParserTreeFilter(AbstractUsedNamesFilter):
           # TODO remove evaluator as an argument, it's not used.
           def __init__(self, evaluator, context, node_context=None, until_position=None,
    1:                  origin_scope=None):
               """
               node_context is an option to specify a second context for use cases
               like the class mro where the parent class of a new name would be the
               context, but for some type inference it's important to have a local
               context of the other classes.
               """
               if node_context is None:
                   node_context = context
               super(ParserTreeFilter, self).__init__(context, node_context.tree_node)
               self._node_context = node_context
               self._origin_scope = origin_scope
               self._until_position = until_position
       
    1:     def _filter(self, names):
               names = super(ParserTreeFilter, self)._filter(names)
               names = [n for n in names if self._is_name_reachable(n)]
               return list(self._check_flows(names))
       
    1:     def _is_name_reachable(self, name):
               parent = name.parent
               if parent.type == 'trailer':
                   return False
               base_node = parent if parent.type in ('classdef', 'funcdef') else name
               return get_cached_parent_scope(self._used_names, base_node) == self._parser_scope
       
    1:     def _check_flows(self, names):
               for name in sorted(names, key=lambda name: name.start_pos, reverse=True):
                   check = flow_analysis.reachability_check(
                       context=self._node_context,
                       context_scope=self._parser_scope,
                       node=name,
                       origin_scope=self._origin_scope
                   )
                   if check is not flow_analysis.UNREACHABLE:
                       yield name
       
                   if check is flow_analysis.REACHABLE:
                       break
       
       
    2: class FunctionExecutionFilter(ParserTreeFilter):
    1:     param_name = ParamName
       
           def __init__(self, evaluator, context, node_context=None,
    1:                  until_position=None, origin_scope=None):
               super(FunctionExecutionFilter, self).__init__(
                   evaluator,
                   context,
                   node_context,
                   until_position,
                   origin_scope
               )
       
    1:     @to_list
           def _convert_names(self, names):
               for name in names:
                   param = search_ancestor(name, 'param')
                   if param:
                       yield self.param_name(self.context, name)
                   else:
                       yield TreeNameDefinition(self.context, name)
       
       
    2: class GlobalNameFilter(AbstractUsedNamesFilter):
    1:     def __init__(self, context, parser_scope):
               super(GlobalNameFilter, self).__init__(context, parser_scope)
       
    1:     def get(self, name):
               try:
                   names = self._used_names[name]
               except KeyError:
                   return []
               return self._convert_names(self._filter(names))
       
    1:     @to_list
           def _filter(self, names):
               for name in names:
                   if name.parent.type == 'global_stmt':
                       yield name
       
    1:     def values(self):
               return self._convert_names(
                   name for name_list in self._used_names.values()
                   for name in self._filter(name_list)
               )
       
       
    2: class DictFilter(AbstractFilter):
    1:     def __init__(self, dct):
               self._dct = dct
       
    1:     def get(self, name):
               try:
                   value = self._convert(name, self._dct[name])
               except KeyError:
                   return []
               else:
                   return list(self._filter([value]))
       
    1:     def values(self):
               def yielder():
                   for item in self._dct.items():
                       try:
                           yield self._convert(*item)
                       except KeyError:
                           pass
               return self._filter(yielder())
       
    1:     def _convert(self, name, value):
               return value
       
    1:     def __repr__(self):
               keys = ', '.join(self._dct.keys())
               return '<%s: for {%s}>' % (self.__class__.__name__, keys)
       
       
    2: class MergedFilter(object):
    1:     def __init__(self, *filters):
               self._filters = filters
       
    1:     def get(self, name):
               return [n for filter in self._filters for n in filter.get(name)]
       
    1:     def values(self):
               return [n for filter in self._filters for n in filter.values()]
       
    1:     def __repr__(self):
               return '%s(%s)' % (self.__class__.__name__, ', '.join(str(f) for f in self._filters))
       
       
    2: class _BuiltinMappedMethod(Context):
    1:     """``Generator.__next__`` ``dict.values`` methods and so on."""
    1:     api_type = u'function'
       
    1:     def __init__(self, builtin_context, method, builtin_func):
               super(_BuiltinMappedMethod, self).__init__(
                   builtin_context.evaluator,
                   parent_context=builtin_context
               )
               self._method = method
               self._builtin_func = builtin_func
       
    1:     def py__call__(self, arguments):
               # TODO add TypeError if params are given/or not correct.
               return self._method(self.parent_context)
       
    1:     def __getattr__(self, name):
               return getattr(self._builtin_func, name)
       
       
    2: class SpecialMethodFilter(DictFilter):
           """
           A filter for methods that are defined in this module on the corresponding
           classes like Generator (for __next__, etc).
    1:     """
    2:     class SpecialMethodName(AbstractNameDefinition):
    1:         api_type = u'function'
       
    1:         def __init__(self, parent_context, string_name, value, builtin_context):
                   callable_, python_version = value
                   if python_version is not None and \
                           python_version != parent_context.evaluator.environment.version_info.major:
                       raise KeyError
       
                   self.parent_context = parent_context
                   self.string_name = string_name
                   self._callable = callable_
                   self._builtin_context = builtin_context
       
    1:         def infer(self):
                   for filter in self._builtin_context.get_filters():
                       # We can take the first index, because on builtin methods there's
                       # always only going to be one name. The same is true for the
                       # inferred values.
                       for name in filter.get(self.string_name):
                           builtin_func = next(iter(name.infer()))
                           break
                       else:
                           continue
                       break
                   return ContextSet([
                       _BuiltinMappedMethod(self.parent_context, self._callable, builtin_func)
                   ])
       
    1:     def __init__(self, context, dct, builtin_context):
               super(SpecialMethodFilter, self).__init__(dct)
               self.context = context
               self._builtin_context = builtin_context
               """
               This context is what will be used to introspect the name, where as the
               other context will be used to execute the function.
       
               We distinguish, because we have to.
               """
       
    1:     def _convert(self, name, value):
               return self.SpecialMethodName(self.context, name, value, self._builtin_context)
       
       
    2: class _OverwriteMeta(type):
    1:     def __init__(cls, name, bases, dct):
   21:         super(_OverwriteMeta, cls).__init__(name, bases, dct)
       
   21:         base_dct = {}
   55:         for base_cls in reversed(cls.__bases__):
   34:             try:
   34:                 base_dct.update(base_cls.overwritten_methods)
   15:             except AttributeError:
   15:                 pass
       
  144:         for func in cls.__dict__.values():
  123:             try:
  123:                 base_dct.update(func.registered_overwritten_methods)
  114:             except AttributeError:
  114:                 pass
   21:         cls.overwritten_methods = base_dct
       
       
    2: class _AttributeOverwriteMixin(object):
    1:     def get_filters(self, search_global=False, *args, **kwargs):
               yield SpecialMethodFilter(self, self.overwritten_methods, self._wrapped_context)
       
               for filter in self._wrapped_context.get_filters(search_global):
                   yield filter
       
       
    2: class LazyAttributeOverwrite(use_metaclass(_OverwriteMeta, _AttributeOverwriteMixin,
    1:                                            LazyContextWrapper)):
    1:     def __init__(self, evaluator):
               self.evaluator = evaluator
       
       
    2: class AttributeOverwrite(use_metaclass(_OverwriteMeta, _AttributeOverwriteMixin,
    1:                                        ContextWrapper)):
    1:     pass
       
       
    1: def publish_method(method_name, python_version_match=None):
   12:     def decorator(func):
   12:         dct = func.__dict__.setdefault('registered_overwritten_methods', {})
   12:         dct[method_name] = func, python_version_match
   12:         return func
   12:     return decorator
       
       
    1: def get_global_filters(evaluator, context, until_position, origin_scope):
           """
           Returns all filters in order of priority for name resolution.
       
           For global name lookups. The filters will handle name resolution
           themselves, but here we gather possible filters downwards.
       
           >>> from jedi._compatibility import u, no_unicode_pprint
           >>> from jedi import Script
           >>> script = Script(u('''
           ... x = ['a', 'b', 'c']
           ... def func():
           ...     y = None
           ... '''))
           >>> module_node = script._module_node
           >>> scope = next(module_node.iter_funcdefs())
           >>> scope
           <Function: func@3-5>
           >>> context = script._get_module().create_context(scope)
           >>> filters = list(get_global_filters(context.evaluator, context, (4, 0), None))
       
           First we get the names from the function scope.
       
           >>> no_unicode_pprint(filters[0])  # doctest: +ELLIPSIS
           MergedFilter(<ParserTreeFilter: ...>, <GlobalNameFilter: ...>)
           >>> sorted(str(n) for n in filters[0].values())  # doctest: +NORMALIZE_WHITESPACE
           ['<TreeNameDefinition: string_name=func start_pos=(3, 4)>',
            '<TreeNameDefinition: string_name=x start_pos=(2, 0)>']
           >>> filters[0]._filters[0]._until_position
           (4, 0)
           >>> filters[0]._filters[1]._until_position
       
           Then it yields the names from one level "lower". In this example, this is
           the module scope (including globals).
           As a side note, you can see, that the position in the filter is None on the
           globals filter, because there the whole module is searched.
       
           >>> list(filters[1].values())  # package modules -> Also empty.
           []
           >>> sorted(name.string_name for name in filters[2].values())  # Module attributes
           ['__doc__', '__name__', '__package__']
       
           Finally, it yields the builtin filter, if `include_builtin` is
           true (default).
       
           >>> list(filters[3].values())  # doctest: +ELLIPSIS
           [...]
           """
           from jedi.evaluate.context.function import FunctionExecutionContext
           while context is not None:
               # Names in methods cannot be resolved within the class.
               for filter in context.get_filters(
                       search_global=True,
                       until_position=until_position,
                       origin_scope=origin_scope):
                   yield filter
               if isinstance(context, FunctionExecutionContext):
                   # The position should be reset if the current scope is a function.
                   until_position = None
       
               context = context.parent_context
       
           # Add builtins to the global scope.
           yield next(evaluator.builtins_module.get_filters())
