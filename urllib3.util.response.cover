    1: from __future__ import absolute_import
    1: from ..packages.six.moves import http_client as httplib
       
    1: from ..exceptions import HeaderParsingError
       
       
    1: def is_fp_closed(obj):
           """
           Checks whether a given file-like object is closed.
       
           :param obj:
               The file-like object to check.
           """
       
    2:     try:
               # Check `isclosed()` first, in case Python3 doesn't set `closed`.
               # GH Issue #928
    2:         return obj.isclosed()
           except AttributeError:
               pass
       
           try:
               # Check via the official file-like-object way.
               return obj.closed
           except AttributeError:
               pass
       
           try:
               # Check if the object is a container for another file-like object that
               # gets released on exhaustion (e.g. HTTPResponse).
               return obj.fp is None
           except AttributeError:
               pass
       
           raise ValueError("Unable to determine whether fp is closed.")
       
       
    1: def assert_header_parsing(headers):
           """
           Asserts whether all headers have been successfully parsed.
           Extracts encountered errors from the result of parsing headers.
       
           Only works on Python 3.
       
           :param headers: Headers to verify.
           :type headers: `httplib.HTTPMessage`.
       
           :raises urllib3.exceptions.HeaderParsingError:
               If parsing errors are found.
           """
       
           # This will fail silently if we pass in the wrong kind of parameter.
           # To make debugging easier add an explicit check.
    1:     if not isinstance(headers, httplib.HTTPMessage):
               raise TypeError('expected httplib.Message, got {0}.'.format(
                   type(headers)))
       
    1:     defects = getattr(headers, 'defects', None)
    1:     get_payload = getattr(headers, 'get_payload', None)
       
    1:     unparsed_data = None
    1:     if get_payload:
               # get_payload is actually email.message.Message.get_payload;
               # we're only interested in the result if it's not a multipart message
    1:         if not headers.is_multipart():
    1:             payload = get_payload()
       
    1:             if isinstance(payload, (bytes, str)):
    1:                 unparsed_data = payload
       
    1:     if defects or unparsed_data:
               raise HeaderParsingError(defects=defects, unparsed_data=unparsed_data)
       
       
    1: def is_response_to_head(response):
           """
           Checks whether the request of a response has been a HEAD-request.
           Handles the quirks of AppEngine.
       
           :param conn:
           :type conn: :class:`httplib.HTTPResponse`
           """
           # FIXME: Can we do this somehow without accessing private httplib _method?
           method = response._method
           if isinstance(method, int):  # Platform-specific: Appengine
               return method == 3
           return method.upper() == 'HEAD'
