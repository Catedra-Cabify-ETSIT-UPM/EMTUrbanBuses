       #!/usr/bin/env python
       # encoding: utf-8
       """
       The :class:`~IPython.core.application.Application` object for the command
       line :command:`ipython` program.
    1: """
       
       # Copyright (c) IPython Development Team.
       # Distributed under the terms of the Modified BSD License.
       
       
    1: import logging
    1: import os
    1: import sys
    1: import warnings
       
    1: from traitlets.config.loader import Config
    1: from traitlets.config.application import boolean_flag, catch_config_error
    1: from IPython.core import release
    1: from IPython.core import usage
    1: from IPython.core.completer import IPCompleter
    1: from IPython.core.crashhandler import CrashHandler
    1: from IPython.core.formatters import PlainTextFormatter
    1: from IPython.core.history import HistoryManager
    1: from IPython.core.application import (
           ProfileDir, BaseIPythonApplication, base_flags, base_aliases
       )
    1: from IPython.core.magics import (
           ScriptMagics, LoggingMagics
       )
    1: from IPython.core.shellapp import (
           InteractiveShellApp, shell_flags, shell_aliases
       )
    1: from IPython.extensions.storemagic import StoreMagics
    1: from .interactiveshell import TerminalInteractiveShell
    1: from IPython.paths import get_ipython_dir
    1: from traitlets import (
           Bool, List, default, observe, Type
       )
       
       #-----------------------------------------------------------------------------
       # Globals, utilities and helpers
       #-----------------------------------------------------------------------------
       
       _examples = """
       ipython --matplotlib       # enable matplotlib integration
       ipython --matplotlib=qt    # enable matplotlib integration with qt4 backend
       
       ipython --log-level=DEBUG  # set logging to DEBUG
       ipython --profile=foo      # start with profile foo
       
       ipython profile create foo # create profile foo w/ default config files
       ipython help profile       # show the help for the profile subcmd
       
       ipython locate             # print the path to the IPython directory
       ipython locate profile foo # print the path to the directory for profile `foo`
    1: """
       
       #-----------------------------------------------------------------------------
       # Crash handler for this application
       #-----------------------------------------------------------------------------
       
    2: class IPAppCrashHandler(CrashHandler):
    1:     """sys.excepthook for IPython itself, leaves a detailed report on disk."""
       
    1:     def __init__(self, app):
               contact_name = release.author
               contact_email = release.author_email
               bug_tracker = 'https://github.com/ipython/ipython/issues'
               super(IPAppCrashHandler,self).__init__(
                   app, contact_name, contact_email, bug_tracker
               )
       
    1:     def make_report(self,traceback):
               """Return a string containing a crash report."""
       
               sec_sep = self.section_sep
               # Start with parent report
               report = [super(IPAppCrashHandler, self).make_report(traceback)]
               # Add interactive-specific info we may have
               rpt_add = report.append
               try:
                   rpt_add(sec_sep+"History of session input:")
                   for line in self.app.shell.user_ns['_ih']:
                       rpt_add(line)
                   rpt_add('\n*** Last line of input (may not be in above history):\n')
                   rpt_add(self.app.shell._last_input_line+'\n')
               except:
                   pass
       
               return ''.join(report)
       
       #-----------------------------------------------------------------------------
       # Aliases and Flags
       #-----------------------------------------------------------------------------
    1: flags = dict(base_flags)
    1: flags.update(shell_flags)
    1: frontend_flags = {}
    6: addflag = lambda *args: frontend_flags.update(boolean_flag(*args))
    1: addflag('autoedit-syntax', 'TerminalInteractiveShell.autoedit_syntax',
    1:         'Turn on auto editing of files with syntax errors.',
    1:         'Turn off auto editing of files with syntax errors.'
       )
    1: addflag('simple-prompt', 'TerminalInteractiveShell.simple_prompt',
    1:         "Force simple minimal prompt using `raw_input`",
    1:         "Use a rich interactive prompt with prompt_toolkit",
       )
       
    1: addflag('banner', 'TerminalIPythonApp.display_banner',
    1:         "Display a banner upon starting IPython.",
    1:         "Don't display a banner upon starting IPython."
       )
    1: addflag('confirm-exit', 'TerminalInteractiveShell.confirm_exit',
           """Set to confirm when you try to exit IPython with an EOF (Control-D
           in Unix, Control-Z/Enter in Windows). By typing 'exit' or 'quit',
    1:     you can force a direct exit without any confirmation.""",
    1:     "Don't prompt the user when exiting."
       )
    1: addflag('term-title', 'TerminalInteractiveShell.term_title',
    1:     "Enable auto setting the terminal title.",
    1:     "Disable auto setting the terminal title."
       )
    1: classic_config = Config()
    1: classic_config.InteractiveShell.cache_size = 0
    1: classic_config.PlainTextFormatter.pprint = False
    1: classic_config.TerminalInteractiveShell.prompts_class='IPython.terminal.prompts.ClassicPrompts'
    1: classic_config.InteractiveShell.separate_in = ''
    1: classic_config.InteractiveShell.separate_out = ''
    1: classic_config.InteractiveShell.separate_out2 = ''
    1: classic_config.InteractiveShell.colors = 'NoColor'
    1: classic_config.InteractiveShell.xmode = 'Plain'
       
       frontend_flags['classic']=(
    1:     classic_config,
    1:     "Gives IPython a similar feel to the classic Python prompt."
       )
       # # log doesn't make so much sense this way anymore
       # paa('--log','-l',
       #     action='store_true', dest='InteractiveShell.logstart',
       #     help="Start logging to the default log file (./ipython_log.py).")
       #
       # # quick is harder to implement
       frontend_flags['quick']=(
    1:     {'TerminalIPythonApp' : {'quick' : True}},
    1:     "Enable quick startup with no config files."
       )
       
       frontend_flags['i'] = (
    1:     {'TerminalIPythonApp' : {'force_interact' : True}},
           """If running code from the command line, become interactive afterwards.
           It is often useful to follow this with `--` to treat remaining flags as
           script arguments.
    1:     """
       )
    1: flags.update(frontend_flags)
       
    1: aliases = dict(base_aliases)
    1: aliases.update(shell_aliases)
       
       #-----------------------------------------------------------------------------
       # Main classes and functions
       #-----------------------------------------------------------------------------
       
       
    2: class LocateIPythonApp(BaseIPythonApplication):
    1:     description = """print the path to the IPython dir"""
    1:     subcommands = dict(
    1:         profile=('IPython.core.profileapp.ProfileLocate',
                   "print the path to an IPython profile directory",
               ),
           )
    1:     def start(self):
               if self.subapp is not None:
                   return self.subapp.start()
               else:
                   print(self.ipython_dir)
       
       
    2: class TerminalIPythonApp(BaseIPythonApplication, InteractiveShellApp):
    1:     name = u'ipython'
    1:     description = usage.cl_usage
    1:     crash_handler_class = IPAppCrashHandler
    1:     examples = _examples
       
    1:     flags = flags
    1:     aliases = aliases
    1:     classes = List()
       
    1:     interactive_shell_class = Type(
    1:         klass=object,   # use default_value otherwise which only allow subclasses.
    1:         default_value=TerminalInteractiveShell,
    1:         help="Class to use to instantiate the TerminalInteractiveShell object. Useful for custom Frontends"
    1:     ).tag(config=True)
       
    1:     @default('classes')
           def _classes_default(self):
               """This has to be in a method, for TerminalIPythonApp to be available."""
               return [
                   InteractiveShellApp, # ShellApp comes before TerminalApp, because
                   self.__class__,      # it will also affect subclasses (e.g. QtConsole)
                   TerminalInteractiveShell,
                   HistoryManager,
                   ProfileDir,
                   PlainTextFormatter,
                   IPCompleter,
                   ScriptMagics,
                   LoggingMagics,
                   StoreMagics,
               ]
       
    1:     deprecated_subcommands = dict(
    1:         qtconsole=('qtconsole.qtconsoleapp.JupyterQtConsoleApp',
                   """DEPRECATED, Will be removed in IPython 6.0 : Launch the Jupyter Qt Console."""
               ),
    1:         notebook=('notebook.notebookapp.NotebookApp',
                   """DEPRECATED, Will be removed in IPython 6.0 : Launch the Jupyter HTML Notebook Server."""
               ),
    1:         console=('jupyter_console.app.ZMQTerminalIPythonApp',
                   """DEPRECATED, Will be removed in IPython 6.0 : Launch the Jupyter terminal-based Console."""
               ),
    1:         nbconvert=('nbconvert.nbconvertapp.NbConvertApp',
                   "DEPRECATED, Will be removed in IPython 6.0 : Convert notebooks to/from other formats."
               ),
    1:         trust=('nbformat.sign.TrustNotebookApp',
                   "DEPRECATED, Will be removed in IPython 6.0 : Sign notebooks to trust their potentially unsafe contents at load."
               ),
    1:         kernelspec=('jupyter_client.kernelspecapp.KernelSpecApp',
                   "DEPRECATED, Will be removed in IPython 6.0 : Manage Jupyter kernel specifications."
               ),
           )
    1:     subcommands = dict(
    1:         profile = ("IPython.core.profileapp.ProfileApp",
                   "Create and manage IPython profiles."
               ),
    1:         kernel = ("ipykernel.kernelapp.IPKernelApp",
                   "Start a kernel without an attached frontend."
               ),
    1:         locate=('IPython.terminal.ipapp.LocateIPythonApp',
    1:             LocateIPythonApp.description
               ),
    1:         history=('IPython.core.historyapp.HistoryApp',
                   "Manage the IPython history database."
               ),
           )
           deprecated_subcommands['install-nbextension'] = (
    1:         "notebook.nbextensions.InstallNBExtensionApp",
               "DEPRECATED, Will be removed in IPython 6.0 : Install Jupyter notebook extension files"
           )
    1:     subcommands.update(deprecated_subcommands)
       
           # *do* autocreate requested profile, but don't create the config file.
    1:     auto_create=Bool(True)
           # configurables
    1:     quick = Bool(False,
    1:         help="""Start IPython quickly by skipping the loading of config files."""
    1:     ).tag(config=True)
    1:     @observe('quick')
           def _quick_changed(self, change):
               if change['new']:
                   self.load_config_file = lambda *a, **kw: None
       
    1:     display_banner = Bool(True,
    1:         help="Whether to display a banner upon starting IPython."
    1:     ).tag(config=True)
       
           # if there is code of files to run from the cmd line, don't interact
           # unless the --i flag (App.force_interact) is true.
    1:     force_interact = Bool(False,
               help="""If a command or file is given via the command-line,
               e.g. 'ipython foo.py', start an interactive shell after executing the
    1:         file or command."""
    1:     ).tag(config=True)
    1:     @observe('force_interact')
           def _force_interact_changed(self, change):
               if change['new']:
                   self.interact = True
       
    1:     @observe('file_to_run', 'code_to_run', 'module_to_run')
           def _file_to_run_changed(self, change):
               new = change['new']
               if new:
                   self.something_to_run = True
               if new and not self.force_interact:
                       self.interact = False
       
           # internal, not-configurable
    1:     something_to_run=Bool(False)
       
    1:     def parse_command_line(self, argv=None):
               """override to allow old '-pylab' flag with deprecation warning"""
       
               argv = sys.argv[1:] if argv is None else argv
       
               if '-pylab' in argv:
                   # deprecated `-pylab` given,
                   # warn and transform into current syntax
                   argv = argv[:] # copy, don't clobber
                   idx = argv.index('-pylab')
                   warnings.warn("`-pylab` flag has been deprecated.\n"
                   "    Use `--matplotlib <backend>` and import pylab manually.")
                   argv[idx] = '--pylab'
       
               return super(TerminalIPythonApp, self).parse_command_line(argv)
           
    1:     @catch_config_error
    1:     def initialize(self, argv=None):
               """Do actions after construct, but before starting the app."""
               super(TerminalIPythonApp, self).initialize(argv)
               if self.subapp is not None:
                   # don't bother initializing further, starting subapp
                   return
               # print self.extra_args
               if self.extra_args and not self.something_to_run:
                   self.file_to_run = self.extra_args[0]
               self.init_path()
               # create the shell
               self.init_shell()
               # and draw the banner
               self.init_banner()
               # Now a variety of things that happen after the banner is printed.
               self.init_gui_pylab()
               self.init_extensions()
               self.init_code()
       
    1:     def init_shell(self):
               """initialize the InteractiveShell instance"""
               # Create an InteractiveShell instance.
               # shell.display_banner should always be False for the terminal
               # based app, because we call shell.show_banner() by hand below
               # so the banner shows *before* all extension loading stuff.
               self.shell = self.interactive_shell_class.instance(parent=self,
                               profile_dir=self.profile_dir,
                               ipython_dir=self.ipython_dir, user_ns=self.user_ns)
               self.shell.configurables.append(self)
       
    1:     def init_banner(self):
               """optionally display the banner"""
               if self.display_banner and self.interact:
                   self.shell.show_banner()
               # Make sure there is a space below the banner.
               if self.log_level <= logging.INFO: print()
       
    1:     def _pylab_changed(self, name, old, new):
               """Replace --pylab='inline' with --pylab='auto'"""
               if new == 'inline':
                   warnings.warn("'inline' not available as pylab backend, "
                             "using 'auto' instead.")
                   self.pylab = 'auto'
       
    1:     def start(self):
               if self.subapp is not None:
                   return self.subapp.start()
               # perform any prexec steps:
               if self.interact:
                   self.log.debug("Starting IPython's mainloop...")
                   self.shell.mainloop()
               else:
                   self.log.debug("IPython not interactive...")
                   if not self.shell.last_execution_succeeded:
                       sys.exit(1)
       
    1: def load_default_config(ipython_dir=None):
           """Load the default config file from the default ipython_dir.
       
           This is useful for embedded shells.
           """
           if ipython_dir is None:
               ipython_dir = get_ipython_dir()
       
           profile_dir = os.path.join(ipython_dir, 'profile_default')
           app = TerminalIPythonApp()
           app.config_file_paths.append(profile_dir)
           app.load_config_file()
           return app.config
       
    1: launch_new_instance = TerminalIPythonApp.launch_instance
       
       
    1: if __name__ == '__main__':
           launch_new_instance()
