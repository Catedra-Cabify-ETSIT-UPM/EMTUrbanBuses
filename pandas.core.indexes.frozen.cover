       """
       frozen (immutable) data structures to support MultiIndexing
       
       These are used for:
       
       - .names (FrozenList)
       - .levels & .codes (FrozenNDArray)
       
    1: """
       
    1: import warnings
       
    1: import numpy as np
       
    1: from pandas.util._decorators import deprecate_kwarg
       
    1: from pandas.core.dtypes.cast import coerce_indexer_dtype
       
    1: from pandas.core.base import PandasObject
       
    1: from pandas.io.formats.printing import pprint_thing
       
       
    2: class FrozenList(PandasObject, list):
       
           """
           Container that doesn't allow setting item *but*
           because it's technically non-hashable, will be used
           for lookups, appropriately, etc.
    1:     """
       
           # Side note: This has to be of type list. Otherwise,
           #            it messes up PyTables type checks.
       
    1:     def union(self, other):
               """
               Returns a FrozenList with other concatenated to the end of self.
       
               Parameters
               ----------
               other : array-like
                   The array-like whose elements we are concatenating.
       
               Returns
               -------
               diff : FrozenList
                   The collection difference between self and other.
               """
               if isinstance(other, tuple):
                   other = list(other)
               return type(self)(super().__add__(other))
       
    1:     def difference(self, other):
               """
               Returns a FrozenList with elements from other removed from self.
       
               Parameters
               ----------
               other : array-like
                   The array-like whose elements we are removing self.
       
               Returns
               -------
               diff : FrozenList
                   The collection difference between self and other.
               """
               other = set(other)
               temp = [x for x in self if x not in other]
               return type(self)(temp)
       
           # TODO: Consider deprecating these in favor of `union` (xref gh-15506)
    1:     __add__ = __iadd__ = union
       
           # Python 2 compat
    1:     def __getslice__(self, i, j):
               return self.__class__(super().__getslice__(i, j))
       
    1:     def __getitem__(self, n):
               # Python 3 compat
               if isinstance(n, slice):
                   return self.__class__(super().__getitem__(n))
               return super().__getitem__(n)
       
    1:     def __radd__(self, other):
               if isinstance(other, tuple):
                   other = list(other)
               return self.__class__(other + list(self))
       
    1:     def __eq__(self, other):
               if isinstance(other, (tuple, FrozenList)):
                   other = list(other)
               return super().__eq__(other)
       
    1:     __req__ = __eq__
       
    1:     def __mul__(self, other):
               return self.__class__(super().__mul__(other))
       
    1:     __imul__ = __mul__
       
    1:     def __reduce__(self):
               return self.__class__, (list(self),)
       
    1:     def __hash__(self):
               return hash(tuple(self))
       
    1:     def _disabled(self, *args, **kwargs):
               """This method will not function because object is immutable."""
               raise TypeError(
                   "'%s' does not support mutable operations." % self.__class__.__name__
               )
       
    1:     def __str__(self):
               return pprint_thing(self, quote_strings=True, escape_chars=("\t", "\r", "\n"))
       
    1:     def __repr__(self):
               return "%s(%s)" % (self.__class__.__name__, str(self))
       
    1:     __setitem__ = __setslice__ = __delitem__ = __delslice__ = _disabled
    1:     pop = append = extend = remove = sort = insert = _disabled
       
       
    2: class FrozenNDArray(PandasObject, np.ndarray):
       
           # no __array_finalize__ for now because no metadata
    1:     def __new__(cls, data, dtype=None, copy=False):
               warnings.warn(
                   "\nFrozenNDArray is deprecated and will be removed in a "
                   "future version.\nPlease use `numpy.ndarray` instead.\n",
                   FutureWarning,
                   stacklevel=2,
               )
       
               if copy is None:
                   copy = not isinstance(data, FrozenNDArray)
               res = np.array(data, dtype=dtype, copy=copy).view(cls)
               return res
       
    1:     def _disabled(self, *args, **kwargs):
               """This method will not function because object is immutable."""
               raise TypeError("'%s' does not support mutable operations." % self.__class__)
       
    1:     __setitem__ = __setslice__ = __delitem__ = __delslice__ = _disabled
    1:     put = itemset = fill = _disabled
       
    1:     def _shallow_copy(self):
               return self.view()
       
    1:     def values(self):
               """returns *copy* of underlying array"""
               arr = self.view(np.ndarray).copy()
               return arr
       
    1:     def __repr__(self):
               """
               Return a string representation for this object.
               """
               prepr = pprint_thing(self, escape_chars=("\t", "\r", "\n"), quote_strings=True)
               return "%s(%s, dtype='%s')" % (type(self).__name__, prepr, self.dtype)
       
    1:     @deprecate_kwarg(old_arg_name="v", new_arg_name="value")
    1:     def searchsorted(self, value, side="left", sorter=None):
               """
               Find indices to insert `value` so as to maintain order.
       
               For full documentation, see `numpy.searchsorted`
       
               See Also
               --------
               numpy.searchsorted : Equivalent function.
               """
       
               # We are much more performant if the searched
               # indexer is the same type as the array.
               #
               # This doesn't matter for int64, but DOES
               # matter for smaller int dtypes.
               #
               # xref: https://github.com/numpy/numpy/issues/5370
               try:
                   value = self.dtype.type(value)
               except ValueError:
                   pass
       
               return super().searchsorted(value, side=side, sorter=sorter)
       
       
    1: def _ensure_frozen(array_like, categories, copy=False):
           array_like = coerce_indexer_dtype(array_like, categories)
           array_like = array_like.view(FrozenNDArray)
           if copy:
               array_like = array_like.copy()
           return array_like
