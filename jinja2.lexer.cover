       # -*- coding: utf-8 -*-
       """
           jinja2.lexer
           ~~~~~~~~~~~~
       
           This module implements a Jinja / Python combination lexer. The
           `Lexer` class provided by this module is used to do some preprocessing
           for Jinja.
       
           On the one hand it filters out invalid operators like the bitshift
           operators we don't allow in templates. On the other hand it separates
           template code and python code in expressions.
       
           :copyright: (c) 2017 by the Jinja Team.
           :license: BSD, see LICENSE for more details.
    1: """
    1: import re
    1: from collections import deque
    1: from operator import itemgetter
       
    1: from jinja2._compat import implements_iterator, intern, iteritems, text_type
    1: from jinja2.exceptions import TemplateSyntaxError
    1: from jinja2.utils import LRUCache
       
       # cache for the lexers. Exists in order to be able to have multiple
       # environments with the same lexer
    1: _lexer_cache = LRUCache(50)
       
       # static regular expressions
    1: whitespace_re = re.compile(r'\s+', re.U)
    1: string_re = re.compile(r"('([^'\\]*(?:\\.[^'\\]*)*)'"
    1:                        r'|"([^"\\]*(?:\\.[^"\\]*)*)")', re.S)
    1: integer_re = re.compile(r'\d+')
       
    1: try:
           # check if this Python supports Unicode identifiers
    1:     compile('föö', '<unknown>', 'eval')
       except SyntaxError:
           # no Unicode support, use ASCII identifiers
           name_re = re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*')
           check_ident = False
       else:
           # Unicode support, build a pattern to match valid characters, and set flag
           # to use str.isidentifier to validate during lexing
    1:     from jinja2 import _identifier
    1:     name_re = re.compile(r'[\w{0}]+'.format(_identifier.pattern))
    1:     check_ident = True
           # remove the pattern from memory after building the regex
    1:     import sys
    1:     del sys.modules['jinja2._identifier']
    1:     import jinja2
    1:     del jinja2._identifier
    1:     del _identifier
       
    1: float_re = re.compile(r'(?<!\.)\d+\.\d+')
    1: newline_re = re.compile(r'(\r\n|\r|\n)')
       
       # internal the tokens and keep references to them
    1: TOKEN_ADD = intern('add')
    1: TOKEN_ASSIGN = intern('assign')
    1: TOKEN_COLON = intern('colon')
    1: TOKEN_COMMA = intern('comma')
    1: TOKEN_DIV = intern('div')
    1: TOKEN_DOT = intern('dot')
    1: TOKEN_EQ = intern('eq')
    1: TOKEN_FLOORDIV = intern('floordiv')
    1: TOKEN_GT = intern('gt')
    1: TOKEN_GTEQ = intern('gteq')
    1: TOKEN_LBRACE = intern('lbrace')
    1: TOKEN_LBRACKET = intern('lbracket')
    1: TOKEN_LPAREN = intern('lparen')
    1: TOKEN_LT = intern('lt')
    1: TOKEN_LTEQ = intern('lteq')
    1: TOKEN_MOD = intern('mod')
    1: TOKEN_MUL = intern('mul')
    1: TOKEN_NE = intern('ne')
    1: TOKEN_PIPE = intern('pipe')
    1: TOKEN_POW = intern('pow')
    1: TOKEN_RBRACE = intern('rbrace')
    1: TOKEN_RBRACKET = intern('rbracket')
    1: TOKEN_RPAREN = intern('rparen')
    1: TOKEN_SEMICOLON = intern('semicolon')
    1: TOKEN_SUB = intern('sub')
    1: TOKEN_TILDE = intern('tilde')
    1: TOKEN_WHITESPACE = intern('whitespace')
    1: TOKEN_FLOAT = intern('float')
    1: TOKEN_INTEGER = intern('integer')
    1: TOKEN_NAME = intern('name')
    1: TOKEN_STRING = intern('string')
    1: TOKEN_OPERATOR = intern('operator')
    1: TOKEN_BLOCK_BEGIN = intern('block_begin')
    1: TOKEN_BLOCK_END = intern('block_end')
    1: TOKEN_VARIABLE_BEGIN = intern('variable_begin')
    1: TOKEN_VARIABLE_END = intern('variable_end')
    1: TOKEN_RAW_BEGIN = intern('raw_begin')
    1: TOKEN_RAW_END = intern('raw_end')
    1: TOKEN_COMMENT_BEGIN = intern('comment_begin')
    1: TOKEN_COMMENT_END = intern('comment_end')
    1: TOKEN_COMMENT = intern('comment')
    1: TOKEN_LINESTATEMENT_BEGIN = intern('linestatement_begin')
    1: TOKEN_LINESTATEMENT_END = intern('linestatement_end')
    1: TOKEN_LINECOMMENT_BEGIN = intern('linecomment_begin')
    1: TOKEN_LINECOMMENT_END = intern('linecomment_end')
    1: TOKEN_LINECOMMENT = intern('linecomment')
    1: TOKEN_DATA = intern('data')
    1: TOKEN_INITIAL = intern('initial')
    1: TOKEN_EOF = intern('eof')
       
       # bind operators to token types
       operators = {
    1:     '+':            TOKEN_ADD,
    1:     '-':            TOKEN_SUB,
    1:     '/':            TOKEN_DIV,
    1:     '//':           TOKEN_FLOORDIV,
    1:     '*':            TOKEN_MUL,
    1:     '%':            TOKEN_MOD,
    1:     '**':           TOKEN_POW,
    1:     '~':            TOKEN_TILDE,
    1:     '[':            TOKEN_LBRACKET,
    1:     ']':            TOKEN_RBRACKET,
    1:     '(':            TOKEN_LPAREN,
    1:     ')':            TOKEN_RPAREN,
    1:     '{':            TOKEN_LBRACE,
    1:     '}':            TOKEN_RBRACE,
    1:     '==':           TOKEN_EQ,
    1:     '!=':           TOKEN_NE,
    1:     '>':            TOKEN_GT,
    1:     '>=':           TOKEN_GTEQ,
    1:     '<':            TOKEN_LT,
    1:     '<=':           TOKEN_LTEQ,
    1:     '=':            TOKEN_ASSIGN,
    1:     '.':            TOKEN_DOT,
    1:     ':':            TOKEN_COLON,
    1:     '|':            TOKEN_PIPE,
    1:     ',':            TOKEN_COMMA,
    1:     ';':            TOKEN_SEMICOLON
       }
       
   28: reverse_operators = dict([(v, k) for k, v in iteritems(operators)])
    1: assert len(operators) == len(reverse_operators), 'operators dropped'
   28: operator_re = re.compile('(%s)' % '|'.join(re.escape(x) for x in
   27:                          sorted(operators, key=lambda x: -len(x))))
       
    1: ignored_tokens = frozenset([TOKEN_COMMENT_BEGIN, TOKEN_COMMENT,
    1:                             TOKEN_COMMENT_END, TOKEN_WHITESPACE,
    1:                             TOKEN_LINECOMMENT_BEGIN, TOKEN_LINECOMMENT_END,
    1:                             TOKEN_LINECOMMENT])
    1: ignore_if_empty = frozenset([TOKEN_WHITESPACE, TOKEN_DATA,
    1:                              TOKEN_COMMENT, TOKEN_LINECOMMENT])
       
       
    1: def _describe_token_type(token_type):
           if token_type in reverse_operators:
               return reverse_operators[token_type]
           return {
               TOKEN_COMMENT_BEGIN:        'begin of comment',
               TOKEN_COMMENT_END:          'end of comment',
               TOKEN_COMMENT:              'comment',
               TOKEN_LINECOMMENT:          'comment',
               TOKEN_BLOCK_BEGIN:          'begin of statement block',
               TOKEN_BLOCK_END:            'end of statement block',
               TOKEN_VARIABLE_BEGIN:       'begin of print statement',
               TOKEN_VARIABLE_END:         'end of print statement',
               TOKEN_LINESTATEMENT_BEGIN:  'begin of line statement',
               TOKEN_LINESTATEMENT_END:    'end of line statement',
               TOKEN_DATA:                 'template data / text',
               TOKEN_EOF:                  'end of template'
           }.get(token_type, token_type)
       
       
    1: def describe_token(token):
           """Returns a description of the token."""
           if token.type == 'name':
               return token.value
           return _describe_token_type(token.type)
       
       
    1: def describe_token_expr(expr):
           """Like `describe_token` but for token expressions."""
           if ':' in expr:
               type, value = expr.split(':', 1)
               if type == 'name':
                   return value
           else:
               type = expr
           return _describe_token_type(type)
       
       
    1: def count_newlines(value):
           """Count the number of newline characters in the string.  This is
           useful for extensions that filter a stream.
           """
           return len(newline_re.findall(value))
       
       
    1: def compile_rules(environment):
           """Compiles all the rules from the environment into a list of rules."""
    1:     e = re.escape
           rules = [
    1:         (len(environment.comment_start_string), 'comment',
    1:          e(environment.comment_start_string)),
    1:         (len(environment.block_start_string), 'block',
    1:          e(environment.block_start_string)),
    1:         (len(environment.variable_start_string), 'variable',
    1:          e(environment.variable_start_string))
           ]
       
    1:     if environment.line_statement_prefix is not None:
               rules.append((len(environment.line_statement_prefix), 'linestatement',
                             r'^[ \t\v]*' + e(environment.line_statement_prefix)))
    1:     if environment.line_comment_prefix is not None:
               rules.append((len(environment.line_comment_prefix), 'linecomment',
                             r'(?:^|(?<=\S))[^\S\r\n]*' +
                             e(environment.line_comment_prefix)))
       
    5:     return [x[1:] for x in sorted(rules, reverse=True)]
       
       
    2: class Failure(object):
           """Class that raises a `TemplateSyntaxError` if called.
           Used by the `Lexer` to specify known errors.
    1:     """
       
    1:     def __init__(self, message, cls=TemplateSyntaxError):
    2:         self.message = message
    2:         self.error_class = cls
       
    1:     def __call__(self, lineno, filename):
               raise self.error_class(self.message, lineno, filename)
       
       
    2: class Token(tuple):
    1:     """Token class."""
    1:     __slots__ = ()
    5:     lineno, type, value = (property(itemgetter(x)) for x in range(3))
       
    1:     def __new__(cls, lineno, type, value):
  655:         return tuple.__new__(cls, (lineno, intern(str(type)), value))
       
    1:     def __str__(self):
               if self.type in reverse_operators:
                   return reverse_operators[self.type]
               elif self.type == 'name':
                   return self.value
               return self.type
       
    1:     def test(self, expr):
               """Test a token against a token expression.  This can either be a
               token type or ``'token_type:token_value'``.  This can only test
               against string values and types.
               """
               # here we do a regular string equality check as test_any is usually
               # passed an iterable of not interned strings.
  809:         if self.type == expr:
  196:             return True
  613:         elif ':' in expr:
  591:             return expr.split(':', 1) == [self.type, self.value]
   22:         return False
       
    1:     def test_any(self, *iterable):
               """Test against multiple token expressions."""
   27:         for expr in iterable:
   23:             if self.test(expr):
   13:                 return True
    4:         return False
       
    1:     def __repr__(self):
               return 'Token(%r, %r, %r)' % (
                   self.lineno,
                   self.type,
                   self.value
               )
       
       
    2: @implements_iterator
    1: class TokenStreamIterator(object):
           """The iterator for tokenstreams.  Iterate over the stream
           until the eof token is reached.
    1:     """
       
    1:     def __init__(self, stream):
               self.stream = stream
       
    1:     def __iter__(self):
               return self
       
    1:     def __next__(self):
               token = self.stream.current
               if token.type is TOKEN_EOF:
                   self.stream.close()
                   raise StopIteration()
               next(self.stream)
               return token
       
       
    2: @implements_iterator
    1: class TokenStream(object):
           """A token stream is an iterable that yields :class:`Token`\\s.  The
           parser however does not iterate over it but calls :meth:`next` to go
           one token ahead.  The current active token is stored as :attr:`current`.
    1:     """
       
    1:     def __init__(self, generator, name, filename):
    8:         self._iter = iter(generator)
    8:         self._pushed = deque()
    8:         self.name = name
    8:         self.filename = filename
    8:         self.closed = False
    8:         self.current = Token(1, TOKEN_INITIAL, '')
    8:         next(self)
       
    1:     def __iter__(self):
               return TokenStreamIterator(self)
       
    1:     def __bool__(self):
  161:         return bool(self._pushed) or self.current.type is not TOKEN_EOF
    1:     __nonzero__ = __bool__  # py2
       
    1:     eos = property(lambda x: not x, doc="Are we at the end of the stream?")
       
    1:     def push(self, token):
               """Push a token back to the stream."""
    2:         self._pushed.append(token)
       
    1:     def look(self):
               """Look at the next token."""
    2:         old_token = next(self)
    2:         result = self.current
    2:         self.push(result)
    2:         self.current = old_token
    2:         return result
       
    1:     def skip(self, n=1):
               """Got n tokens ahead."""
               for x in range(n):
                   next(self)
       
    1:     def next_if(self, expr):
               """Perform the token test and return the token if it matched.
               Otherwise the return value is `None`.
               """
  387:         if self.current.test(expr):
                   return next(self)
       
    1:     def skip_if(self, expr):
               """Like :meth:`next_if` but only returns `True` or `False`."""
  387:         return self.next_if(expr) is not None
       
    1:     def __next__(self):
               """Go one token ahead and return the old one.
       
               Use the built-in :func:`next` instead of calling this directly.
               """
  649:         rv = self.current
  649:         if self._pushed:
    2:             self.current = self._pushed.popleft()
  647:         elif self.current.type is not TOKEN_EOF:
  647:             try:
  647:                 self.current = next(self._iter)
    8:             except StopIteration:
    8:                 self.close()
  649:         return rv
       
    1:     def close(self):
               """Close the stream."""
    8:         self.current = Token(self.current.lineno, TOKEN_EOF, '')
    8:         self._iter = None
    8:         self.closed = True
       
    1:     def expect(self, expr):
               """Expect a given token type and return it.  This accepts the same
               argument as :meth:`jinja2.lexer.Token.test`.
               """
  203:         if not self.current.test(expr):
                   expr = describe_token_expr(expr)
                   if self.current.type is TOKEN_EOF:
                       raise TemplateSyntaxError('unexpected end of template, '
                                                 'expected %r.' % expr,
                                                 self.current.lineno,
                                                 self.name, self.filename)
                   raise TemplateSyntaxError("expected token %r, got %r" %
                                             (expr, describe_token(self.current)),
                                             self.current.lineno,
                                             self.name, self.filename)
  203:         try:
  203:             return self.current
               finally:
  203:             next(self)
       
       
    1: def get_lexer(environment):
           """Return a lexer which is probably cached."""
    8:     key = (environment.block_start_string,
    8:            environment.block_end_string,
    8:            environment.variable_start_string,
    8:            environment.variable_end_string,
    8:            environment.comment_start_string,
    8:            environment.comment_end_string,
    8:            environment.line_statement_prefix,
    8:            environment.line_comment_prefix,
    8:            environment.trim_blocks,
    8:            environment.lstrip_blocks,
    8:            environment.newline_sequence,
    8:            environment.keep_trailing_newline)
    8:     lexer = _lexer_cache.get(key)
    8:     if lexer is None:
    1:         lexer = Lexer(environment)
    1:         _lexer_cache[key] = lexer
    8:     return lexer
       
       
    2: class Lexer(object):
           """Class that implements a lexer for a given environment. Automatically
           created by the environment class, usually you don't have to do that.
       
           Note that the lexer is not automatically bound to an environment.
           Multiple environments can share the same lexer.
    1:     """
       
    1:     def __init__(self, environment):
               # shortcuts
   11:         c = lambda x: re.compile(x, re.M | re.S)
    1:         e = re.escape
       
               # lexing rules for tags
               tag_rules = [
    1:             (whitespace_re, TOKEN_WHITESPACE, None),
    1:             (float_re, TOKEN_FLOAT, None),
    1:             (integer_re, TOKEN_INTEGER, None),
    1:             (name_re, TOKEN_NAME, None),
    1:             (string_re, TOKEN_STRING, None),
    1:             (operator_re, TOKEN_OPERATOR, None)
               ]
       
               # assemble the root lexing rule. because "|" is ungreedy
               # we have to sort by length so that the lexer continues working
               # as expected when we have parsing rules like <% for block and
               # <%= for variables. (if someone wants asp like syntax)
               # variables are just part of the rules if variable processing
               # is required.
    1:         root_tag_rules = compile_rules(environment)
       
               # block suffix if trimming is enabled
    1:         block_suffix_re = environment.trim_blocks and '\\n?' or ''
       
               # strip leading spaces if lstrip_blocks is enabled
    1:         prefix_re = {}
    1:         if environment.lstrip_blocks:
                   # use '{%+' to manually disable lstrip_blocks behavior
                   no_lstrip_re = e('+')
                   # detect overlap between block and variable or comment strings
                   block_diff = c(r'^%s(.*)' % e(environment.block_start_string))
                   # make sure we don't mistake a block for a variable or a comment
                   m = block_diff.match(environment.comment_start_string)
                   no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''
                   m = block_diff.match(environment.variable_start_string)
                   no_lstrip_re += m and r'|%s' % e(m.group(1)) or ''
       
                   # detect overlap between comment and variable strings
                   comment_diff = c(r'^%s(.*)' % e(environment.comment_start_string))
                   m = comment_diff.match(environment.variable_start_string)
                   no_variable_re = m and r'(?!%s)' % e(m.group(1)) or ''
       
                   lstrip_re = r'^[ \t]*'
                   block_prefix_re = r'%s%s(?!%s)|%s\+?' % (
                           lstrip_re,
                           e(environment.block_start_string),
                           no_lstrip_re,
                           e(environment.block_start_string),
                           )
                   comment_prefix_re = r'%s%s%s|%s\+?' % (
                           lstrip_re,
                           e(environment.comment_start_string),
                           no_variable_re,
                           e(environment.comment_start_string),
                           )
                   prefix_re['block'] = block_prefix_re
                   prefix_re['comment'] = comment_prefix_re
               else:
    1:             block_prefix_re = '%s' % e(environment.block_start_string)
       
    1:         self.newline_sequence = environment.newline_sequence
    1:         self.keep_trailing_newline = environment.keep_trailing_newline
       
               # global lexing rules
               self.rules = {
    1:             'root': [
                       # directives
    1:                 (c('(.*?)(?:%s)' % '|'.join(
    1:                     [r'(?P<raw_begin>(?:\s*%s\-|%s)\s*raw\s*(?:\-%s\s*|%s))' % (
    1:                         e(environment.block_start_string),
    1:                         block_prefix_re,
    1:                         e(environment.block_end_string),
    1:                         e(environment.block_end_string)
                           )] + [
    5:                         r'(?P<%s_begin>\s*%s\-|%s)' % (n, r, prefix_re.get(n,r))
    4:                         for n, r in root_tag_rules
    1:                     ])), (TOKEN_DATA, '#bygroup'), '#bygroup'),
                       # data
    1:                 (c('.+'), TOKEN_DATA, None)
                   ],
                   # comments
    1:             TOKEN_COMMENT_BEGIN: [
    1:                 (c(r'(.*?)((?:\-%s\s*|%s)%s)' % (
    1:                     e(environment.comment_end_string),
    1:                     e(environment.comment_end_string),
    1:                     block_suffix_re
    1:                 )), (TOKEN_COMMENT, TOKEN_COMMENT_END), '#pop'),
    1:                 (c('(.)'), (Failure('Missing end of comment tag'),), None)
                   ],
                   # blocks
    1:             TOKEN_BLOCK_BEGIN: [
    1:                 (c(r'(?:\-%s\s*|%s)%s' % (
    1:                     e(environment.block_end_string),
    1:                     e(environment.block_end_string),
    1:                     block_suffix_re
    1:                 )), TOKEN_BLOCK_END, '#pop'),
    1:             ] + tag_rules,
                   # variables
    1:             TOKEN_VARIABLE_BEGIN: [
    1:                 (c(r'\-%s\s*|%s' % (
    1:                     e(environment.variable_end_string),
    1:                     e(environment.variable_end_string)
    1:                 )), TOKEN_VARIABLE_END, '#pop')
    1:             ] + tag_rules,
                   # raw block
    1:             TOKEN_RAW_BEGIN: [
    1:                 (c(r'(.*?)((?:\s*%s\-|%s)\s*endraw\s*(?:\-%s\s*|%s%s))' % (
    1:                     e(environment.block_start_string),
    1:                     block_prefix_re,
    1:                     e(environment.block_end_string),
    1:                     e(environment.block_end_string),
    1:                     block_suffix_re
    1:                 )), (TOKEN_DATA, TOKEN_RAW_END), '#pop'),
    1:                 (c('(.)'), (Failure('Missing end of raw directive'),), None)
                   ],
                   # line statements
    1:             TOKEN_LINESTATEMENT_BEGIN: [
    1:                 (c(r'\s*(\n|$)'), TOKEN_LINESTATEMENT_END, '#pop')
    1:             ] + tag_rules,
                   # line comments
    1:             TOKEN_LINECOMMENT_BEGIN: [
    1:                 (c(r'(.*?)()(?=\n|$)'), (TOKEN_LINECOMMENT,
    1:                  TOKEN_LINECOMMENT_END), '#pop')
                   ]
               }
       
    1:     def _normalize_newlines(self, value):
               """Called for strings and template data to normalize it to unicode."""
   71:         return newline_re.sub(self.newline_sequence, value)
       
    1:     def tokenize(self, source, name=None, filename=None, state=None):
               """Calls tokeniter + tokenize and wraps it in a token stream.
               """
    8:         stream = self.tokeniter(source, name, filename, state)
    8:         return TokenStream(self.wrap(stream, name, filename), name, filename)
       
    1:     def wrap(self, stream, name=None, filename=None):
               """This is called with the stream as returned by `tokenize` and wraps
               every token in a :class:`Token` and converts the value.
               """
  717:         for lineno, token, value in stream:
  709:             if token in ignored_tokens:
   70:                 continue
  639:             elif token == 'linestatement_begin':
                       token = 'block_begin'
  639:             elif token == 'linestatement_end':
                       token = 'block_end'
                   # we are not interested in those tokens in the parser
  639:             elif token in ('raw_begin', 'raw_end'):
                       continue
  639:             elif token == 'data':
   69:                 value = self._normalize_newlines(value)
  570:             elif token == 'keyword':
                       token = value
  570:             elif token == 'name':
  184:                 value = str(value)
  184:                 if check_ident and not value.isidentifier():
                           raise TemplateSyntaxError(
                               'Invalid character in identifier',
                               lineno, name, filename)
  386:             elif token == 'string':
                       # try to unescape string
    2:                 try:
    2:                     value = self._normalize_newlines(value[1:-1]) \
    2:                         .encode('ascii', 'backslashreplace') \
    2:                         .decode('unicode-escape')
                       except Exception as e:
                           msg = str(e).split(':')[-1].strip()
                           raise TemplateSyntaxError(msg, lineno, name, filename)
  384:             elif token == 'integer':
   16:                 value = int(value)
  368:             elif token == 'float':
                       value = float(value)
  368:             elif token == 'operator':
  200:                 token = operators[value]
  639:             yield Token(lineno, token, value)
       
    1:     def tokeniter(self, source, name, filename=None, state=None):
               """This method tokenizes the text and returns the tokens in a
               generator.  Use this method if you just want to tokenize a template.
               """
    8:         source = text_type(source)
    8:         lines = source.splitlines()
    8:         if self.keep_trailing_newline and source:
                   for newline in ('\r\n', '\r', '\n'):
                       if source.endswith(newline):
                           lines.append('')
                           break
    8:         source = '\n'.join(lines)
    8:         pos = 0
    8:         lineno = 1
    8:         stack = ['root']
    8:         if state is not None and state != 'root':
                   assert state in ('variable', 'block'), 'invalid state'
                   stack.append(state + '_begin')
               else:
    8:             state = 'root'
    8:         statetokens = self.rules[stack[-1]]
    8:         source_length = len(source)
       
    8:         balancing_stack = []
       
    8:         while 1:
                   # tokenizer loop
 2732:             for regex, tokens, new_state in statetokens:
 2724:                 m = regex.match(source, pos)
                       # if no match we try again with the next rule
 2724:                 if m is None:
 2082:                     continue
       
                       # we only match blocks and variables if braces / parentheses
                       # are balanced. continue parsing with the lower rule which
                       # is the operator rule. do this only if the end tags look
                       # like operators
  642:                 if balancing_stack and \
  102:                    tokens in ('variable_end', 'block_end',
                                     'linestatement_end'):
                           continue
       
                       # tuples support more options
  642:                 if isinstance(tokens, tuple):
  252:                     for idx, token in enumerate(tokens):
                               # failure group
  168:                         if token.__class__ is Failure:
                                   raise token(lineno, filename)
                               # bygroup is a bit more complex, in that case we
                               # yield for the current token the first named
                               # group that matched
  168:                         elif token == '#bygroup':
  212:                             for key, value in iteritems(m.groupdict()):
  212:                                 if value is not None:
   84:                                     yield lineno, key, value
   84:                                     lineno += value.count('\n')
   84:                                     break
                                   else:
                                       raise RuntimeError('%r wanted to resolve '
                                                          'the token dynamically'
                                                          ' but no group matched'
                                                          % regex)
                               # normal group
                               else:
   84:                             data = m.group(idx + 1)
   84:                             if data or token not in ignore_if_empty:
   67:                                 yield lineno, token, data
   84:                             lineno += data.count('\n')
       
                       # strings as token just are yielded as it.
                       else:
  558:                     data = m.group()
                           # update brace/parentheses balance
  558:                     if tokens == 'operator':
  200:                         if data == '{':
                                   balancing_stack.append('}')
  200:                         elif data == '(':
   40:                             balancing_stack.append(')')
  160:                         elif data == '[':
   16:                             balancing_stack.append(']')
  144:                         elif data in ('}', ')', ']'):
   56:                             if not balancing_stack:
                                       raise TemplateSyntaxError('unexpected \'%s\'' %
                                                                 data, lineno, name,
                                                                 filename)
   56:                             expected_op = balancing_stack.pop()
   56:                             if expected_op != data:
                                       raise TemplateSyntaxError('unexpected \'%s\', '
                                                                 'expected \'%s\'' %
                                                                 (data, expected_op),
                                                                 lineno, name,
                                                                 filename)
                           # yield items
  558:                     if data or tokens not in ignore_if_empty:
  558:                         yield lineno, tokens, data
  558:                     lineno += data.count('\n')
       
                       # fetch new position into new variable so that we can check
                       # if there is a internal parsing error which would result
                       # in an infinite loop
  642:                 pos2 = m.end()
       
                       # handle state changes
  642:                 if new_state is not None:
                           # remove the uppermost state
  168:                     if new_state == '#pop':
   84:                         stack.pop()
                           # resolve the new state by group checking
   84:                     elif new_state == '#bygroup':
  212:                         for key, value in iteritems(m.groupdict()):
  212:                             if value is not None:
   84:                                 stack.append(key)
   84:                                 break
                               else:
                                   raise RuntimeError('%r wanted to resolve the '
                                                      'new state dynamically but'
                                                      ' no group matched' %
                                                      regex)
                           # direct state name given
                           else:
                               stack.append(new_state)
  168:                     statetokens = self.rules[stack[-1]]
                       # we are still at the same position and no stack change.
                       # this means a loop without break condition, avoid that and
                       # raise error
  474:                 elif pos2 == pos:
                           raise RuntimeError('%r yielded empty string without '
                                              'stack change' % regex)
                       # publish new function and start again
  642:                 pos = pos2
  642:                 break
                   # if loop terminated without break we haven't found a single match
                   # either we are at the end of the file or we have a problem
                   else:
                       # end of text
    8:                 if pos >= source_length:
    8:                     return
                       # something went wrong
                       raise TemplateSyntaxError('unexpected char %r at %d' %
                                                 (source[pos], pos), lineno,
                                                 name, filename)
