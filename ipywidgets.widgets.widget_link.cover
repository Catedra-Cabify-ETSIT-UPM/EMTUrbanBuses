       # Copyright (c) Jupyter Development Team.
       # Distributed under the terms of the Modified BSD License.
       
       """Link and DirectionalLink classes.
       
       Propagate changes between widgets on the javascript side.
    1: """
       
    1: from .widget import Widget, register, widget_serialization
    1: from .widget_core import CoreWidget
       
    1: from traitlets import Unicode, Tuple, Instance, TraitError
       
       
    2: class WidgetTraitTuple(Tuple):
    1:     """Traitlet for validating a single (Widget, 'trait_name') pair"""
       
    1:     info_text = "A (Widget, 'trait_name') pair"
       
    1:     def __init__(self, **kwargs):
    2:         super(WidgetTraitTuple, self).__init__(Instance(Widget), Unicode(), **kwargs)
       
    1:     def validate_elements(self, obj, value):
               value = super(WidgetTraitTuple, self).validate_elements(obj, value)
               widget, trait_name = value
               trait = widget.traits().get(trait_name)
               trait_repr = "%s.%s" % (widget.__class__.__name__, trait_name)
               # Can't raise TraitError because the parent will swallow the message
               # and throw it away in a new, less informative TraitError
               if trait is None:
                   raise TypeError("No such trait: %s" % trait_repr)
               elif not trait.metadata.get('sync'):
                   raise TypeError("%s cannot be synced" % trait_repr)
               return value
       
       
    2: @register
    1: class Link(CoreWidget):
           """Link Widget
       
           source: a (Widget, 'trait_name') tuple for the source trait
           target: a (Widget, 'trait_name') tuple that should be updated
    1:     """
       
    1:     _model_name = Unicode('LinkModel').tag(sync=True)
    1:     target = WidgetTraitTuple(help="The target (widget, 'trait_name') pair").tag(sync=True, **widget_serialization)
    1:     source = WidgetTraitTuple(help="The source (widget, 'trait_name') pair").tag(sync=True, **widget_serialization)
       
    1:     def __init__(self, source, target, **kwargs):
               kwargs['source'] = source
               kwargs['target'] = target
               super(Link, self).__init__(**kwargs)
       
           # for compatibility with traitlet links
    1:     def unlink(self):
               self.close()
       
       
    1: def jslink(attr1, attr2):
           """Link two widget attributes on the frontend so they remain in sync.
       
           The link is created in the front-end and does not rely on a roundtrip
           to the backend.
       
           Parameters
           ----------
           source : a (Widget, 'trait_name') tuple for the first trait
           target : a (Widget, 'trait_name') tuple for the second trait
       
           Examples
           --------
       
           >>> c = link((widget1, 'value'), (widget2, 'value'))
           """
           return Link(attr1, attr2)
       
       
    2: @register
    1: class DirectionalLink(Link):
           """A directional link
       
           source: a (Widget, 'trait_name') tuple for the source trait
           target: a (Widget, 'trait_name') tuple that should be updated
           when the source trait changes.
    1:     """
    1:     _model_name = Unicode('DirectionalLinkModel').tag(sync=True)
       
       
    1: def jsdlink(source, target):
           """Link a source widget attribute with a target widget attribute.
       
           The link is created in the front-end and does not rely on a roundtrip
           to the backend.
       
           Parameters
           ----------
           source : a (Widget, 'trait_name') tuple for the source trait
           target : a (Widget, 'trait_name') tuple for the target trait
       
           Examples
           --------
       
           >>> c = dlink((src_widget, 'value'), (tgt_widget, 'value'))
           """
           return DirectionalLink(source, target)
