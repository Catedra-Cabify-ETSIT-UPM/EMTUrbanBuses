    1: """ define extension dtypes """
    1: import re
    1: from typing import Any, Dict, List, Optional, Tuple, Type, Union
    1: import warnings
       
    1: import numpy as np
    1: import pytz
       
    1: from pandas._libs.interval import Interval
    1: from pandas._libs.tslibs import NaT, Period, Timestamp, timezones
       
    1: from pandas.core.dtypes.generic import ABCCategoricalIndex, ABCDateOffset, ABCIndexClass
       
    1: from .base import ExtensionDtype
    1: from .inference import is_list_like
       
    1: str_type = str
       
       # GH26403: sentinel value used for the default value of ordered in the
       # CategoricalDtype constructor to detect when ordered=None is explicitly passed
    1: ordered_sentinel = object()  # type: object
       
       # TODO(GH26403): Replace with Optional[bool] or bool
    1: OrderedType = Union[None, bool, object]
       
       
    1: def register_extension_dtype(cls: Type[ExtensionDtype],) -> Type[ExtensionDtype]:
           """
           Register an ExtensionType with pandas as class decorator.
       
           .. versionadded:: 0.24.0
       
           This enables operations like ``.astype(name)`` for the name
           of the ExtensionDtype.
       
           Returns
           -------
           callable
               A class decorator.
       
           Examples
           --------
           >>> from pandas.api.extensions import register_extension_dtype
           >>> from pandas.api.extensions import ExtensionDtype
           >>> @register_extension_dtype
           ... class MyExtensionDtype(ExtensionDtype):
           ...     pass
           """
   14:     registry.register(cls)
   14:     return cls
       
       
    2: class Registry:
           """
           Registry for dtype inference
       
           The registry allows one to map a string repr of a extension
           dtype to an extension dtype. The string alias can be used in several
           places, including
       
           * Series and Index constructors
           * :meth:`pandas.array`
           * :meth:`pandas.Series.astype`
       
           Multiple extension types can be registered.
           These are tried in order.
    1:     """
       
    1:     def __init__(self):
    1:         self.dtypes = []  # type: List[Type[ExtensionDtype]]
       
    1:     def register(self, dtype: Type[ExtensionDtype]) -> None:
               """
               Parameters
               ----------
               dtype : ExtensionDtype
               """
   14:         if not issubclass(dtype, ExtensionDtype):
                   raise ValueError("can only register pandas extension dtypes")
       
   14:         self.dtypes.append(dtype)
       
           def find(
    1:         self, dtype: Union[Type[ExtensionDtype], str]
    1:     ) -> Optional[Type[ExtensionDtype]]:
               """
               Parameters
               ----------
               dtype : Type[ExtensionDtype] or string
       
               Returns
               -------
               return the first matching dtype, otherwise return None
               """
 1103:         if not isinstance(dtype, str):
 1060:             dtype_type = dtype
 1060:             if not isinstance(dtype, type):
 1056:                 dtype_type = type(dtype)
 1060:             if issubclass(dtype_type, ExtensionDtype):
    1:                 return dtype
       
 1059:             return None
       
  455:         for dtype_type in self.dtypes:
  412:             try:
  412:                 return dtype_type.construct_from_string(dtype)
  412:             except TypeError:
  412:                 pass
       
   43:         return None
       
       
    1: registry = Registry()
       
       
    2: class PandasExtensionDtype(ExtensionDtype):
           """
           A np.dtype duck-typed class, suitable for holding a custom dtype.
       
           THIS IS NOT A REAL NUMPY DTYPE
    1:     """
       
    1:     type = None  # type: Any
    1:     kind = None  # type: Any
           # The Any type annotations above are here only because mypy seems to have a
           # problem dealing with with multiple inheritance from PandasExtensionDtype
           # and ExtensionDtype's @properties in the subclasses below. The kind and
           # type variables in those subclasses are explicitly typed below.
    1:     subdtype = None
    1:     str = None  # type: Optional[str_type]
    1:     num = 100
    1:     shape = tuple()  # type: Tuple[int, ...]
    1:     itemsize = 8
    1:     base = None
    1:     isbuiltin = 0
    1:     isnative = 0
    1:     _cache = {}  # type: Dict[str_type, 'PandasExtensionDtype']
       
    1:     def __str__(self) -> str_type:
               """
               Return a string representation for a particular Object
               """
               return self.name
       
    1:     def __repr__(self) -> str_type:
               """
               Return a string representation for a particular object.
               """
               return str(self)
       
    1:     def __hash__(self) -> int:
               raise NotImplementedError("sub-classes should implement an __hash__ " "method")
       
    1:     def __getstate__(self) -> Dict[str_type, Any]:
               # pickle support; we don't want to pickle the cache
               return {k: getattr(self, k, None) for k in self._metadata}
       
    1:     @classmethod
    1:     def reset_cache(cls) -> None:
               """ clear the cache """
               cls._cache = {}
       
       
    2: class CategoricalDtypeType(type):
           """
           the type of CategoricalDtype, this metaclass determines subclass ability
    1:     """
       
    1:     pass
       
       
    2: @register_extension_dtype
    1: class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
           """
           Type for categorical data with the categories and orderedness.
       
           .. versionchanged:: 0.21.0
       
           Parameters
           ----------
           categories : sequence, optional
               Must be unique, and must not contain any nulls.
           ordered : bool, default False
       
           Attributes
           ----------
           categories
           ordered
       
           Methods
           -------
           None
       
           See Also
           --------
           Categorical
       
           Notes
           -----
           This class is useful for specifying the type of a ``Categorical``
           independent of the values. See :ref:`categorical.categoricaldtype`
           for more.
       
           Examples
           --------
           >>> t = pd.CategoricalDtype(categories=['b', 'a'], ordered=True)
           >>> pd.Series(['a', 'b', 'a', 'c'], dtype=t)
           0      a
           1      b
           2      a
           3    NaN
           dtype: category
           Categories (2, object): [b < a]
    1:     """
       
           # TODO: Document public vs. private API
    1:     name = "category"
    1:     type = CategoricalDtypeType  # type: Type[CategoricalDtypeType]
    1:     kind = "O"  # type: str_type
    1:     str = "|O08"
    1:     base = np.dtype("O")
    1:     _metadata = ("categories", "ordered", "_ordered_from_sentinel")
    1:     _cache = {}  # type: Dict[str_type, PandasExtensionDtype]
       
    1:     def __init__(self, categories=None, ordered: OrderedType = ordered_sentinel):
    1:         self._finalize(categories, ordered, fastpath=False)
       
    1:     @classmethod
           def _from_fastpath(
    1:         cls, categories=None, ordered: Optional[bool] = None
    1:     ) -> "CategoricalDtype":
               self = cls.__new__(cls)
               self._finalize(categories, ordered, fastpath=True)
               return self
       
    1:     @classmethod
           def _from_categorical_dtype(
    1:         cls, dtype: "CategoricalDtype", categories=None, ordered: OrderedType = None
    1:     ) -> "CategoricalDtype":
               if categories is ordered is None:
                   return dtype
               if categories is None:
                   categories = dtype.categories
               if ordered is None:
                   ordered = dtype.ordered
               return cls(categories, ordered)
       
    1:     @classmethod
           def _from_values_or_dtype(
               cls,
               values=None,
               categories=None,
               ordered: Optional[bool] = None,
    1:         dtype: Optional["CategoricalDtype"] = None,
    1:     ) -> "CategoricalDtype":
               """
               Construct dtype from the input parameters used in :class:`Categorical`.
       
               This constructor method specifically does not do the factorization
               step, if that is needed to find the categories. This constructor may
               therefore return ``CategoricalDtype(categories=None, ordered=None)``,
               which may not be useful. Additional steps may therefore have to be
               taken to create the final dtype.
       
               The return dtype is specified from the inputs in this prioritized
               order:
               1. if dtype is a CategoricalDtype, return dtype
               2. if dtype is the string 'category', create a CategoricalDtype from
                  the supplied categories and ordered parameters, and return that.
               3. if values is a categorical, use value.dtype, but override it with
                  categories and ordered if either/both of those are not None.
               4. if dtype is None and values is not a categorical, construct the
                  dtype from categories and ordered, even if either of those is None.
       
               Parameters
               ----------
               values : list-like, optional
                   The list-like must be 1-dimensional.
               categories : list-like, optional
                   Categories for the CategoricalDtype.
               ordered : bool, optional
                   Designating if the categories are ordered.
               dtype : CategoricalDtype or the string "category", optional
                   If ``CategoricalDtype``, cannot be used together with
                   `categories` or `ordered`.
       
               Returns
               -------
               CategoricalDtype
       
               Examples
               --------
               >>> CategoricalDtype._from_values_or_dtype()
               CategoricalDtype(categories=None, ordered=None)
               >>> CategoricalDtype._from_values_or_dtype(categories=['a', 'b'],
               ...                                        ordered=True)
               CategoricalDtype(categories=['a', 'b'], ordered=True)
               >>> dtype1 = CategoricalDtype(['a', 'b'], ordered=True)
               >>> dtype2 = CategoricalDtype(['x', 'y'], ordered=False)
               >>> c = Categorical([0, 1], dtype=dtype1, fastpath=True)
               >>> CategoricalDtype._from_values_or_dtype(c, ['x', 'y'], ordered=True,
               ...                                        dtype=dtype2)
               ValueError: Cannot specify `categories` or `ordered` together with
               `dtype`.
       
               The supplied dtype takes precedence over values' dtype:
       
               >>> CategoricalDtype._from_values_or_dtype(c, dtype=dtype2)
               CategoricalDtype(['x', 'y'], ordered=False)
               """
               from pandas.core.dtypes.common import is_categorical
       
               if dtype is not None:
                   # The dtype argument takes precedence over values.dtype (if any)
                   if isinstance(dtype, str):
                       if dtype == "category":
                           dtype = CategoricalDtype(categories, ordered)
                       else:
                           msg = "Unknown dtype {dtype!r}"
                           raise ValueError(msg.format(dtype=dtype))
                   elif categories is not None or ordered is not None:
                       raise ValueError(
                           "Cannot specify `categories` or `ordered` " "together with `dtype`."
                       )
               elif is_categorical(values):
                   # If no "dtype" was passed, use the one from "values", but honor
                   # the "ordered" and "categories" arguments
                   dtype = values.dtype._from_categorical_dtype(
                       values.dtype, categories, ordered
                   )
               else:
                   # If dtype=None and values is not categorical, create a new dtype.
                   # Note: This could potentially have categories=None and
                   # ordered=None.
                   dtype = CategoricalDtype(categories, ordered)
       
               return dtype
       
           def _finalize(
    1:         self, categories, ordered: OrderedType, fastpath: bool = False
    1:     ) -> None:
       
    1:         if ordered is not None and ordered is not ordered_sentinel:
    1:             self.validate_ordered(ordered)
       
    1:         if categories is not None:
                   categories = self.validate_categories(categories, fastpath=fastpath)
       
    1:         self._categories = categories
    1:         self._ordered = ordered if ordered is not ordered_sentinel else None
    1:         self._ordered_from_sentinel = ordered is ordered_sentinel
       
    1:     def __setstate__(self, state: Dict[str_type, Any]) -> None:
               # for pickle compat. __get_state__ is defined in the
               # PandasExtensionDtype superclass and uses the public properties to
               # pickle -> need to set the settable private ones here (see GH26067)
               self._categories = state.pop("categories", None)
               self._ordered = state.pop("ordered", False)
               self._ordered_from_sentinel = state.pop("_ordered_from_sentinel", False)
       
    1:     def __hash__(self) -> int:
               # _hash_categories returns a uint64, so use the negative
               # space for when we have unknown categories to avoid a conflict
               if self.categories is None:
                   if self._ordered:
                       return -1
                   else:
                       return -2
               # We *do* want to include the real self.ordered here
               return int(self._hash_categories(self.categories, self._ordered))
       
    1:     def __eq__(self, other: Any) -> bool:
               """
               Rules for CDT equality:
               1) Any CDT is equal to the string 'category'
               2) Any CDT is equal to itself
               3) Any CDT is equal to a CDT with categories=None regardless of ordered
               4) A CDT with ordered=True is only equal to another CDT with
                  ordered=True and identical categories in the same order
               5) A CDT with ordered={False, None} is only equal to another CDT with
                  ordered={False, None} and identical categories, but same order is
                  not required. There is no distinction between False/None.
               6) Any other comparison returns False
               """
               if isinstance(other, str):
                   return other == self.name
               elif other is self:
                   return True
               elif not (hasattr(other, "_ordered") and hasattr(other, "categories")):
                   return False
               elif self.categories is None or other.categories is None:
                   # We're forced into a suboptimal corner thanks to math and
                   # backwards compatibility. We require that `CDT(...) == 'category'`
                   # for all CDTs **including** `CDT(None, ...)`. Therefore, *all*
                   # CDT(., .) = CDT(None, False) and *all*
                   # CDT(., .) = CDT(None, True).
                   return True
               elif self._ordered or other._ordered:
                   # At least one has ordered=True; equal if both have ordered=True
                   # and the same values for categories in the same order.
                   return (self._ordered == other._ordered) and self.categories.equals(
                       other.categories
                   )
               else:
                   # Neither has ordered=True; equal if both have the same categories,
                   # but same order is not necessary.  There is no distinction between
                   # ordered=False and ordered=None: CDT(., False) and CDT(., None)
                   # will be equal if they have the same categories.
                   if (
                       self.categories.dtype == other.categories.dtype
                       and self.categories.equals(other.categories)
                   ):
                       # Check and see if they happen to be identical categories
                       return True
                   return hash(self) == hash(other)
       
    1:     def __repr__(self):
               tpl = "CategoricalDtype(categories={}ordered={})"
               if self.categories is None:
                   data = "None, "
               else:
                   data = self.categories._format_data(name=self.__class__.__name__)
               return tpl.format(data, self._ordered)
       
    1:     @staticmethod
    1:     def _hash_categories(categories, ordered: OrderedType = True) -> int:
               from pandas.core.util.hashing import (
                   hash_array,
                   _combine_hash_arrays,
                   hash_tuples,
               )
               from pandas.core.dtypes.common import is_datetime64tz_dtype, _NS_DTYPE
       
               if len(categories) and isinstance(categories[0], tuple):
                   # assumes if any individual category is a tuple, then all our. ATM
                   # I don't really want to support just some of the categories being
                   # tuples.
                   categories = list(categories)  # breaks if a np.array of categories
                   cat_array = hash_tuples(categories)
               else:
                   if categories.dtype == "O":
                       if len({type(x) for x in categories}) != 1:
                           # TODO: hash_array doesn't handle mixed types. It casts
                           # everything to a str first, which means we treat
                           # {'1', '2'} the same as {'1', 2}
                           # find a better solution
                           hashed = hash((tuple(categories), ordered))
                           return hashed
       
                   if is_datetime64tz_dtype(categories.dtype):
                       # Avoid future warning.
                       categories = categories.astype(_NS_DTYPE)
       
                   cat_array = hash_array(np.asarray(categories), categorize=False)
               if ordered:
                   cat_array = np.vstack(
                       [cat_array, np.arange(len(cat_array), dtype=cat_array.dtype)]
                   )
               else:
                   cat_array = [cat_array]
               hashed = _combine_hash_arrays(iter(cat_array), num_items=len(cat_array))
               return np.bitwise_xor.reduce(hashed)
       
    1:     @classmethod
           def construct_array_type(cls):
               """
               Return the array type associated with this dtype
       
               Returns
               -------
               type
               """
               from pandas import Categorical
       
               return Categorical
       
    1:     @staticmethod
    1:     def validate_ordered(ordered: OrderedType) -> None:
               """
               Validates that we have a valid ordered parameter. If
               it is not a boolean, a TypeError will be raised.
       
               Parameters
               ----------
               ordered : object
                   The parameter to be verified.
       
               Raises
               ------
               TypeError
                   If 'ordered' is not a boolean.
               """
    1:         from pandas.core.dtypes.common import is_bool
       
    1:         if not is_bool(ordered):
                   raise TypeError("'ordered' must either be 'True' or 'False'")
       
    1:     @staticmethod
    1:     def validate_categories(categories, fastpath: bool = False):
               """
               Validates that we have good categories
       
               Parameters
               ----------
               categories : array-like
               fastpath : bool
                   Whether to skip nan and uniqueness checks
       
               Returns
               -------
               categories : Index
               """
               from pandas.core.indexes.base import Index
       
               if not fastpath and not is_list_like(categories):
                   msg = "Parameter 'categories' must be list-like, was {!r}"
                   raise TypeError(msg.format(categories))
               elif not isinstance(categories, ABCIndexClass):
                   categories = Index(categories, tupleize_cols=False)
       
               if not fastpath:
       
                   if categories.hasnans:
                       raise ValueError("Categorial categories cannot be null")
       
                   if not categories.is_unique:
                       raise ValueError("Categorical categories must be unique")
       
               if isinstance(categories, ABCCategoricalIndex):
                   categories = categories.categories
       
               return categories
       
    1:     def update_dtype(self, dtype: "CategoricalDtype") -> "CategoricalDtype":
               """
               Returns a CategoricalDtype with categories and ordered taken from dtype
               if specified, otherwise falling back to self if unspecified
       
               Parameters
               ----------
               dtype : CategoricalDtype
       
               Returns
               -------
               new_dtype : CategoricalDtype
               """
               if isinstance(dtype, str) and dtype == "category":
                   # dtype='category' should not change anything
                   return self
               elif not self.is_dtype(dtype):
                   msg = (
                       "a CategoricalDtype must be passed to perform an update, "
                       "got {dtype!r}"
                   ).format(dtype=dtype)
                   raise ValueError(msg)
       
               # dtype is CDT: keep current categories/ordered if None
               new_categories = dtype.categories
               if new_categories is None:
                   new_categories = self.categories
       
               new_ordered = dtype._ordered
               new_ordered_from_sentinel = dtype._ordered_from_sentinel
               if new_ordered is None:
                   # maintain existing ordered if new dtype has ordered=None
                   new_ordered = self._ordered
                   if self._ordered and new_ordered_from_sentinel:
                       # only warn if we'd actually change the existing behavior
                       msg = (
                           "Constructing a CategoricalDtype without specifying "
                           "`ordered` will default to `ordered=False` in a future "
                           "version, which will cause the resulting categorical's "
                           "`ordered` attribute to change to False; `ordered=True`"
                           " must be explicitly passed in order to be retained"
                       )
                       warnings.warn(msg, FutureWarning, stacklevel=3)
       
               return CategoricalDtype(new_categories, new_ordered)
       
    1:     @property
           def categories(self):
               """
               An ``Index`` containing the unique categories allowed.
               """
               return self._categories
       
    1:     @property
    1:     def ordered(self) -> OrderedType:
               """
               Whether the categories have an ordered relationship.
               """
               # TODO: remove if block when ordered=None as default is deprecated
               if self._ordered_from_sentinel and self._ordered is None:
                   # warn when accessing ordered if ordered=None and None was not
                   # explicitly passed to the constructor
                   msg = (
                       "Constructing a CategoricalDtype without specifying "
                       "`ordered` will default to `ordered=False` in a future "
                       "version; `ordered=None` must be explicitly passed."
                   )
                   warnings.warn(msg, FutureWarning, stacklevel=2)
               return self._ordered
       
    1:     @property
    1:     def _is_boolean(self) -> bool:
               from pandas.core.dtypes.common import is_bool_dtype
       
               return is_bool_dtype(self.categories)
       
       
    2: @register_extension_dtype
    1: class DatetimeTZDtype(PandasExtensionDtype):
           """
           An ExtensionDtype for timezone-aware datetime data.
       
           **This is not an actual numpy dtype**, but a duck type.
       
           Parameters
           ----------
           unit : str, default "ns"
               The precision of the datetime data. Currently limited
               to ``"ns"``.
           tz : str, int, or datetime.tzinfo
               The timezone.
       
           Attributes
           ----------
           unit
           tz
       
           Methods
           -------
           None
       
           Raises
           ------
           pytz.UnknownTimeZoneError
               When the requested timezone cannot be found.
       
           Examples
           --------
           >>> pd.DatetimeTZDtype(tz='UTC')
           datetime64[ns, UTC]
       
           >>> pd.DatetimeTZDtype(tz='dateutil/US/Central')
           datetime64[ns, tzfile('/usr/share/zoneinfo/US/Central')]
    1:     """
       
    1:     type = Timestamp  # type: Type[Timestamp]
    1:     kind = "M"  # type: str_type
    1:     str = "|M8[ns]"
    1:     num = 101
    1:     base = np.dtype("M8[ns]")
    1:     na_value = NaT
    1:     _metadata = ("unit", "tz")
    1:     _match = re.compile(r"(datetime64|M8)\[(?P<unit>.+), (?P<tz>.+)\]")
    1:     _cache = {}  # type: Dict[str_type, PandasExtensionDtype]
       
    1:     def __init__(self, unit="ns", tz=None):
               if isinstance(unit, DatetimeTZDtype):
                   unit, tz = unit.unit, unit.tz
       
               if unit != "ns":
                   if isinstance(unit, str) and tz is None:
                       # maybe a string like datetime64[ns, tz], which we support for
                       # now.
                       result = type(self).construct_from_string(unit)
                       unit = result.unit
                       tz = result.tz
                       msg = (
                           "Passing a dtype alias like 'datetime64[ns, {tz}]' "
                           "to DatetimeTZDtype is deprecated. Use "
                           "'DatetimeTZDtype.construct_from_string()' instead."
                       )
                       warnings.warn(msg.format(tz=tz), FutureWarning, stacklevel=2)
                   else:
                       raise ValueError("DatetimeTZDtype only supports ns units")
       
               if tz:
                   tz = timezones.maybe_get_tz(tz)
                   tz = timezones.tz_standardize(tz)
               elif tz is not None:
                   raise pytz.UnknownTimeZoneError(tz)
               elif tz is None:
                   raise TypeError("A 'tz' is required.")
       
               self._unit = unit
               self._tz = tz
       
    1:     @property
           def unit(self):
               """
               The precision of the datetime data.
               """
               return self._unit
       
    1:     @property
           def tz(self):
               """
               The timezone.
               """
               return self._tz
       
    1:     @classmethod
           def construct_array_type(cls):
               """
               Return the array type associated with this dtype
       
               Returns
               -------
               type
               """
               from pandas.core.arrays import DatetimeArray
       
               return DatetimeArray
       
    1:     @classmethod
           def construct_from_string(cls, string):
               """
               Construct a DatetimeTZDtype from a string.
       
               Parameters
               ----------
               string : str
                   The string alias for this DatetimeTZDtype.
                   Should be formatted like ``datetime64[ns, <tz>]``,
                   where ``<tz>`` is the timezone name.
       
               Examples
               --------
               >>> DatetimeTZDtype.construct_from_string('datetime64[ns, UTC]')
               datetime64[ns, UTC]
               """
   86:         if isinstance(string, str):
   47:             msg = "Could not construct DatetimeTZDtype from '{}'"
   47:             try:
   47:                 match = cls._match.match(string)
   47:                 if match:
                           d = match.groupdict()
                           return cls(unit=d["unit"], tz=d["tz"])
                   except Exception:
                       # TODO(py3): Change this pass to `raise TypeError(msg) from e`
                       pass
   47:             raise TypeError(msg.format(string))
       
   39:         raise TypeError("Could not construct DatetimeTZDtype")
       
    1:     def __str__(self):
               return "datetime64[{unit}, {tz}]".format(unit=self.unit, tz=self.tz)
       
    1:     @property
           def name(self):
               """A string representation of the dtype."""
               return str(self)
       
    1:     def __hash__(self):
               # make myself hashable
               # TODO: update this.
               return hash(str(self))
       
    1:     def __eq__(self, other):
               if isinstance(other, str):
                   return other == self.name
       
               return (
                   isinstance(other, DatetimeTZDtype)
                   and self.unit == other.unit
                   and str(self.tz) == str(other.tz)
               )
       
    1:     def __setstate__(self, state):
               # for pickle compat. __get_state__ is defined in the
               # PandasExtensionDtype superclass and uses the public properties to
               # pickle -> need to set the settable private ones here (see GH26067)
               self._tz = state["tz"]
               self._unit = state["unit"]
       
       
    2: @register_extension_dtype
    1: class PeriodDtype(PandasExtensionDtype):
           """
           An ExtensionDtype for Period data.
       
           **This is not an actual numpy dtype**, but a duck type.
       
           Parameters
           ----------
           freq : str or DateOffset
               The frequency of this PeriodDtype
       
           Attributes
           ----------
           freq
       
           Methods
           -------
           None
       
           Examples
           --------
           >>> pd.PeriodDtype(freq='D')
           period[D]
       
           >>> pd.PeriodDtype(freq=pd.offsets.MonthEnd())
           period[M]
    1:     """
       
    1:     type = Period  # type: Type[Period]
    1:     kind = "O"  # type: str_type
    1:     str = "|O08"
    1:     base = np.dtype("O")
    1:     num = 102
    1:     _metadata = ("freq",)
    1:     _match = re.compile(r"(P|p)eriod\[(?P<freq>.+)\]")
    1:     _cache = {}  # type: Dict[str_type, PandasExtensionDtype]
       
    1:     def __new__(cls, freq=None):
               """
               Parameters
               ----------
               freq : frequency
               """
       
               if isinstance(freq, PeriodDtype):
                   return freq
       
               elif freq is None:
                   # empty constructor for pickle compat
                   u = object.__new__(cls)
                   u._freq = None
                   return u
       
               if not isinstance(freq, ABCDateOffset):
                   freq = cls._parse_dtype_strict(freq)
       
               try:
                   return cls._cache[freq.freqstr]
               except KeyError:
                   u = object.__new__(cls)
                   u._freq = freq
                   cls._cache[freq.freqstr] = u
                   return u
       
    1:     @property
           def freq(self):
               """
               The frequency object of this PeriodDtype.
               """
               return self._freq
       
    1:     @classmethod
           def _parse_dtype_strict(cls, freq):
               if isinstance(freq, str):
                   if freq.startswith("period[") or freq.startswith("Period["):
                       m = cls._match.search(freq)
                       if m is not None:
                           freq = m.group("freq")
                   from pandas.tseries.frequencies import to_offset
       
                   freq = to_offset(freq)
                   if freq is not None:
                       return freq
       
               raise ValueError("could not construct PeriodDtype")
       
    1:     @classmethod
           def construct_from_string(cls, string):
               """
               Strict construction from a string, raise a TypeError if not
               possible
               """
               if (
   51:             isinstance(string, str)
   43:             and (string.startswith("period[") or string.startswith("Period["))
   51:             or isinstance(string, ABCDateOffset)
               ):
                   # do not parse string like U as period[U]
                   # avoid tuple to be regarded as freq
                   try:
                       return cls(freq=string)
                   except ValueError:
                       pass
   51:         raise TypeError("could not construct PeriodDtype")
       
    1:     def __str__(self):
               return self.name
       
    1:     @property
           def name(self):
               return "period[{freq}]".format(freq=self.freq.freqstr)
       
    1:     @property
           def na_value(self):
               return NaT
       
    1:     def __hash__(self):
               # make myself hashable
               return hash(str(self))
       
    1:     def __eq__(self, other):
               if isinstance(other, str):
                   return other == self.name or other == self.name.title()
       
               return isinstance(other, PeriodDtype) and self.freq == other.freq
       
    1:     def __setstate__(self, state):
               # for pickle compat. __get_state__ is defined in the
               # PandasExtensionDtype superclass and uses the public properties to
               # pickle -> need to set the settable private ones here (see GH26067)
               self._freq = state["freq"]
       
    1:     @classmethod
           def is_dtype(cls, dtype):
               """
               Return a boolean if we if the passed type is an actual dtype that we
               can match (via string or type)
               """
       
  106:         if isinstance(dtype, str):
                   # PeriodDtype can be instantiated from freq string like "U",
                   # but doesn't regard freq str like "U" as dtype.
    4:             if dtype.startswith("period[") or dtype.startswith("Period["):
                       try:
                           if cls._parse_dtype_strict(dtype) is not None:
                               return True
                           else:
                               return False
                       except ValueError:
                           return False
                   else:
    4:                 return False
  102:         return super().is_dtype(dtype)
       
    1:     @classmethod
           def construct_array_type(cls):
               from pandas.core.arrays import PeriodArray
       
               return PeriodArray
       
       
    2: @register_extension_dtype
    1: class IntervalDtype(PandasExtensionDtype):
           """
           An ExtensionDtype for Interval data.
       
           **This is not an actual numpy dtype**, but a duck type.
       
           Parameters
           ----------
           subtype : str, np.dtype
               The dtype of the Interval bounds.
       
           Attributes
           ----------
           subtype
       
           Methods
           -------
           None
       
           Examples
           --------
           >>> pd.IntervalDtype(subtype='int64')
           interval[int64]
    1:     """
       
    1:     name = "interval"
    1:     kind = None  # type: Optional[str_type]
    1:     str = "|O08"
    1:     base = np.dtype("O")
    1:     num = 103
    1:     _metadata = ("subtype",)
    1:     _match = re.compile(r"(I|i)nterval\[(?P<subtype>.+)\]")
    1:     _cache = {}  # type: Dict[str_type, PandasExtensionDtype]
       
    1:     def __new__(cls, subtype=None):
               from pandas.core.dtypes.common import (
                   is_categorical_dtype,
                   is_string_dtype,
                   pandas_dtype,
               )
       
               if isinstance(subtype, IntervalDtype):
                   return subtype
               elif subtype is None:
                   # we are called as an empty constructor
                   # generally for pickle compat
                   u = object.__new__(cls)
                   u._subtype = None
                   return u
               elif isinstance(subtype, str) and subtype.lower() == "interval":
                   subtype = None
               else:
                   if isinstance(subtype, str):
                       m = cls._match.search(subtype)
                       if m is not None:
                           subtype = m.group("subtype")
       
                   try:
                       subtype = pandas_dtype(subtype)
                   except TypeError:
                       raise TypeError("could not construct IntervalDtype")
       
               if is_categorical_dtype(subtype) or is_string_dtype(subtype):
                   # GH 19016
                   msg = (
                       "category, object, and string subtypes are not supported "
                       "for IntervalDtype"
                   )
                   raise TypeError(msg)
       
               try:
                   return cls._cache[str(subtype)]
               except KeyError:
                   u = object.__new__(cls)
                   u._subtype = subtype
                   cls._cache[str(subtype)] = u
                   return u
       
    1:     @property
           def subtype(self):
               """
               The dtype of the Interval bounds.
               """
               return self._subtype
       
    1:     @classmethod
           def construct_array_type(cls):
               """
               Return the array type associated with this dtype
       
               Returns
               -------
               type
               """
               from pandas.core.arrays import IntervalArray
       
               return IntervalArray
       
    1:     @classmethod
           def construct_from_string(cls, string):
               """
               attempt to construct this type from a string, raise a TypeError
               if its not possible
               """
   51:         if not isinstance(string, str):
    8:             msg = "a string needs to be passed, got type {typ}"
    8:             raise TypeError(msg.format(typ=type(string)))
       
   43:         if string.lower() == "interval" or cls._match.search(string) is not None:
                   return cls(string)
       
               msg = (
   43:             "Incorrectly formatted string passed to constructor. "
                   "Valid formats include Interval or Interval[dtype] "
                   "where dtype is numeric, datetime, or timedelta"
               )
   43:         raise TypeError(msg)
       
    1:     @property
           def type(self):
               return Interval
       
    1:     def __str__(self):
               if self.subtype is None:
                   return "interval"
               return "interval[{subtype}]".format(subtype=self.subtype)
       
    1:     def __hash__(self):
               # make myself hashable
               return hash(str(self))
       
    1:     def __eq__(self, other):
               if isinstance(other, str):
                   return other.lower() in (self.name.lower(), str(self).lower())
               elif not isinstance(other, IntervalDtype):
                   return False
               elif self.subtype is None or other.subtype is None:
                   # None should match any subtype
                   return True
               else:
                   from pandas.core.dtypes.common import is_dtype_equal
       
                   return is_dtype_equal(self.subtype, other.subtype)
       
    1:     def __setstate__(self, state):
               # for pickle compat. __get_state__ is defined in the
               # PandasExtensionDtype superclass and uses the public properties to
               # pickle -> need to set the settable private ones here (see GH26067)
               self._subtype = state["subtype"]
       
    1:     @classmethod
           def is_dtype(cls, dtype):
               """
               Return a boolean if we if the passed type is an actual dtype that we
               can match (via string or type)
               """
       
   98:         if isinstance(dtype, str):
                   if dtype.lower().startswith("interval"):
                       try:
                           if cls.construct_from_string(dtype) is not None:
                               return True
                           else:
                               return False
                       except (ValueError, TypeError):
                           return False
                   else:
                       return False
   98:         return super().is_dtype(dtype)
