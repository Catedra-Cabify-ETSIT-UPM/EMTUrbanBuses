       """
       The config module holds package-wide configurables and provides
       a uniform API for working with them.
       
       Overview
       ========
       
       This module supports the following requirements:
       - options are referenced using keys in dot.notation, e.g. "x.y.option - z".
       - keys are case-insensitive.
       - functions should accept partial/regex keys, when unambiguous.
       - options can be registered by modules at import time.
       - options can be registered at init-time (via core.config_init)
       - options have a default value, and (optionally) a description and
         validation function associated with them.
       - options can be deprecated, in which case referencing them
         should produce a warning.
       - deprecated options can optionally be rerouted to a replacement
         so that accessing a deprecated option reroutes to a differently
         named option.
       - options can be reset to their default value.
       - all option can be reset to their default value at once.
       - all options in a certain sub - namespace can be reset at once.
       - the user can set / get / reset or ask for the description of an option.
       - a developer can register and mark an option as deprecated.
       - you can register a callback to be invoked when the option value
         is set or reset. Changing the stored value is considered misuse, but
         is not verboten.
       
       Implementation
       ==============
       
       - Data is stored using nested dictionaries, and should be accessed
         through the provided API.
       
       - "Registered options" and "Deprecated options" have metadata associated
         with them, which are stored in auxiliary dictionaries keyed on the
         fully-qualified key, e.g. "x.y.z.option".
       
       - the config_init module is imported by the package's __init__.py file.
         placing any register_option() calls there will ensure those options
         are available as soon as pandas is loaded. If you use register_option
         in a module, it will only be available after that module is imported,
         which you should be aware of.
       
       - `config_prefix` is a context_manager (for use with the `with` keyword)
         which can save developers some typing, see the docstring.
       
    1: """
       
    1: from collections import namedtuple
    1: from contextlib import contextmanager
    1: import re
    1: from typing import Dict, List
    1: import warnings
       
    1: DeprecatedOption = namedtuple("DeprecatedOption", "key msg rkey removal_ver")
    1: RegisteredOption = namedtuple("RegisteredOption", "key defval doc validator cb")
       
       # holds deprecated option metdata
    1: _deprecated_options = {}  # type: Dict[str, DeprecatedOption]
       
       # holds registered option metdata
    1: _registered_options = {}  # type: Dict[str, RegisteredOption]
       
       # holds the current values for registered options
    1: _global_config = {}  # type: Dict[str, str]
       
       # keys which have a special meaning
    1: _reserved_keys = ["all"]  # type: List[str]
       
       
    2: class OptionError(AttributeError, KeyError):
           """Exception for pandas.options, backwards compatible with KeyError
           checks
    1:     """
       
       
       #
       # User API
       
       
    1: def _get_single_key(pat, silent):
    3:     keys = _select_options(pat)
    3:     if len(keys) == 0:
               if not silent:
                   _warn_if_deprecated(pat)
               raise OptionError("No such keys(s): {pat!r}".format(pat=pat))
    3:     if len(keys) > 1:
               raise OptionError("Pattern matched multiple keys")
    3:     key = keys[0]
       
    3:     if not silent:
    3:         _warn_if_deprecated(key)
       
    3:     key = _translate_key(key)
       
    3:     return key
       
       
    1: def _get_option(pat, silent=False):
    3:     key = _get_single_key(pat, silent)
       
           # walk the nested dict
    3:     root, k = _get_root(key)
    3:     return root[k]
       
       
    1: def _set_option(*args, **kwargs):
           # must at least 1 arg deal with constraints later
           nargs = len(args)
           if not nargs or nargs % 2 != 0:
               raise ValueError("Must provide an even number of non-keyword " "arguments")
       
           # default to false
           silent = kwargs.pop("silent", False)
       
           if kwargs:
               msg = '_set_option() got an unexpected keyword argument "{kwarg}"'
               raise TypeError(msg.format(list(kwargs.keys())[0]))
       
           for k, v in zip(args[::2], args[1::2]):
               key = _get_single_key(k, silent)
       
               o = _get_registered_option(key)
               if o and o.validator:
                   o.validator(v)
       
               # walk the nested dict
               root, k = _get_root(key)
               root[k] = v
       
               if o.cb:
                   if silent:
                       with warnings.catch_warnings(record=True):
                           o.cb(key)
                   else:
                       o.cb(key)
       
       
    1: def _describe_option(pat="", _print_desc=True):
       
           keys = _select_options(pat)
           if len(keys) == 0:
               raise OptionError("No such keys(s)")
       
           s = ""
           for k in keys:  # filter by pat
               s += _build_option_description(k)
       
           if _print_desc:
               print(s)
           else:
               return s
       
       
    1: def _reset_option(pat, silent=False):
       
           keys = _select_options(pat)
       
           if len(keys) == 0:
               raise OptionError("No such keys(s)")
       
           if len(keys) > 1 and len(pat) < 4 and pat != "all":
               raise ValueError(
                   "You must specify at least 4 characters when "
                   "resetting multiple keys, use the special keyword "
                   '"all" to reset all the options to their default '
                   "value"
               )
       
           for k in keys:
               _set_option(k, _registered_options[k].defval, silent=silent)
       
       
    1: def get_default_val(pat):
           key = _get_single_key(pat, silent=True)
           return _get_registered_option(key).defval
       
       
    2: class DictWrapper:
    1:     """ provide attribute-style access to a nested dict"""
       
    1:     def __init__(self, d, prefix=""):
    1:         object.__setattr__(self, "d", d)
    1:         object.__setattr__(self, "prefix", prefix)
       
    1:     def __setattr__(self, key, val):
               prefix = object.__getattribute__(self, "prefix")
               if prefix:
                   prefix += "."
               prefix += key
               # you can't set new keys
               # can you can't overwrite subtrees
               if key in self.d and not isinstance(self.d[key], dict):
                   _set_option(prefix, val)
               else:
                   raise OptionError("You can only set the value of existing options")
       
    1:     def __getattr__(self, key):
               prefix = object.__getattribute__(self, "prefix")
               if prefix:
                   prefix += "."
               prefix += key
               try:
                   v = object.__getattribute__(self, "d")[key]
               except KeyError:
                   raise OptionError("No such option")
               if isinstance(v, dict):
                   return DictWrapper(v, prefix)
               else:
                   return _get_option(prefix)
       
    1:     def __dir__(self):
               return list(self.d.keys())
       
       
       # For user convenience,  we'd like to have the available options described
       # in the docstring. For dev convenience we'd like to generate the docstrings
       # dynamically instead of maintaining them by hand. To this, we use the
       # class below which wraps functions inside a callable, and converts
       # __doc__ into a property function. The doctsrings below are templates
       # using the py2.6+ advanced formatting syntax to plug in a concise list
       # of options, and option descriptions.
       
       
    2: class CallableDynamicDoc:
    1:     def __init__(self, func, doc_tmpl):
    4:         self.__doc_tmpl__ = doc_tmpl
    4:         self.__func__ = func
       
    1:     def __call__(self, *args, **kwds):
    3:         return self.__func__(*args, **kwds)
       
    1:     @property
           def __doc__(self):
               opts_desc = _describe_option("all", _print_desc=False)
               opts_list = pp_options_list(list(_registered_options.keys()))
               return self.__doc_tmpl__.format(opts_desc=opts_desc, opts_list=opts_list)
       
       
       _get_option_tmpl = """
       get_option(pat)
       
       Retrieves the value of the specified option.
       
       Available options:
       
       {opts_list}
       
       Parameters
       ----------
       pat : str
           Regexp which should match a single option.
           Note: partial matches are supported for convenience, but unless you use the
           full option name (e.g. x.y.z.option_name), your code may break in future
           versions if new options with similar names are introduced.
       
       Returns
       -------
       result : the value of the option
       
       Raises
       ------
       OptionError : if no such option exists
       
       Notes
       -----
       The available options with its descriptions:
       
       {opts_desc}
    1: """
       
       _set_option_tmpl = """
       set_option(pat, value)
       
       Sets the value of the specified option.
       
       Available options:
       
       {opts_list}
       
       Parameters
       ----------
       pat : str
           Regexp which should match a single option.
           Note: partial matches are supported for convenience, but unless you use the
           full option name (e.g. x.y.z.option_name), your code may break in future
           versions if new options with similar names are introduced.
       value : object
           New value of option.
       
       Returns
       -------
       None
       
       Raises
       ------
       OptionError if no such option exists
       
       Notes
       -----
       The available options with its descriptions:
       
       {opts_desc}
    1: """
       
       _describe_option_tmpl = """
       describe_option(pat, _print_desc=False)
       
       Prints the description for one or more registered options.
       
       Call with not arguments to get a listing for all registered options.
       
       Available options:
       
       {opts_list}
       
       Parameters
       ----------
       pat : str
           Regexp pattern. All matching keys will have their description displayed.
       _print_desc : bool, default True
           If True (default) the description(s) will be printed to stdout.
           Otherwise, the description(s) will be returned as a unicode string
           (for testing).
       
       Returns
       -------
       None by default, the description(s) as a unicode string if _print_desc
       is False
       
       Notes
       -----
       The available options with its descriptions:
       
       {opts_desc}
    1: """
       
       _reset_option_tmpl = """
       reset_option(pat)
       
       Reset one or more options to their default value.
       
       Pass "all" as argument to reset all options.
       
       Available options:
       
       {opts_list}
       
       Parameters
       ----------
       pat : str/regex
           If specified only options matching `prefix*` will be reset.
           Note: partial matches are supported for convenience, but unless you
           use the full option name (e.g. x.y.z.option_name), your code may break
           in future versions if new options with similar names are introduced.
       
       Returns
       -------
       None
       
       Notes
       -----
       The available options with its descriptions:
       
       {opts_desc}
    1: """
       
       # bind the functions with their docstrings into a Callable
       # and use that as the functions exposed in pd.api
    1: get_option = CallableDynamicDoc(_get_option, _get_option_tmpl)
    1: set_option = CallableDynamicDoc(_set_option, _set_option_tmpl)
    1: reset_option = CallableDynamicDoc(_reset_option, _reset_option_tmpl)
    1: describe_option = CallableDynamicDoc(_describe_option, _describe_option_tmpl)
    1: options = DictWrapper(_global_config)
       
       #
       # Functions for use by pandas developers, in addition to User - api
       
       
    2: class option_context:
           """
           Context manager to temporarily set options in the `with` statement context.
       
           You need to invoke as ``option_context(pat, val, [(pat, val), ...])``.
       
           Examples
           --------
       
           >>> with option_context('display.max_rows', 10, 'display.max_columns', 5):
           ...     ...
    1:     """
       
    1:     def __init__(self, *args):
               if not (len(args) % 2 == 0 and len(args) >= 2):
                   raise ValueError(
                       "Need to invoke as" " option_context(pat, val, [(pat, val), ...])."
                   )
       
               self.ops = list(zip(args[::2], args[1::2]))
       
    1:     def __enter__(self):
               self.undo = [(pat, _get_option(pat, silent=True)) for pat, val in self.ops]
       
               for pat, val in self.ops:
                   _set_option(pat, val, silent=True)
       
    1:     def __exit__(self, *args):
               if self.undo:
                   for pat, val in self.undo:
                       _set_option(pat, val, silent=True)
       
       
    1: def register_option(key, defval, doc="", validator=None, cb=None):
           """Register an option in the package-wide pandas config object
       
           Parameters
           ----------
           key       - a fully-qualified key, e.g. "x.y.option - z".
           defval    - the default value of the option
           doc       - a string description of the option
           validator - a function of a single argument, should raise `ValueError` if
                       called with a value which is not a legal value for the option.
           cb        - a function of a single argument "key", which is called
                       immediately after an option value is set/reset. key is
                       the full name of the option.
       
           Returns
           -------
           Nothing.
       
           Raises
           ------
           ValueError if `validator` is specified and `defval` is not a valid value.
       
           """
   53:     import tokenize
   53:     import keyword
       
   53:     key = key.lower()
       
   53:     if key in _registered_options:
               msg = "Option '{key}' has already been registered"
               raise OptionError(msg.format(key=key))
   53:     if key in _reserved_keys:
               msg = "Option '{key}' is a reserved key"
               raise OptionError(msg.format(key=key))
       
           # the default value should be legal
   53:     if validator:
   47:         validator(defval)
       
           # walk the nested dict, creating dicts as needed along the path
   53:     path = key.split(".")
       
  188:     for k in path:
  135:         if not bool(re.match("^" + tokenize.Name + "$", k)):
                   raise ValueError("{k} is not a valid identifier".format(k=k))
  135:         if keyword.iskeyword(k):
                   raise ValueError("{k} is a python keyword".format(k=k))
       
   53:     cursor = _global_config
   53:     msg = "Path prefix to option '{option}' is already an option"
  135:     for i, p in enumerate(path[:-1]):
   82:         if not isinstance(cursor, dict):
                   raise OptionError(msg.format(option=".".join(path[:i])))
   82:         if p not in cursor:
   16:             cursor[p] = {}
   82:         cursor = cursor[p]
       
   53:     if not isinstance(cursor, dict):
               raise OptionError(msg.format(option=".".join(path[:-1])))
       
   53:     cursor[path[-1]] = defval  # initialize
       
           # save the option metadata
   53:     _registered_options[key] = RegisteredOption(
   53:         key=key, defval=defval, doc=doc, validator=validator, cb=cb
           )
       
       
    1: def deprecate_option(key, msg=None, rkey=None, removal_ver=None):
           """
           Mark option `key` as deprecated, if code attempts to access this option,
           a warning will be produced, using `msg` if given, or a default message
           if not.
           if `rkey` is given, any access to the key will be re-routed to `rkey`.
       
           Neither the existence of `key` nor that if `rkey` is checked. If they
           do not exist, any subsequence access will fail as usual, after the
           deprecation warning is given.
       
           Parameters
           ----------
           key - the name of the option to be deprecated. must be a fully-qualified
                 option name (e.g "x.y.z.rkey").
       
           msg - (Optional) a warning message to output when the key is referenced.
                 if no message is given a default message will be emitted.
       
           rkey - (Optional) the name of an option to reroute access to.
                  If specified, any referenced `key` will be re-routed to `rkey`
                  including set/get/reset.
                  rkey must be a fully-qualified option name (e.g "x.y.z.rkey").
                  used by the default message if no `msg` is specified.
       
           removal_ver - (Optional) specifies the version in which this option will
                         be removed. used by the default message if no `msg`
                         is specified.
       
           Returns
           -------
           Nothing
       
           Raises
           ------
           OptionError - if key has already been deprecated.
       
           """
       
    1:     key = key.lower()
       
    1:     if key in _deprecated_options:
               msg = "Option '{key}' has already been defined as deprecated."
               raise OptionError(msg.format(key=key))
       
    1:     _deprecated_options[key] = DeprecatedOption(key, msg, rkey, removal_ver)
       
       
       #
       # functions internal to the module
       
       
    1: def _select_options(pat):
           """returns a list of keys matching `pat`
       
           if pat=="all", returns all registered options
           """
       
           # short-circuit for exact key
    3:     if pat in _registered_options:
    3:         return [pat]
       
           # else look through all of them
           keys = sorted(_registered_options.keys())
           if pat == "all":  # reserved key
               return keys
       
           return [k for k in keys if re.search(pat, k, re.I)]
       
       
    1: def _get_root(key):
    3:     path = key.split(".")
    3:     cursor = _global_config
    8:     for p in path[:-1]:
    5:         cursor = cursor[p]
    3:     return cursor, path[-1]
       
       
    1: def _is_deprecated(key):
           """ Returns True if the given option has been deprecated """
       
           key = key.lower()
           return key in _deprecated_options
       
       
    1: def _get_deprecated_option(key):
           """
           Retrieves the metadata for a deprecated option, if `key` is deprecated.
       
           Returns
           -------
           DeprecatedOption (namedtuple) if key is deprecated, None otherwise
           """
       
    6:     try:
    6:         d = _deprecated_options[key]
    6:     except KeyError:
    6:         return None
           else:
               return d
       
       
    1: def _get_registered_option(key):
           """
           Retrieves the option metadata if `key` is a registered option.
       
           Returns
           -------
           RegisteredOption (namedtuple) if key is deprecated, None otherwise
           """
           return _registered_options.get(key)
       
       
    1: def _translate_key(key):
           """
           if key id deprecated and a replacement key defined, will return the
           replacement key, otherwise returns `key` as - is
           """
       
    3:     d = _get_deprecated_option(key)
    3:     if d:
               return d.rkey or key
           else:
    3:         return key
       
       
    1: def _warn_if_deprecated(key):
           """
           Checks if `key` is a deprecated option and if so, prints a warning.
       
           Returns
           -------
           bool - True if `key` is deprecated, False otherwise.
           """
       
    3:     d = _get_deprecated_option(key)
    3:     if d:
               if d.msg:
                   print(d.msg)
                   warnings.warn(d.msg, FutureWarning)
               else:
                   msg = "'{key}' is deprecated".format(key=key)
                   if d.removal_ver:
                       msg += " and will be removed in {version}".format(version=d.removal_ver)
                   if d.rkey:
                       msg += ", please use '{rkey}' instead.".format(rkey=d.rkey)
                   else:
                       msg += ", please refrain from using it."
       
                   warnings.warn(msg, FutureWarning)
               return True
    3:     return False
       
       
    1: def _build_option_description(k):
           """ Builds a formatted description of a registered option and prints it """
       
           o = _get_registered_option(k)
           d = _get_deprecated_option(k)
       
           s = "{k} ".format(k=k)
       
           if o.doc:
               s += "\n".join(o.doc.strip().split("\n"))
           else:
               s += "No description available."
       
           if o:
               s += "\n    [default: {default}] [currently: {current}]".format(
                   default=o.defval, current=_get_option(k, True)
               )
       
           if d:
               s += "\n    (Deprecated"
               s += ", use `{rkey}` instead.".format(rkey=d.rkey if d.rkey else "")
               s += ")"
       
           return s
       
       
    1: def pp_options_list(keys, width=80, _print=False):
           """ Builds a concise listing of available options, grouped by prefix """
       
           from textwrap import wrap
           from itertools import groupby
       
           def pp(name, ks):
               pfx = "- " + name + ".[" if name else ""
               ls = wrap(
                   ", ".join(ks),
                   width,
                   initial_indent=pfx,
                   subsequent_indent="  ",
                   break_long_words=False,
               )
               if ls and ls[-1] and name:
                   ls[-1] = ls[-1] + "]"
               return ls
       
           ls = []
           singles = [x for x in sorted(keys) if x.find(".") < 0]
           if singles:
               ls += pp("", singles)
           keys = [x for x in keys if x.find(".") >= 0]
       
           for k, g in groupby(sorted(keys), lambda x: x[: x.rfind(".")]):
               ks = [x[len(k) + 1 :] for x in list(g)]
               ls += pp(k, ks)
           s = "\n".join(ls)
           if _print:
               print(s)
           else:
               return s
       
       
       #
       # helpers
       
       
    1: @contextmanager
       def config_prefix(prefix):
           """contextmanager for multiple invocations of API with a common prefix
       
           supported API functions: (register / get / set )__option
       
           Warning: This is not thread - safe, and won't work properly if you import
           the API functions into your module using the "from x import y" construct.
       
           Example:
       
           import pandas._config.config as cf
           with cf.config_prefix("display.font"):
               cf.register_option("color", "red")
               cf.register_option("size", " 5 pt")
               cf.set_option(size, " 6 pt")
               cf.get_option(size)
               ...
       
               etc'
       
           will register options "display.font.color", "display.font.size", set the
           value of "display.font.size"... and so on.
           """
       
           # Note: reset_option relies on set_option, and on key directly
           # it does not fit in to this monkey-patching scheme
       
           global register_option, get_option, set_option, reset_option
       
   18:     def wrap(func):
   54:         def inner(key, *args, **kwds):
   53:             pkey = "{prefix}.{key}".format(prefix=prefix, key=key)
   53:             return func(pkey, *args, **kwds)
       
   54:         return inner
       
   18:     _register_option = register_option
   18:     _get_option = get_option
   18:     _set_option = set_option
   18:     set_option = wrap(set_option)
   18:     get_option = wrap(get_option)
   18:     register_option = wrap(register_option)
   18:     yield None
   18:     set_option = _set_option
   18:     get_option = _get_option
   18:     register_option = _register_option
       
       
       # These factories and methods are handy for use as the validator
       # arg in register_option
       
       
    1: def is_type_factory(_type):
           """
       
           Parameters
           ----------
           `_type` - a type to be compared against (e.g. type(x) == `_type`)
       
           Returns
           -------
           validator - a function of a single argument x , which raises
                       ValueError if type(x) is not equal to `_type`
       
           """
       
    4:     def inner(x):
   23:         if type(x) != _type:
                   msg = "Value must have type '{typ!s}'"
                   raise ValueError(msg.format(typ=_type))
       
    4:     return inner
       
       
    1: def is_instance_factory(_type):
           """
       
           Parameters
           ----------
           `_type` - the type to be checked against
       
           Returns
           -------
           validator - a function of a single argument x , which raises
                       ValueError if x is not an instance of `_type`
       
           """
    6:     if isinstance(_type, (tuple, list)):
    6:         _type = tuple(_type)
    6:         type_repr = "|".join(map(str, _type))
           else:
               type_repr = "'{typ}'".format(typ=_type)
       
    6:     def inner(x):
    8:         if not isinstance(x, _type):
                   msg = "Value must be an instance of {type_repr}"
                   raise ValueError(msg.format(type_repr=type_repr))
       
    6:     return inner
       
       
    1: def is_one_of_factory(legal_values):
       
   34:     callables = [c for c in legal_values if callable(c)]
   34:     legal_values = [c for c in legal_values if not callable(c)]
       
    7:     def inner(x):
    7:         if x not in legal_values:
       
                   if not any(c(x) for c in callables):
                       uvals = [str(lval) for lval in legal_values]
                       pp_values = "|".join(uvals)
                       msg = "Value must be one of {pp_values}"
                       if len(callables):
                           msg += " or a callable"
                       raise ValueError(msg.format(pp_values=pp_values))
       
    7:     return inner
       
       
       # common type validators, for convenience
       # usage: register_option(... , validator = is_int)
    1: is_int = is_type_factory(int)
    1: is_bool = is_type_factory(bool)
    1: is_float = is_type_factory(float)
    1: is_str = is_type_factory(str)
    1: is_text = is_instance_factory((str, bytes))
       
       
    1: def is_callable(obj):
           """
       
           Parameters
           ----------
           `obj` - the object to be checked
       
           Returns
           -------
           validator - returns True if object is callable
               raises ValueError otherwise.
       
           """
           if not callable(obj):
               raise ValueError("Value must be a callable")
           return True
