    1: from __future__ import unicode_literals
       
    1: from prompt_toolkit.cache import FastDictCache
    1: from prompt_toolkit.utils import get_cwidth
       
    1: from collections import defaultdict, namedtuple
       
       __all__ = [
    1:     'Point',
    1:     'Size',
    1:     'Screen',
    1:     'Char',
       ]
       
       
    1: Point = namedtuple('Point', 'x y')
    1: Size = namedtuple('Size', 'rows columns')
       
       
    2: class Char(object):
           """
           Represent a single character in a :class:`.Screen`.
       
           This should be considered immutable.
       
           :param char: A single character (can be a double-width character).
           :param style: A style string. (Can contain classnames.)
    1:     """
    1:     __slots__ = ('char', 'style', 'width')
       
           # If we end up having one of these special control sequences in the input string,
           # we should display them as follows:
           # Usually this happens after a "quoted insert".
           display_mappings = {
    1:         '\x00': '^@',  # Control space
    1:         '\x01': '^A',
    1:         '\x02': '^B',
    1:         '\x03': '^C',
    1:         '\x04': '^D',
    1:         '\x05': '^E',
    1:         '\x06': '^F',
    1:         '\x07': '^G',
    1:         '\x08': '^H',
    1:         '\x09': '^I',
    1:         '\x0a': '^J',
    1:         '\x0b': '^K',
    1:         '\x0c': '^L',
    1:         '\x0d': '^M',
    1:         '\x0e': '^N',
    1:         '\x0f': '^O',
    1:         '\x10': '^P',
    1:         '\x11': '^Q',
    1:         '\x12': '^R',
    1:         '\x13': '^S',
    1:         '\x14': '^T',
    1:         '\x15': '^U',
    1:         '\x16': '^V',
    1:         '\x17': '^W',
    1:         '\x18': '^X',
    1:         '\x19': '^Y',
    1:         '\x1a': '^Z',
    1:         '\x1b': '^[',  # Escape
    1:         '\x1c': '^\\',
    1:         '\x1d': '^]',
    1:         '\x1f': '^_',
    1:         '\x7f': '^?',  # ASCII Delete (backspace).
       
               # Special characters. All visualized like Vim does.
    1:         '\x80': '<80>',
    1:         '\x81': '<81>',
    1:         '\x82': '<82>',
    1:         '\x83': '<83>',
    1:         '\x84': '<84>',
    1:         '\x85': '<85>',
    1:         '\x86': '<86>',
    1:         '\x87': '<87>',
    1:         '\x88': '<88>',
    1:         '\x89': '<89>',
    1:         '\x8a': '<8a>',
    1:         '\x8b': '<8b>',
    1:         '\x8c': '<8c>',
    1:         '\x8d': '<8d>',
    1:         '\x8e': '<8e>',
    1:         '\x8f': '<8f>',
       
    1:         '\x90': '<90>',
    1:         '\x91': '<91>',
    1:         '\x92': '<92>',
    1:         '\x93': '<93>',
    1:         '\x94': '<94>',
    1:         '\x95': '<95>',
    1:         '\x96': '<96>',
    1:         '\x97': '<97>',
    1:         '\x98': '<98>',
    1:         '\x99': '<99>',
    1:         '\x9a': '<9a>',
    1:         '\x9b': '<9b>',
    1:         '\x9c': '<9c>',
    1:         '\x9d': '<9d>',
    1:         '\x9e': '<9e>',
    1:         '\x9f': '<9f>',
       
               # For the non-breaking space: visualize like Emacs does by default.
               # (Print a space, but attach the 'nbsp' class that applies the
               # underline style.)
    1:         '\xa0': ' ',
           }
       
    1:     def __init__(self, char=' ', style=''):
               # If this character has to be displayed otherwise, take that one.
               if char in self.display_mappings:
                   if char == '\xa0':
                       style += ' class:nbsp '  # Will be underlined.
                   else:
                       style += ' class:control-character '
       
                   char = self.display_mappings[char]
       
               self.char = char
               self.style = style
       
               # Calculate width. (We always need this, so better to store it directly
               # as a member for performance.)
               self.width = get_cwidth(char)
       
    1:     def __eq__(self, other):
               return self.char == other.char and self.style == other.style
       
    1:     def __ne__(self, other):
               # Not equal: We don't do `not char.__eq__` here, because of the
               # performance of calling yet another function.
               return self.char != other.char or self.style != other.style
       
    1:     def __repr__(self):
               return '%s(%r, %r)' % (self.__class__.__name__, self.char, self.style)
       
       
    1: _CHAR_CACHE = FastDictCache(Char, size=1000 * 1000)
    1: Transparent = '[transparent]'
       
       
    2: class Screen(object):
           """
           Two dimensional buffer of :class:`.Char` instances.
    1:     """
    1:     def __init__(self, default_char=None, initial_width=0, initial_height=0):
               if default_char is None:
                   default_char = _CHAR_CACHE[' ', Transparent]
       
               self.data_buffer = defaultdict(lambda: defaultdict(lambda: default_char))
       
               #: Escape sequences to be injected.
               self.zero_width_escapes = defaultdict(lambda: defaultdict(lambda: ''))
       
               #: Position of the cursor.
               self.cursor_positions = {}  # Map `Window` objects to `Point` objects.
       
               #: Visibility of the cursor.
               self.show_cursor = True
       
               #: (Optional) Where to position the menu. E.g. at the start of a completion.
               #: (We can't use the cursor position, because we don't want the
               #: completion menu to change its position when we browse through all the
               #: completions.)
               self.menu_positions = {}  # Map `Window` objects to `Point` objects.
       
               #: Currently used width/height of the screen. This will increase when
               #: data is written to the screen.
               self.width = initial_width or 0
               self.height = initial_height or 0
       
               # Windows that have been drawn. (Each `Window` class will add itself to
               # this list.)
               self.visible_windows = []
       
               self._draw_float_functions = []  # List of (z_index, draw_func)
       
    1:     def set_cursor_position(self, window, position):
               " Set the cursor position for a given window. "
               self.cursor_positions[window] = position
       
    1:     def set_menu_position(self, window, position):
               " Set the cursor position for a given window. "
               self.menu_positions[window] = position
       
    1:     def get_cursor_position(self, window):
               """
               Get the cursor position for a given window.
               Returns a `Point`.
               """
               try:
                   return self.cursor_positions[window]
               except KeyError:
                   return Point(x=0, y=0)
       
    1:     def get_menu_position(self, window):
               """
               Get the menu position for a given window.
               (This falls back to the cursor position if no menu position was set.)
               """
               try:
                   return self.menu_positions[window]
               except KeyError:
                   try:
                       return self.cursor_positions[window]
                   except KeyError:
                       return Point(x=0, y=0)
       
    1:     def draw_with_z_index(self, z_index, draw_func):
               """
               Add a draw-function for a `Window` which has a >= 0 z_index.
               This will be postponed until `draw_all_floats` is called.
               """
               assert isinstance(z_index, int), z_index
               assert callable(draw_func)
       
               self._draw_float_functions.append((z_index, draw_func))
       
    1:     def draw_all_floats(self):
               """
               Draw all float functions in order of z-index.
               """
               # We keep looping because some draw functions could add new functions
               # to this list. See `FloatContainer`.
               while self._draw_float_functions:
                   # Sort the floats that we have so far by z_index.
                   functions = sorted(self._draw_float_functions, key=lambda item: item[0])
       
                   # Draw only one at a time, then sort everything again. Now floats
                   # might have been added.
                   self._draw_float_functions = functions[1:]
                   functions[0][1]()
       
    1:     def append_style_to_content(self, style_str):
               """
               For all the characters in the screen.
               Set the style string to the given `style_str`.
               """
               b = self.data_buffer
               char_cache = _CHAR_CACHE
       
               append_style = ' ' + style_str
       
               for y, row in b.items():
                   for x, char in row.items():
                       b[y][x] = char_cache[char.char, char.style + append_style]
       
    1:     def fill_area(self, write_position, style='', after=False):
               """
               Fill the content of this area, using the given `style`.
               The style is prepended before whatever was here before.
               """
               if not style.strip():
                   return
       
               xmin = write_position.xpos
               xmax = write_position.xpos + write_position.width
               char_cache = _CHAR_CACHE
               data_buffer = self.data_buffer
       
               if after:
                   append_style = ' ' + style
                   prepend_style = ''
               else:
                   append_style = ''
                   prepend_style = style + ' '
       
               for y in range(write_position.ypos, write_position.ypos + write_position.height):
                   row = data_buffer[y]
                   for x in range(xmin, xmax):
                       cell = row[x]
                       row[x] = char_cache[cell.char, prepend_style + cell.style + append_style]
       
       
    2: class WritePosition(object):
    1:     def __init__(self, xpos, ypos, width, height):
               assert height >= 0
               assert width >= 0
               # xpos and ypos can be negative. (A float can be partially visible.)
       
               self.xpos = xpos
               self.ypos = ypos
               self.width = width
               self.height = height
       
    1:     def __repr__(self):
               return '%s(x=%r, y=%r, width=%r, height=%r)' % (
                   self.__class__.__name__,
                   self.xpos, self.ypos, self.width, self.height)
